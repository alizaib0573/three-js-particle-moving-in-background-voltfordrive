var requirejs, require, define;
! function(ba) {
    function G(t) {
        return "[object Function]" === K.call(t)
    }

    function H(t) {
        return "[object Array]" === K.call(t)
    }

    function v(t, e) {
        if (t)
            for (var i = 0; i < t.length && (!t[i] || !e(t[i], i, t)); i += 1);
    }

    function T(t, e) {
        if (t)
            for (var i = t.length - 1; - 1 < i && (!t[i] || !e(t[i], i, t)); --i);
    }

    function t(t, e) {
        return fa.call(t, e)
    }

    function m(e, i) {
        return t(e, i) && e[i]
    }

    function B(e, i) {
        for (var n in e)
            if (t(e, n) && i(e[n], n)) break
    }

    function U(n, e, r, s) {
        return e && B(e, function(e, i) {
            !r && t(n, i) || (!s || "object" != typeof e || !e || H(e) || G(e) || e instanceof RegExp ? n[i] = e : (n[i] || (n[i] = {}), U(n[i], e, r, s)))
        }), n
    }

    function u(t, e) {
        return function() {
            return e.apply(t, arguments)
        }
    }

    function ca(t) {
        throw t
    }

    function da(t) {
        if (!t) return t;
        var e = ba;
        return v(t.split("."), function(t) {
            e = e[t]
        }), e
    }

    function C(t, e, i, n) {
        return (e = Error(e + "\nhttp://requirejs.org/docs/errors.html#" + t)).requireType = t, e.requireModules = n, i && (e.originalError = i), e
    }

    function ga(h) {
        function d(t, e, i) {
            var n, r, s, a, o, l, h, c, e = e && e.split("/"),
                u = L.map,
                d = u && u["*"];
            if (t) {
                for (r = (t = t.split("/")).length - 1, L.nodeIdCompat && Q.test(t[r]) && (t[r] = t[r].replace(Q, "")), "." === t[0].charAt(0) && e && (t = (r = e.slice(0, e.length - 1)).concat(t)), r = t, s = 0; s < r.length; s++) "." === (a = r[s]) ? (r.splice(s, 1), --s) : ".." === a && 0 !== s && (1 != s || ".." !== r[2]) && ".." !== r[s - 1] && 0 < s && (r.splice(s - 1, 2), s -= 2);
                t = t.join("/")
            }
            if (i && u && (e || d)) {
                s = (r = t.split("/")).length;
                t: for (; 0 < s; --s) {
                    if (o = r.slice(0, s).join("/"), e)
                        for (a = e.length; 0 < a; --a)
                            if ((i = m(u, e.slice(0, a).join("/"))) && (i = m(i, o))) {
                                n = i, l = s;
                                break t
                            }!h && d && m(d, o) && (h = m(d, o), c = s)
                }!n && h && (n = h, l = c), n && (r.splice(0, l, n), t = r.join("/"))
            }
            return (n = m(L.pkgs, t)) ? n : t
        }

        function c(e) {
            z && v(document.getElementsByTagName("script"), function(t) {
                if (t.getAttribute("data-requiremodule") === e && t.getAttribute("data-requirecontext") === A.contextName) return t.parentNode.removeChild(t), !0
            })
        }

        function p(t) {
            var e = m(L.paths, t);
            return e && H(e) && 1 < e.length && (e.shift(), A.require.undef(t), A.makeRequire(null, {
                skipMap: !0
            })([t]), 1)
        }

        function f(t) {
            var e, i = t ? t.indexOf("!") : -1;
            return -1 < i && (e = t.substring(0, i), t = t.substring(i + 1, t.length)), [e, t]
        }

        function _(t, e, i, n) {
            var r, s, a = null,
                o = e ? e.name : null,
                l = t,
                h = !0,
                c = "";
            return t || (h = !1, t = "_@r" + (V += 1)), a = (t = f(t))[0], t = t[1], a && (a = d(a, o, n), s = m(I, a)), t && (a ? c = s && s.normalize ? s.normalize(t, function(t) {
                return d(t, o, n)
            }) : -1 === t.indexOf("!") ? d(t, o, n) : t : (a = (t = f(c = d(t, o, n)))[0], c = t[1], i = !0, r = A.nameToUrl(c))), {
                prefix: a,
                name: c,
                parentMap: e,
                unnormalized: !!(i = !a || s || i ? "" : "_unnormalized" + (j += 1)),
                url: r,
                originalName: l,
                isDefine: h,
                id: (a ? a + "!" + c : c) + i
            }
        }

        function y(t) {
            var e = t.id;
            return m(O, e) || (O[e] = new A.Module(t))
        }

        function s(e, i, n) {
            var r = e.id,
                s = m(O, r);
            !t(I, r) || s && !s.defineEmitComplete ? (s = y(e)).error && "error" === i ? n(s.error) : s.on(i, n) : "defined" === i && n(I[r])
        }

        function x(e, t) {
            var i = e.requireModules,
                n = !1;
            t ? t(e) : (v(i, function(t) {
                (t = m(O, t)) && (t.error = e, t.events.error && (n = !0, t.emit("error", e)))
            }), n || g.onError(e))
        }

        function b() {
            R.length && (ha.apply(k, [k.length, 0].concat(R)), R = [])
        }

        function w(t) {
            delete O[t], delete D[t]
        }

        function E() {
            var t, n, r = (t = 1e3 * L.waitSeconds) && A.startTime + t < (new Date).getTime(),
                s = [],
                a = [],
                o = !1,
                l = !0;
            if (!e) {
                if (e = !0, B(D, function(t) {
                        var e = t.map,
                            i = e.id;
                        if (t.enabled && (e.isDefine || a.push(t), !t.error))
                            if (!t.inited && r) p(i) ? o = n = !0 : (s.push(i), c(i));
                            else if (!t.inited && t.fetched && e.isDefine && (o = !0, !e.prefix)) return l = !1
                    }), r && s.length) return (t = C("timeout", "Load timeout for modules: " + s, null, s)).contextName = A.contextName, x(t), 0;
                l && v(a, function(t) {
                    ! function n(r, s, a) {
                        var t = r.map.id;
                        r.error ? r.emit("error", r.error) : (s[t] = !0, v(r.depMaps, function(t, e) {
                            var i = t.id,
                                t = m(O, i);
                            !t || r.depMatched[e] || a[i] || (m(s, i) ? (r.defineDep(e, I[i]), r.check()) : n(t, s, a))
                        }), a[t] = !0)
                    }(t, {}, {})
                }), r && !n || !o || !z && !ea || P || (P = setTimeout(function() {
                    P = 0, E()
                }, 50)), e = !1
            }
        }

        function a(e) {
            t(I, e[0]) || y(_(e[0], null, !0)).init(e[1], e[2])
        }

        function i(t) {
            var t = t.currentTarget || t.srcElement,
                e = A.onScriptLoad;
            return t.detachEvent && !Y ? t.detachEvent("onreadystatechange", e) : t.removeEventListener("load", e, !1), e = A.onScriptError, t.detachEvent && !Y || t.removeEventListener("error", e, !1), {
                node: t,
                id: t && t.getAttribute("data-requiremodule")
            }
        }

        function S() {
            var t;
            for (b(); k.length;) {
                if (null === (t = k.shift())[0]) return x(C("mismatch", "Mismatched anonymous define() module: " + t[t.length - 1])), 0;
                a(t)
            }
        }
        var e, A, P, L = {
                waitSeconds: 7,
                baseUrl: "./",
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            O = {},
            D = {},
            n = {},
            k = [],
            I = {},
            r = {},
            F = {},
            V = 1,
            j = 1,
            W = {
                require: function(t) {
                    return t.require || (t.require = A.makeRequire(t.map))
                },
                exports: function(t) {
                    if (t.usingExports = !0, t.map.isDefine) return t.exports ? I[t.map.id] = t.exports : t.exports = I[t.map.id] = {}
                },
                module: function(t) {
                    return t.module || (t.module = {
                        id: t.map.id,
                        uri: t.map.url,
                        config: function() {
                            return m(L.config, t.map.id) || {}
                        },
                        exports: t.exports || (t.exports = {})
                    })
                }
            },
            o = function(t) {
                this.events = m(n, t.id) || {}, this.map = t, this.shim = m(L.shim, t.id), this.depExports = [], this.depMaps = [], this.depMatched = [], this.pluginMaps = {}, this.depCount = 0
            };
        return o.prototype = {
            init: function(t, e, i, n) {
                n = n || {}, this.inited || (this.factory = e, i ? this.on("error", i) : this.events.error && (i = u(this, function(t) {
                    this.emit("error", t)
                })), this.depMaps = t && t.slice(0), this.errback = i, this.inited = !0, this.ignore = n.ignore, n.enabled || this.enabled ? this.enable() : this.check())
            },
            defineDep: function(t, e) {
                this.depMatched[t] || (this.depMatched[t] = !0, --this.depCount, this.depExports[t] = e)
            },
            fetch: function() {
                if (!this.fetched) {
                    this.fetched = !0, A.startTime = (new Date).getTime();
                    var t = this.map;
                    if (!this.shim) return t.prefix ? this.callPlugin() : this.load();
                    A.makeRequire(this.map, {
                        enableBuildCallback: !0
                    })(this.shim.deps || [], u(this, function() {
                        return t.prefix ? this.callPlugin() : this.load()
                    }))
                }
            },
            load: function() {
                var t = this.map.url;
                r[t] || (r[t] = !0, A.load(this.map.id, t))
            },
            check: function() {
                if (this.enabled && !this.enabling) {
                    var e, t = this.map.id,
                        i = this.depExports,
                        n = this.exports,
                        r = this.factory;
                    if (this.inited) {
                        if (this.error) this.emit("error", this.error);
                        else if (!this.defining) {
                            if (this.defining = !0, this.depCount < 1 && !this.defined) {
                                if (G(r)) {
                                    if (this.events.error && this.map.isDefine || g.onError !== ca) try {
                                        n = A.execCb(t, r, i, n)
                                    } catch (t) {
                                        e = t
                                    } else n = A.execCb(t, r, i, n);
                                    if (this.map.isDefine && void 0 === n && ((i = this.module) ? n = i.exports : this.usingExports && (n = this.exports)), e) return e.requireMap = this.map, e.requireModules = this.map.isDefine ? [this.map.id] : null, e.requireType = this.map.isDefine ? "define" : "require", x(this.error = e)
                                } else n = r;
                                this.exports = n, this.map.isDefine && !this.ignore && (I[t] = n, g.onResourceLoad) && g.onResourceLoad(A, this.map, this.depMaps), w(t), this.defined = !0
                            }
                            this.defining = !1, this.defined && !this.defineEmitted && (this.defineEmitted = !0, this.emit("defined", this.exports), this.defineEmitComplete = !0)
                        }
                    } else this.fetch()
                }
            },
            callPlugin: function() {
                var l = this.map,
                    h = l.id,
                    e = _(l.prefix);
                this.depMaps.push(e), s(e, "defined", u(this, function(e) {
                    var a, i = m(F, this.map.id),
                        n = this.map.name,
                        r = this.map.parentMap ? this.map.parentMap.name : null,
                        o = A.makeRequire(l.parentMap, {
                            enableBuildCallback: !0
                        });
                    this.map.unnormalized ? (e.normalize && (n = e.normalize(n, function(t) {
                        return d(t, r, !0)
                    }) || ""), s(e = _(l.prefix + "!" + n, this.map.parentMap), "defined", u(this, function(t) {
                        this.init([], function() {
                            return t
                        }, null, {
                            enabled: !0,
                            ignore: !0
                        })
                    })), (i = m(O, e.id)) && (this.depMaps.push(e), this.events.error && i.on("error", u(this, function(t) {
                        this.emit("error", t)
                    })), i.enable())) : i ? (this.map.url = A.nameToUrl(i), this.load()) : ((a = u(this, function(t) {
                        this.init([], function() {
                            return t
                        }, null, {
                            enabled: !0
                        })
                    })).error = u(this, function(t) {
                        this.inited = !0, (this.error = t).requireModules = [h], B(O, function(t) {
                            0 === t.map.id.indexOf(h + "_unnormalized") && w(t.map.id)
                        }), x(t)
                    }), a.fromText = u(this, function(e, i) {
                        var n = l.name,
                            r = _(n),
                            s = M;
                        i && (e = i), s && (M = !1), y(r), t(L.config, h) && (L.config[n] = L.config[h]);
                        try {
                            g.exec(e)
                        } catch (t) {
                            return x(C("fromtexteval", "fromText eval for " + h + " failed: " + t, t, [h]))
                        }
                        s && (M = !0), this.depMaps.push(r), A.completeLoad(n), o([n], a)
                    }), e.load(l.name, o, a, L))
                })), A.enable(e, this), this.pluginMaps[e.id] = e
            },
            enable: function() {
                (D[this.map.id] = this).enabling = this.enabled = !0, v(this.depMaps, u(this, function(e, i) {
                    var n, r;
                    if ("string" == typeof e) {
                        if (e = _(e, this.map.isDefine ? this.map : this.map.parentMap, !1, !this.skipMap), this.depMaps[i] = e, n = m(W, e.id)) return void(this.depExports[i] = n(this));
                        this.depCount += 1, s(e, "defined", u(this, function(t) {
                            this.defineDep(i, t), this.check()
                        })), this.errback && s(e, "error", u(this, this.errback))
                    }
                    n = e.id, r = O[n], t(W, n) || !r || r.enabled || A.enable(e, this)
                })), B(this.pluginMaps, u(this, function(t) {
                    var e = m(O, t.id);
                    e && !e.enabled && A.enable(t, this)
                })), this.enabling = !1, this.check()
            },
            on: function(t, e) {
                (this.events[t] || (this.events[t] = [])).push(e)
            },
            emit: function(t, e) {
                v(this.events[t], function(t) {
                    t(e)
                }), "error" === t && delete this.events[t]
            }
        }, (A = {
            config: L,
            contextName: h,
            registry: O,
            defined: I,
            urlFetched: r,
            defQueue: k,
            Module: o,
            makeModuleMap: _,
            nextTick: g.nextTick,
            onError: x,
            configure: function(t) {
                t.baseUrl && "/" !== t.baseUrl.charAt(t.baseUrl.length - 1) && (t.baseUrl += "/");
                var i = L.shim,
                    n = {
                        paths: !0,
                        bundles: !0,
                        config: !0,
                        map: !0
                    };
                B(t, function(t, e) {
                    n[e] ? (L[e] || (L[e] = {}), U(L[e], t, !0, !0)) : L[e] = t
                }), t.bundles && B(t.bundles, function(t, e) {
                    v(t, function(t) {
                        t !== e && (F[t] = e)
                    })
                }), t.shim && (B(t.shim, function(t, e) {
                    H(t) && (t = {
                        deps: t
                    }), !t.exports && !t.init || t.exportsFn || (t.exportsFn = A.makeShimExports(t)), i[e] = t
                }), L.shim = i), t.packages && v(t.packages, function(t) {
                    var e = (t = "string" == typeof t ? {
                        name: t
                    } : t).name;
                    t.location && (L.paths[e] = t.location), L.pkgs[e] = t.name + "/" + (t.main || "main").replace(ia, "").replace(Q, "")
                }), B(O, function(t, e) {
                    t.inited || t.map.unnormalized || (t.map = _(e))
                }), (t.deps || t.callback) && A.require(t.deps || [], t.callback)
            },
            makeShimExports: function(e) {
                return function() {
                    var t;
                    return e.init && (t = e.init.apply(ba, arguments)), t || e.exports && da(e.exports)
                }
            },
            makeRequire: function(a, o) {
                function l(e, i, n) {
                    var r, s;
                    return o.enableBuildCallback && i && G(i) && (i.__requireJsBuild = !0), "string" == typeof e ? G(i) ? x(C("requireargs", "Invalid require call"), n) : a && t(W, e) ? W[e](O[a.id]) : g.get ? g.get(A, e, a, l) : (r = _(e, a, !1, !0).id, t(I, r) ? I[r] : x(C("notloaded", 'Module name "' + r + '" has not been loaded yet for context: ' + h + (a ? "" : ". Use require([])")))) : (S(), A.nextTick(function() {
                        S(), (s = y(_(null, a))).skipMap = o.skipMap, s.init(e, i, n, {
                            enabled: !0
                        }), E()
                    }), l)
                }
                return o = o || {}, U(l, {
                    isBrowser: z,
                    toUrl: function(t) {
                        var e, i = t.lastIndexOf("."),
                            n = t.split("/")[0];
                        return -1 !== i && ("." !== n && ".." !== n || 1 < i) && (e = t.substring(i, t.length), t = t.substring(0, i)), A.nameToUrl(d(t, a && a.id, !0), e, !0)
                    },
                    defined: function(e) {
                        return t(I, _(e, a, !1, !0).id)
                    },
                    specified: function(e) {
                        return e = _(e, a, !1, !0).id, t(I, e) || t(O, e)
                    }
                }), a || (l.undef = function(i) {
                    b();
                    var t = _(i, a, !0),
                        e = m(O, i);
                    c(i), delete I[i], delete r[t.url], delete n[i], T(k, function(t, e) {
                        t[0] === i && k.splice(e, 1)
                    }), e && (e.events.defined && (n[i] = e.events), w(i))
                }), l
            },
            enable: function(t) {
                m(O, t.id) && y(t).enable()
            },
            completeLoad: function(e) {
                var i, n, r = m(L.shim, e) || {},
                    s = r.exports;
                for (b(); k.length;) {
                    if (null === (n = k.shift())[0]) {
                        if (n[0] = e, i) break;
                        i = !0
                    } else n[0] === e && (i = !0);
                    a(n)
                }
                if (n = m(O, e), !i && !t(I, e) && n && !n.inited) {
                    if (L.enforceDefine && (!s || !da(s))) return p(e) ? void 0 : x(C("nodefine", "No define call for " + e, null, [e]));
                    a([e, r.deps || [], r.exportsFn])
                }
                E()
            },
            nameToUrl: function(t, e, i) {
                var n, r, s;
                if ((n = m(L.pkgs, t)) && (t = n), n = m(F, t)) return A.nameToUrl(n, e, i);
                if (g.jsExtRegExp.test(t)) n = t + (e || "");
                else {
                    for (n = L.paths, r = (t = t.split("/")).length; 0 < r; --r)
                        if (s = m(n, s = t.slice(0, r).join("/"))) {
                            H(s) && (s = s[0]), t.splice(0, r, s);
                            break
                        }
                    n = t.join("/"), n = ("/" === (n += e || (/^data\:|\?/.test(n) || i ? "" : ".js")).charAt(0) || n.match(/^[\w\+\.\-]+:/) ? "" : L.baseUrl) + n
                }
                return L.urlArgs ? n + ((-1 === n.indexOf("?") ? "?" : "&") + L.urlArgs) : n
            },
            load: function(t, e) {
                g.load(A, t, e)
            },
            execCb: function(t, e, i, n) {
                return e.apply(n, i)
            },
            onScriptLoad: function(t) {
                "load" !== t.type && !ja.test((t.currentTarget || t.srcElement).readyState) || (N = null, t = i(t), A.completeLoad(t.id))
            },
            onScriptError: function(t) {
                var e = i(t);
                if (!p(e.id)) return x(C("scripterror", "Script error for: " + e.id, t, [e.id]))
            }
        }).require = A.makeRequire(), A
    }
    var g, x, y, D, I, E, N, J, s, O, ka = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,
        la = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        Q = /\.js$/,
        ia = /^\.\//,
        x = Object.prototype,
        K = x.toString,
        fa = x.hasOwnProperty,
        ha = Array.prototype.splice,
        z = !("undefined" == typeof window || "undefined" == typeof navigator || !window.document),
        ea = !z && "undefined" != typeof importScripts,
        ja = z && "PLAYSTATION 3" === navigator.platform ? /^complete$/ : /^(complete|loaded)$/,
        Y = "undefined" != typeof opera && "[object Opera]" === opera.toString(),
        F = {},
        q = {},
        R = [],
        M = !1;
    if (void 0 === define) {
        if (void 0 !== requirejs) {
            if (G(requirejs)) return;
            q = requirejs, requirejs = void 0
        }
        void 0 === require || G(require) || (q = require, require = void 0), g = requirejs = function(t, e, i, n) {
            var r, s = "_";
            return H(t) || "string" == typeof t || (r = t, H(e) ? (t = e, e = i, i = n) : t = []), r && r.context && (s = r.context), (n = m(F, s)) || (n = F[s] = g.s.newContext(s)), r && n.configure(r), n.require(t, e, i)
        }, g.config = function(t) {
            return g(t)
        }, g.nextTick = "undefined" != typeof setTimeout ? function(t) {
            setTimeout(t, 4)
        } : function(t) {
            t()
        }, require = require || g, g.version = "2.1.15", g.jsExtRegExp = /^\/|:|\?|\.js$/, g.isBrowser = z, x = g.s = {
            contexts: F,
            newContext: ga
        }, g({}), v(["toUrl", "undef", "defined", "specified"], function(e) {
            g[e] = function() {
                var t = F._;
                return t.require[e].apply(t, arguments)
            }
        }), z && (y = x.head = document.getElementsByTagName("head")[0], D = document.getElementsByTagName("base")[0]) && (y = x.head = D.parentNode), g.onError = ca, g.createNode = function(t) {
            var e = t.xhtml ? document.createElementNS("http://www.w3.org/1999/xhtml", "html:script") : document.createElement("script");
            return e.type = t.scriptType || "text/javascript", e.charset = "utf-8", e.async = !0, e
        }, g.load = function(e, i, n) {
            var t = e && e.config || {};
            if (z) return (t = g.createNode(t, i, n)).setAttribute("data-requirecontext", e.contextName), t.setAttribute("data-requiremodule", i), !t.attachEvent || t.attachEvent.toString && t.attachEvent.toString().indexOf("[native code") < 0 || Y ? (t.addEventListener("load", e.onScriptLoad, !1), t.addEventListener("error", e.onScriptError, !1)) : (M = !0, t.attachEvent("onreadystatechange", e.onScriptLoad)), t.src = n, J = t, D ? y.insertBefore(t, D) : y.appendChild(t), J = null, t;
            if (ea) try {
                importScripts(n), e.completeLoad(i)
            } catch (t) {
                e.onError(C("importscripts", "importScripts failed for " + i + " at " + n, t, [i]))
            }
        }, z && !q.skipDataMain && T(document.getElementsByTagName("script"), function(t) {
            if (y = y || t.parentNode, I = t.getAttribute("data-main")) return s = I, q.baseUrl || (s = (E = s.split("/")).pop(), O = E.length ? E.join("/") + "/" : "./", q.baseUrl = O), s = s.replace(Q, ""), g.jsExtRegExp.test(s) && (s = I), q.deps = q.deps ? q.deps.concat(s) : [s], !0
        }), define = function(t, i, e) {
            var n, r;
            "string" != typeof t && (e = i, i = t, t = null), H(i) || (e = i, i = null), !i && G(e) && (i = [], e.length && (e.toString().replace(ka, "").replace(la, function(t, e) {
                i.push(e)
            }), i = (1 === e.length ? ["require"] : ["require", "exports", "module"]).concat(i))), M && ((n = J) || (N && "interactive" === N.readyState || T(document.getElementsByTagName("script"), function(t) {
                if ("interactive" === t.readyState) return N = t
            }), n = N), n && (t = t || n.getAttribute("data-requiremodule"), r = F[n.getAttribute("data-requirecontext")])), (r ? r.defQueue : R).push([t, i, e])
        }, define.amd = {
            jQuery: !0
        }, g.exec = function(b) {
            return eval(b)
        }, g(q)
    }
}(this), define("requireLib", function() {}), define("utils/EventEmitter", [], function() {
    "use strict";
    return function() {
        this._handlers = {
            all: []
        }, this.dispatch = function(t, e) {
            e || (e = t, t = "all"), e && e.type.indexOf(":") && (t = e.type.split(":")[0]), this._handlers.hasOwnProperty(t) || (this._handlers[t] = []), this._handlers[t].forEach(function(t) {
                t(e)
            }), "all" !== t && this._handlers.all.forEach(function(t) {
                t(e)
            })
        }, this.subscribe = function(t, e) {
            e || (e = t, t = "all"), "function" == typeof e ? (this._handlers.hasOwnProperty(t) || (this._handlers[t] = []), -1 === this._handlers[t].indexOf(e) ? this._handlers[t].push(e) : console.log("handler already set")) : console.log("handler has to be a function")
        }, this.unsubscribe = function(t, e) {
            e || (e = t, t = "all"), "function" == typeof e ? this._handlers[t] ? -1 !== this._handlers[t].indexOf(e) ? this._handlers[t] = this._handlers[t].filter(function(t) {
                return t !== e
            }) : console.log("trying to unsubscribe unexisting handler") : console.log("channel " + t + "  does not exist") : console.log("handler has to be a function")
        }
    }
}), define("dispatcher", ["utils/EventEmitter"], function(t) {
    return new t
});
var NEWTON_ITERATIONS = 4,
    NEWTON_MIN_SLOPE = .001,
    SUBDIVISION_PRECISION = 1e-7,
    SUBDIVISION_MAX_ITERATIONS = 10,
    kSplineTableSize = 11,
    kSampleStepSize = 1 / (kSplineTableSize - 1),
    float32ArraySupported = "function" == typeof Float32Array;

function A(t, e) {
    return 1 - 3 * e + 3 * t
}

function B(t, e) {
    return 3 * e - 6 * t
}

function C(t) {
    return 3 * t
}

function calcBezier(t, e, i) {
    return ((A(e, i) * t + B(e, i)) * t + C(e)) * t
}

function getSlope(t, e, i) {
    return 3 * A(e, i) * t * t + 2 * B(e, i) * t + C(e)
}

function binarySubdivide(t, e, i, n, r) {
    for (var s, a, o = 0; 0 < (s = calcBezier(a = e + (i - e) / 2, n, r) - t) ? i = a : e = a, Math.abs(s) > SUBDIVISION_PRECISION && ++o < SUBDIVISION_MAX_ITERATIONS;);
    return a
}

function newtonRaphsonIterate(t, e, i, n) {
    for (var r = 0; r < NEWTON_ITERATIONS; ++r) {
        var s = getSlope(e, i, n);
        if (0 === s) return e;
        e -= (calcBezier(e, i, n) - t) / s
    }
    return e
}

function bezier(a, e, o, i) {
    if (!(0 <= a && a <= 1 && 0 <= o && o <= 1)) throw new Error("bezier x values must be in [0, 1] range");
    var l = new(float32ArraySupported ? Float32Array : Array)(kSplineTableSize);
    if (a !== e || o !== i)
        for (var t = 0; t < kSplineTableSize; ++t) l[t] = calcBezier(t * kSampleStepSize, a, o);
    return function(t) {
        return a === e && o === i ? t : 0 === t ? 0 : 1 === t ? 1 : calcBezier(function(t) {
            for (var e = 0, i = 1, n = kSplineTableSize - 1; i !== n && l[i] <= t; ++i) e += kSampleStepSize;
            var r = e + (t - l[--i]) / (l[i + 1] - l[i]) * kSampleStepSize,
                s = getSlope(r, a, o);
            return NEWTON_MIN_SLOPE <= s ? newtonRaphsonIterate(t, r, a, o) : 0 === s ? r : binarySubdivide(t, e, e + kSampleStepSize, a, o)
        }(t), e, i)
    }
}
define("bezier", function(t) {
    return function() {
        return t.bezier
    }
}(this));
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";

        function _(t, e, i, n) {
            this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
        }

        function y(t, e, i, n) {
            var r = {
                    a: t
                },
                s = {},
                a = {},
                o = {
                    c: n
                },
                l = (t + e) / 2,
                h = (i + n) / 2,
                c = ((i = ((c = (e + i) / 2) + h) / 2) - (e = (l + c) / 2)) / 8;
            return r.b = l + (t - l) / 4, s.b = e + c, r.c = s.a = (r.b + s.b) / 2, s.c = a.a = (e + i) / 2, a.b = i - c, o.b = h + (n - h) / 4, a.c = o.a = (a.b + o.b) / 2, [r, s, a, o]
        }

        function d(t, e, i, n, r, s) {
            var a, o, l, h, c, u, d, p, f = {},
                m = [],
                g = s || t[0];
            for (o in r = "string" == typeof r ? "," + r + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == e && (e = 1), t[0]) m.push(o);
            if (1 < t.length) {
                for (p = t[t.length - 1], d = !0, a = m.length; - 1 < --a;)
                    if (o = m[a], .05 < Math.abs(g[o] - p[o])) {
                        d = !1;
                        break
                    }
                d && (t = t.concat(), s && t.unshift(s), t.push(t[1]), s = t[t.length - 3])
            }
            for (x.length = b.length = w.length = 0, a = m.length; - 1 < --a;) o = m[a], v[o] = -1 !== r.indexOf("," + o + ","), f[o] = function(t, e, i, n) {
                var r, s, a, o, l, h, c = [];
                if (n)
                    for (s = (t = [n].concat(t)).length; - 1 < --s;) "string" == typeof(h = t[s][e]) && "=" === h.charAt(1) && (t[s][e] = n[e] + Number(h.charAt(0) + h.substr(2)));
                if ((r = t.length - 2) < 0) return c[0] = new _(t[0][e], 0, 0, t[r < -1 ? 0 : 1][e]), c;
                for (s = 0; s < r; s++) a = t[s][e], o = t[s + 1][e], c[s] = new _(a, 0, 0, o), i && (l = t[s + 2][e], x[s] = (x[s] || 0) + (o - a) * (o - a), b[s] = (b[s] || 0) + (l - o) * (l - o));
                return c[s] = new _(t[s][e], 0, 0, t[s + 1][e]), c
            }(t, o, v[o], s);
            for (a = x.length; - 1 < --a;) x[a] = Math.sqrt(x[a]), b[a] = Math.sqrt(b[a]);
            if (!n) {
                for (a = m.length; - 1 < --a;)
                    if (v[o])
                        for (u = (l = f[m[a]]).length - 1, h = 0; h < u; h++) c = l[h + 1].da / b[h] + l[h].da / x[h], w[h] = (w[h] || 0) + c * c;
                for (a = w.length; - 1 < --a;) w[a] = Math.sqrt(w[a])
            }
            for (a = m.length, h = i ? 4 : 1; - 1 < --a;)(function(t, e, i, n, r) {
                for (var s, a, o, l, h, c, u, d, p, f = t.length - 1, m = 0, g = t[0].a, v = 0; v < f; v++) s = (o = t[m]).a, a = o.d, h = t[m + 1].d, h = r ? (u = x[v], p = ((d = b[v]) + u) * e * .25 / (!n && w[v] || .5), a - ((l = a - (a - s) * (n ? .5 * e : 0 !== u ? p / u : 0)) + (((p = a + (h - a) * (n ? .5 * e : 0 !== d ? p / d : 0)) - l) * (3 * u / (u + d) + .5) / 4 || 0))) : a - ((l = a - (a - s) * e * .5) + (p = a + (h - a) * e * .5)) / 2, l += h, p += h, o.c = h = l, o.b = 0 !== v ? g : g = o.a + .6 * (o.c - o.a), o.da = a - s, o.ca = h - s, o.ba = g - s, i ? (c = y(s, g, h, a), t.splice(m, 1, c[0], c[1], c[2], c[3]), m += 4) : m++, g = p;
                (o = t[m]).b = g, o.c = g + .4 * (o.d - g), o.da = o.d - o.a, o.ca = o.c - o.a, o.ba = g - o.a, i && (c = y(o.a, g, o.c, o.d), t.splice(m, 1, c[0], c[1], c[2], c[3]))
            })(l = f[o = m[a]], e, i, n, v[o]), d && (l.splice(0, h), l.splice(l.length - h, h));
            return f
        }
        var T, x, b, w, v, e, g, t;
        _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(n, c, g) {
            function v(t) {
                for (var e = [], i = t.length, n = 0; n !== i; e.push(t[n++]));
                return e
            }

            function _(t, e, i) {
                var n, r, s = t.cycle;
                for (n in s) r = s[n], t[n] = "function" == typeof r ? r.call(e[i], i) : r[i % r.length];
                delete t.cycle
            }
            var y = function(t, e, i) {
                    g.call(this, t, e, i), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = y.prototype.render
                },
                m = 1e-10,
                x = g._internals,
                b = x.isSelector,
                w = x.isArray,
                t = y.prototype = g.to({}, .1, {}),
                T = [];
            y.version = "1.18.0", t.constructor = y, t.kill()._gc = !1, y.killTweensOf = y.killDelayedCallsTo = g.killTweensOf, y.getTweensOf = g.getTweensOf, y.lagSmoothing = g.lagSmoothing, y.ticker = g.ticker, y.render = g.render, t.invalidate = function() {
                return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), g.prototype.invalidate.call(this)
            }, t.updateTo = function(t, e) {
                var i, n = this.ratio,
                    r = this.vars.immediateRender || t.immediateRender;
                for (i in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[i] = t[i];
                if (this._initted || r)
                    if (e) this._initted = !1, r && this.render(0, !0, !0);
                    else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && g._onPluginEvent("_onDisable", this), .998 < this._time / this._duration) {
                    e = this._time;
                    this.render(0, !0, !1), this._initted = !1, this.render(e, !0, !1)
                } else if (0 < this._time || r) {
                    this._initted = !1, this._init();
                    for (var s, a = 1 / (1 - n), o = this._firstPT; o;) s = o.s + o.c, o.c *= a, o.s = s - o.c, o = o._next
                }
                return this
            }, t.render = function(t, e, i) {
                this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                var n, r, s, a, o, l, h = this._dirty ? this.totalDuration() : this._totalDuration,
                    c = this._time,
                    u = this._totalTime,
                    d = this._cycle,
                    p = this._duration,
                    f = this._rawPrevTime;
                if (h <= t ? (this._totalTime = h, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = p, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === p && (!this._initted && this.vars.lazy && !i || (this._startTime === this._timeline._duration && (t = 0), (0 === t || f < 0 || f === m) && f !== t && (i = !0, m < f && (r = "onReverseComplete")), this._rawPrevTime = l = !e || t || f === t ? t : m))) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== u || 0 === p && 0 < f) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === p && (!this._initted && this.vars.lazy && !i || (0 <= f && (i = !0), this._rawPrevTime = l = !e || t || f === t ? t : m))), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (o = p + this._repeatDelay, this._cycle = this._totalTime / o >> 0, 0 !== this._cycle && this._cycle === this._totalTime / o && this._cycle--, this._time = this._totalTime - this._cycle * o, this._yoyo && 0 != (1 & this._cycle) && (this._time = p - this._time), this._time > p ? this._time = p : this._time < 0 && (this._time = 0)), this._easeType ? (a = this._time / p, (1 === (h = this._easeType) || 3 === h && .5 <= a) && (a = 1 - a), 3 === h && (a *= 2), 1 === (o = this._easePower) ? a *= a : 2 === o ? a *= a * a : 3 === o ? a *= a * a * a : 4 === o && (a *= a * a * a * a), 1 === h ? this.ratio = 1 - a : 2 === h ? this.ratio = a : this._time / p < .5 ? this.ratio = a / 2 : this.ratio = 1 - a / 2) : this.ratio = this._ease.getRatio(this._time / p)), c !== this._time || i || d !== this._cycle) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = c, this._totalTime = u, this._rawPrevTime = f, this._cycle = d, x.lazyTweens.push(this), void(this._lazy = [t, e]);
                        this._time && !n ? this.ratio = this._ease.getRatio(this._time / p) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== c && 0 <= t && (this._active = !0), 0 === u && (2 === this._initted && 0 < t && this._init(), this._startAt && (0 <= t ? this._startAt.render(t, e, i) : r = r || "_dummyGS"), this.vars.onStart && (0 === this._totalTime && 0 !== p || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                    this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, e, i), e || this._totalTime === u && !n || this._callback("onUpdate")), this._cycle !== d && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === p && this._rawPrevTime === m && l !== m && (this._rawPrevTime = 0)))
                } else u !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
            }, y.to = function(t, e, i) {
                return new y(t, e, i)
            }, y.from = function(t, e, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new y(t, e, i)
            }, y.fromTo = function(t, e, i, n) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new y(t, e, n)
            }, y.staggerTo = y.allTo = function(t, e, i, n, r, s, a) {
                n = n || 0;

                function o() {
                    i.onComplete && i.onComplete.apply(i.onCompleteScope || this, arguments), r.apply(a || i.callbackScope || this, s || T)
                }
                var l, h, c, u, d = i.delay || 0,
                    p = [],
                    f = i.cycle,
                    m = i.startAt && i.startAt.cycle;
                for (w(t) || ("string" == typeof t && (t = g.selector(t) || t), b(t) && (t = v(t))), t = t || [], n < 0 && ((t = v(t)).reverse(), n *= -1), l = t.length - 1, c = 0; c <= l; c++) {
                    for (u in h = {}, i) h[u] = i[u];
                    if (f && _(h, t, c), m) {
                        for (u in m = h.startAt = {}, i.startAt) m[u] = i.startAt[u];
                        _(h.startAt, t, c)
                    }
                    h.delay = d, c === l && r && (h.onComplete = o), p[c] = new y(t[c], e, h), d += n
                }
                return p
            }, y.staggerFrom = y.allFrom = function(t, e, i, n, r, s, a) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, y.staggerTo(t, e, i, n, r, s, a)
            }, y.staggerFromTo = y.allFromTo = function(t, e, i, n, r, s, a, o) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, y.staggerTo(t, e, n, r, s, a, o)
            }, y.delayedCall = function(t, e, i, n, r) {
                return new y(e, 0, {
                    delay: t,
                    onComplete: e,
                    onCompleteParams: i,
                    callbackScope: n,
                    onReverseComplete: e,
                    onReverseCompleteParams: i,
                    immediateRender: !1,
                    useFrames: r,
                    overwrite: 0
                })
            }, y.set = function(t, e) {
                return new y(t, 0, e)
            }, y.isTweening = function(t) {
                return 0 < g.getTweensOf(t, !0).length
            };
            var s = function(t, e) {
                    for (var i = [], n = 0, r = t._first; r;) r instanceof g ? i[n++] = r : (e && (i[n++] = r), n = (i = i.concat(s(r, e))).length), r = r._next;
                    return i
                },
                u = y.getAllTweens = function(t) {
                    return s(n._rootTimeline, t).concat(s(n._rootFramesTimeline, t))
                };
            y.killAll = function(t, e, i, n) {
                null == e && (e = !0), null == i && (i = !0);
                for (var r, s, a = u(0 != n), o = a.length, l = e && i && n, h = 0; h < o; h++) s = a[h], (l || s instanceof c || (r = s.target === s.vars.onComplete) && i || e && !r) && (t ? s.totalTime(s._reversed ? 0 : s.totalDuration()) : s._enabled(!1, !1))
            }, y.killChildTweensOf = function(t, e) {
                if (null != t) {
                    var i, n, r, s, a, o = x.tweenLookup;
                    if ("string" == typeof t && (t = g.selector(t) || t), b(t) && (t = v(t)), w(t))
                        for (s = t.length; - 1 < --s;) y.killChildTweensOf(t[s], e);
                    else {
                        for (r in i = [], o)
                            for (n = o[r].target.parentNode; n;) n === t && (i = i.concat(o[r].tweens)), n = n.parentNode;
                        for (a = i.length, s = 0; s < a; s++) e && i[s].totalTime(i[s].totalDuration()), i[s]._enabled(!1, !1)
                    }
                }
            };

            function r(t, e, i, n) {
                e = !1 !== e, i = !1 !== i;
                for (var r, s, a = u(n = !1 !== n), o = e && i && n, l = a.length; - 1 < --l;) s = a[l], (o || s instanceof c || (r = s.target === s.vars.onComplete) && i || e && !r) && s.paused(t)
            }
            return y.pauseAll = function(t, e, i) {
                r(!0, t, e, i)
            }, y.resumeAll = function(t, e, i) {
                r(!1, t, e, i)
            }, y.globalTimeScale = function(t) {
                var e = n._rootTimeline,
                    i = g.ticker.time;
                return arguments.length ? (t = t || m, e._startTime = i - (i - e._startTime) * e._timeScale / t, e = n._rootFramesTimeline, i = g.ticker.frame, e._startTime = i - (i - e._startTime) * e._timeScale / t, e._timeScale = n._rootTimeline._timeScale = t) : e._timeScale
            }, t.progress = function(t) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
            }, t.totalProgress = function(t) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration()
            }, t.time = function(t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
            }, t.duration = function(t) {
                return arguments.length ? n.prototype.duration.call(this, t) : this._duration
            }, t.totalDuration = function(t) {
                return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
            }, t.repeat = function(t) {
                return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
            }, t.repeatDelay = function(t) {
                return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
            }, t.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, y
        }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(c, u, d) {
            function p(t) {
                u.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                var e, i, n = this.vars;
                for (i in n) e = n[i], y(e) && -1 !== e.join("").indexOf("{self}") && (n[i] = this._swapSelfInParams(e));
                y(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger)
            }

            function f(t) {
                var e, i = {};
                for (e in t) i[e] = t[e];
                return i
            }

            function m(t, e, i) {
                var n, r, s = t.cycle;
                for (n in s) r = s[n], t[n] = "function" == typeof r ? r.call(e[i], i) : r[i % r.length];
                delete t.cycle
            }

            function g(t) {
                for (var e = [], i = t.length, n = 0; n !== i; e.push(t[n++]));
                return e
            }
            var v = 1e-10,
                t = d._internals,
                e = p._internals = {},
                _ = t.isSelector,
                y = t.isArray,
                x = t.lazyTweens,
                b = t.lazyRender,
                a = _gsScope._gsDefine.globals,
                r = e.pauseCallback = function() {},
                e = p.prototype = new u;
            return p.version = "1.18.0", e.constructor = p, e.kill()._gc = e._forcingPlayhead = e._hasPause = !1, e.to = function(t, e, i, n) {
                var r = i.repeat && a.TweenMax || d;
                return e ? this.add(new r(t, e, i), n) : this.set(t, i, n)
            }, e.from = function(t, e, i, n) {
                return this.add((i.repeat && a.TweenMax || d).from(t, e, i), n)
            }, e.fromTo = function(t, e, i, n, r) {
                var s = n.repeat && a.TweenMax || d;
                return e ? this.add(s.fromTo(t, e, i, n), r) : this.set(t, n, r)
            }, e.staggerTo = function(t, e, i, n, r, s, a, o) {
                var l, h, c = new p({
                        onComplete: s,
                        onCompleteParams: a,
                        callbackScope: o,
                        smoothChildTiming: this.smoothChildTiming
                    }),
                    u = i.cycle;
                for ("string" == typeof t && (t = d.selector(t) || t), _(t = t || []) && (t = g(t)), (n = n || 0) < 0 && ((t = g(t)).reverse(), n *= -1), h = 0; h < t.length; h++)(l = f(i)).startAt && (l.startAt = f(l.startAt), l.startAt.cycle && m(l.startAt, t, h)), u && m(l, t, h), c.to(t[h], e, l, h * n);
                return this.add(c, r)
            }, e.staggerFrom = function(t, e, i, n, r, s, a, o) {
                return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, s, a, o)
            }, e.staggerFromTo = function(t, e, i, n, r, s, a, o, l) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, s, a, o, l)
            }, e.call = function(t, e, i, n) {
                return this.add(d.delayedCall(0, t, e, i), n)
            }, e.set = function(t, e, i) {
                return i = this._parseTimeOrLabel(i, 0, !0), null == e.immediateRender && (e.immediateRender = i === this._time && !this._paused), this.add(new d(t, 0, e), i)
            }, p.exportRoot = function(t, e) {
                null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0);
                var i, n, r = new p(t),
                    t = r._timeline;
                for (null == e && (e = !0), t._remove(r, !0), r._startTime = 0, r._rawPrevTime = r._time = r._totalTime = t._time, i = t._first; i;) n = i._next, e && i instanceof d && i.target === i.vars.onComplete || r.add(i, i._startTime - i._delay), i = n;
                return t.add(r, 0), r
            }, e.add = function(t, e, i, n) {
                var r, s, a, o, l, h;
                if ("number" != typeof e && (e = this._parseTimeOrLabel(e, 0, !0, t)), !(t instanceof c)) {
                    if (t instanceof Array || t && t.push && y(t)) {
                        for (i = i || "normal", n = n || 0, r = e, s = t.length, a = 0; a < s; a++) y(o = t[a]) && (o = new p({
                            tweens: o
                        })), this.add(o, r), "string" != typeof o && "function" != typeof o && ("sequence" === i ? r = o._startTime + o.totalDuration() / o._timeScale : "start" === i && (o._startTime -= o.delay())), r += n;
                        return this._uncache(!0)
                    }
                    if ("string" == typeof t) return this.addLabel(t, e);
                    if ("function" != typeof t) throw "Cannot add " + t + " into the timeline; it is not a tween, timeline, function, or string.";
                    t = d.delayedCall(0, t)
                }
                if (u.prototype.add.call(this, t, e), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                    for (h = (l = this).rawTime() > t._startTime; l._timeline;) h && l._timeline.smoothChildTiming ? l.totalTime(l._totalTime, !0) : l._gc && l._enabled(!0, !1), l = l._timeline;
                return this
            }, e.remove = function(t) {
                if (t instanceof c) {
                    this._remove(t, !1);
                    var e = t._timeline = t.vars.useFrames ? c._rootFramesTimeline : c._rootTimeline;
                    return t._startTime = (t._paused ? t._pauseTime : e._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this
                }
                if (t instanceof Array || t && t.push && y(t)) {
                    for (var i = t.length; - 1 < --i;) this.remove(t[i]);
                    return this
                }
                return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
            }, e._remove = function(t, e) {
                u.prototype._remove.call(this, t, e);
                e = this._last;
                return e ? this._time > e._startTime + e._totalDuration / e._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
            }, e.append = function(t, e) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
            }, e.insert = e.insertMultiple = function(t, e, i, n) {
                return this.add(t, e || 0, i, n)
            }, e.appendMultiple = function(t, e, i, n) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
            }, e.addLabel = function(t, e) {
                return this._labels[t] = this._parseTimeOrLabel(e), this
            }, e.addPause = function(t, e, i, n) {
                n = d.delayedCall(0, r, i, n || this);
                return n.vars.onComplete = n.vars.onReverseComplete = e, n.data = "isPause", this._hasPause = !0, this.add(n, t)
            }, e.removeLabel = function(t) {
                return delete this._labels[t], this
            }, e.getLabelTime = function(t) {
                return null != this._labels[t] ? this._labels[t] : -1
            }, e._parseTimeOrLabel = function(t, e, i, n) {
                var r;
                if (n instanceof c && n.timeline === this) this.remove(n);
                else if (n && (n instanceof Array || n.push && y(n)))
                    for (r = n.length; - 1 < --r;) n[r] instanceof c && n[r].timeline === this && this.remove(n[r]);
                if ("string" == typeof e) return this._parseTimeOrLabel(e, i && "number" == typeof t && null == this._labels[e] ? t - this.duration() : 0, i);
                if (e = e || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = this.duration());
                else {
                    if (-1 === (r = t.indexOf("="))) return null == this._labels[t] ? i ? this._labels[t] = this.duration() + e : e : this._labels[t] + e;
                    e = parseInt(t.charAt(r - 1) + "1", 10) * Number(t.substr(r + 1)), t = 1 < r ? this._parseTimeOrLabel(t.substr(0, r - 1), 0, i) : this.duration()
                }
                return Number(t) + e
            }, e.seek = function(t, e) {
                return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
            }, e.stop = function() {
                return this.paused(!0)
            }, e.gotoAndPlay = function(t, e) {
                return this.play(t, e)
            }, e.gotoAndStop = function(t, e) {
                return this.pause(t, e)
            }, e.render = function(t, e, i) {
                this._gc && this._enabled(!0, !1);
                var n, r, s, a, o, l, h = this._dirty ? this.totalDuration() : this._totalDuration,
                    c = this._time,
                    u = this._startTime,
                    d = this._timeScale,
                    p = this._paused;
                if (h <= t) this._totalTime = this._time = h, this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", o = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === t || this._rawPrevTime < 0 || this._rawPrevTime === v) && this._rawPrevTime !== t && this._first && (o = !0, this._rawPrevTime > v && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : v, t = h + 1e-4;
                else if (t < 1e-7)
                    if (((this._totalTime = this._time = 0) !== c || 0 === this._duration && this._rawPrevTime !== v && (0 < this._rawPrevTime || t < 0 && 0 <= this._rawPrevTime)) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (o = r = !0, a = "onReverseComplete") : 0 <= this._rawPrevTime && this._first && (o = !0), this._rawPrevTime = t;
                    else {
                        if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : v, 0 === t && r)
                            for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                        t = 0, this._initted || (o = !0)
                    }
                else {
                    if (this._hasPause && !this._forcingPlayhead && !e) {
                        if (c <= t)
                            for (n = this._first; n && n._startTime <= t && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (l = n), n = n._next;
                        else
                            for (n = this._last; n && n._startTime >= t && !l;) n._duration || "isPause" === n.data && 0 < n._rawPrevTime && (l = n), n = n._prev;
                        l && (this._time = t = l._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                    }
                    this._totalTime = this._time = this._rawPrevTime = t
                }
                if (this._time !== c && this._first || i || o || l) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== c && 0 < t && (this._active = !0), 0 === c && this.vars.onStart && 0 !== this._time && (e || this._callback("onStart")), this._time >= c)
                        for (n = this._first; n && (s = n._next, !this._paused || p);)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (l === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s;
                    else
                        for (n = this._last; n && (s = n._prev, !this._paused || p);) {
                            if (n._active || n._startTime <= c && !n._paused && !n._gc) {
                                if (l === n) {
                                    for (l = n._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (t - l._startTime) * l._timeScale : (t - l._startTime) * l._timeScale, e, i), l = l._prev;
                                    l = null, this.pause()
                                }
                                n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                            }
                            n = s
                        }
                    this._onUpdate && (e || (x.length && b(), this._callback("onUpdate"))), a && (this._gc || u !== this._startTime && d === this._timeScale || (0 === this._time || h >= this.totalDuration()) && (r && (x.length && b(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                }
            }, e._hasPausedChild = function() {
                for (var t = this._first; t;) {
                    if (t._paused || t instanceof p && t._hasPausedChild()) return !0;
                    t = t._next
                }
                return !1
            }, e.getChildren = function(t, e, i, n) {
                n = n || -9999999999;
                for (var r = [], s = this._first, a = 0; s;) s._startTime < n || (s instanceof d ? !1 !== e && (r[a++] = s) : (!1 !== i && (r[a++] = s), !1 !== t && (a = (r = r.concat(s.getChildren(!0, e, i))).length))), s = s._next;
                return r
            }, e.getTweensOf = function(t, e) {
                var i, n, r = this._gc,
                    s = [],
                    a = 0;
                for (r && this._enabled(!0, !0), n = (i = d.getTweensOf(t)).length; - 1 < --n;)(i[n].timeline === this || e && this._contains(i[n])) && (s[a++] = i[n]);
                return r && this._enabled(!1, !0), s
            }, e.recent = function() {
                return this._recent
            }, e._contains = function(t) {
                for (var e = t.timeline; e;) {
                    if (e === this) return !0;
                    e = e.timeline
                }
                return !1
            }, e.shiftChildren = function(t, e, i) {
                i = i || 0;
                for (var n, r = this._first, s = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                if (e)
                    for (n in s) s[n] >= i && (s[n] += t);
                return this._uncache(!0)
            }, e._kill = function(t, e) {
                if (!t && !e) return this._enabled(!1, !1);
                for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; - 1 < --n;) i[n]._kill(t, e) && (r = !0);
                return r
            }, e.clear = function(t) {
                var e = this.getChildren(!1, !0, !0),
                    i = e.length;
                for (this._time = this._totalTime = 0; - 1 < --i;) e[i]._enabled(!1, !1);
                return !1 !== t && (this._labels = {}), this._uncache(!0)
            }, e.invalidate = function() {
                for (var t = this._first; t;) t.invalidate(), t = t._next;
                return c.prototype.invalidate.call(this)
            }, e._enabled = function(t, e) {
                if (t === this._gc)
                    for (var i = this._first; i;) i._enabled(t, !0), i = i._next;
                return u.prototype._enabled.call(this, t, e)
            }, e.totalTime = function(t, e, i) {
                this._forcingPlayhead = !0;
                var n = c.prototype.totalTime.apply(this, arguments);
                return this._forcingPlayhead = !1, n
            }, e.duration = function(t) {
                return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
            }, e.totalDuration = function(t) {
                if (arguments.length) return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this;
                if (this._dirty) {
                    for (var e, i, n = 0, r = this._last, s = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > s && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : s = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), s = 0), n < (i = r._startTime + r._totalDuration / r._timeScale) && (n = i), r = e;
                    this._duration = this._totalDuration = n, this._dirty = !1
                }
                return this._totalDuration
            }, e.paused = function(t) {
                if (!t)
                    for (var e = this._first, i = this._time; e;) e._startTime === i && "isPause" === e.data && (e._rawPrevTime = 0), e = e._next;
                return c.prototype.paused.apply(this, arguments)
            }, e.usesFrames = function() {
                for (var t = this._timeline; t._timeline;) t = t._timeline;
                return t === c._rootFramesTimeline
            }, e.rawTime = function() {
                return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
            }, p
        }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(e, a, t) {
            function i(t) {
                e.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
            }
            var M = 1e-10,
                n = a._internals,
                E = n.lazyTweens,
                S = n.lazyRender,
                o = new t(null, null, 1, 0),
                t = i.prototype = new e;
            return t.constructor = i, t.kill()._gc = !1, i.version = "1.18.0", t.invalidate = function() {
                return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), e.prototype.invalidate.call(this)
            }, t.addCallback = function(t, e, i, n) {
                return this.add(a.delayedCall(0, t, i, n), e)
            }, t.removeCallback = function(t, e) {
                if (t)
                    if (null == e) this._kill(null, t);
                    else
                        for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); - 1 < --n;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                return this
            }, t.removePause = function(t) {
                return this.removeCallback(e._internals.pauseCallback, t)
            }, t.tweenTo = function(t, e) {
                e = e || {};
                var i, n, r, s = {
                    ease: o,
                    useFrames: this.usesFrames(),
                    immediateRender: !1
                };
                for (n in e) s[n] = e[n];
                return s.time = this._parseTimeOrLabel(t), i = Math.abs(Number(s.time) - this._time) / this._timeScale || .001, r = new a(this, i, s), s.onStart = function() {
                    r.target.paused(!0), r.vars.time !== r.target.time() && i === r.duration() && r.duration(Math.abs(r.vars.time - r.target.time()) / r.target._timeScale), e.onStart && r._callback("onStart")
                }, r
            }, t.tweenFromTo = function(t, e, i) {
                i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                    onComplete: this.seek,
                    onCompleteParams: [t],
                    callbackScope: this
                }, i.immediateRender = !1 !== i.immediateRender;
                i = this.tweenTo(e, i);
                return i.duration(Math.abs(i.vars.time - t) / this._timeScale || .001)
            }, t.render = function(t, e, i) {
                this._gc && this._enabled(!0, !1);
                var n, r, s, a, o, l, h = this._dirty ? this.totalDuration() : this._totalDuration,
                    c = this._duration,
                    u = this._time,
                    d = this._totalTime,
                    p = this._startTime,
                    f = this._timeScale,
                    m = this._rawPrevTime,
                    g = this._paused,
                    v = this._cycle;
                if (h <= t) this._locked || (this._totalTime = h, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", o = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === t || m < 0 || m === M) && m !== t && this._first && (o = !0, M < m && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : M, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : t = (this._time = c) + 1e-4;
                else if (t < 1e-7)
                    if (this._locked || (this._totalTime = this._cycle = 0), ((this._time = 0) !== u || 0 === c && m !== M && (0 < m || t < 0 && 0 <= m) && !this._locked) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (o = r = !0, a = "onReverseComplete") : 0 <= m && this._first && (o = !0), this._rawPrevTime = t;
                    else {
                        if (this._rawPrevTime = c || !e || t || this._rawPrevTime === t ? t : M, 0 === t && r)
                            for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                        t = 0, this._initted || (o = !0)
                    }
                else if (0 === c && m < 0 && (o = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (T = c + this._repeatDelay, this._cycle = this._totalTime / T >> 0, 0 !== this._cycle && this._cycle === this._totalTime / T && this._cycle--, this._time = this._totalTime - this._cycle * T, this._yoyo && 0 != (1 & this._cycle) && (this._time = c - this._time), this._time > c ? t = (this._time = c) + 1e-4 : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                    if (u <= (t = this._time))
                        for (n = this._first; n && n._startTime <= t && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (l = n), n = n._next;
                    else
                        for (n = this._last; n && n._startTime >= t && !l;) n._duration || "isPause" === n.data && 0 < n._rawPrevTime && (l = n), n = n._prev;
                    l && (this._time = t = l._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                }
                if (this._cycle !== v && !this._locked) {
                    var _ = this._yoyo && 0 != (1 & v),
                        y = _ === (this._yoyo && 0 != (1 & this._cycle)),
                        x = this._totalTime,
                        b = this._cycle,
                        w = this._rawPrevTime,
                        T = this._time;
                    if (this._totalTime = v * c, this._cycle < v ? _ = !_ : this._totalTime += c, this._time = u, this._rawPrevTime = 0 === c ? m - 1e-4 : m, this._cycle = v, this._locked = !0, u = _ ? 0 : c, this.render(u, e, 0 === c), e || this._gc || this.vars.onRepeat && this._callback("onRepeat"), y && (u = _ ? c + 1e-4 : -1e-4, this.render(u, !0, !1)), this._locked = !1, this._paused && !g) return;
                    this._time = T, this._totalTime = x, this._cycle = b, this._rawPrevTime = w
                }
                if (this._time !== u && this._first || i || o || l) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== d && 0 < t && (this._active = !0), 0 === d && this.vars.onStart && 0 !== this._totalTime && (e || this._callback("onStart")), this._time >= u)
                        for (n = this._first; n && (s = n._next, !this._paused || g);)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (l === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s;
                    else
                        for (n = this._last; n && (s = n._prev, !this._paused || g);) {
                            if (n._active || n._startTime <= u && !n._paused && !n._gc) {
                                if (l === n) {
                                    for (l = n._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (t - l._startTime) * l._timeScale : (t - l._startTime) * l._timeScale, e, i), l = l._prev;
                                    l = null, this.pause()
                                }
                                n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                            }
                            n = s
                        }
                    this._onUpdate && (e || (E.length && S(), this._callback("onUpdate"))), a && (this._locked || this._gc || p !== this._startTime && f === this._timeScale || (0 === this._time || h >= this.totalDuration()) && (r && (E.length && S(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                } else d !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
            }, t.getActive = function(t, e, i) {
                null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                for (var n, r = [], s = this.getChildren(t, e, i), a = 0, o = s.length, l = 0; l < o; l++)(n = s[l]).isActive() && (r[a++] = n);
                return r
            }, t.getLabelAfter = function(t) {
                t || 0 !== t && (t = this._time);
                for (var e = this.getLabelsArray(), i = e.length, n = 0; n < i; n++)
                    if (e[n].time > t) return e[n].name;
                return null
            }, t.getLabelBefore = function(t) {
                null == t && (t = this._time);
                for (var e = this.getLabelsArray(), i = e.length; - 1 < --i;)
                    if (e[i].time < t) return e[i].name;
                return null
            }, t.getLabelsArray = function() {
                var t, e = [],
                    i = 0;
                for (t in this._labels) e[i++] = {
                    time: this._labels[t],
                    name: t
                };
                return e.sort(function(t, e) {
                    return t.time - e.time
                }), e
            }, t.progress = function(t, e) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
            }, t.totalProgress = function(t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
            }, t.totalDuration = function(t) {
                return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
            }, t.time = function(t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
            }, t.repeat = function(t) {
                return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
            }, t.repeatDelay = function(t) {
                return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
            }, t.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, t.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
            }, i
        }, !0), T = 180 / Math.PI, x = [], b = [], w = [], v = {}, e = _gsScope._gsDefine.globals, g = _gsScope._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.4",
            API: 2,
            global: !0,
            init: function(t, e, i) {
                this._target = t, e instanceof Array && (e = {
                    values: e
                }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                var n, r, s, a, o, l = e.values || [],
                    h = {},
                    c = l[0],
                    u = e.autoRotate || i.vars.orientToBezier;
                for (n in this._autoRotate = u ? u instanceof Array ? u : [
                        ["x", "y", "rotation", !0 !== u && Number(u) || 0]
                    ] : null, c) this._props.push(n);
                for (s = this._props.length; - 1 < --s;) n = this._props[s], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], h[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), o || h[n] !== l[0][n] && (o = h);
                if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? d(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : function(t, e, i) {
                        var n, r, s, a, o, l, h, c, u, d, p, f = {},
                            m = "cubic" === (e = e || "soft") ? 3 : 2,
                            g = "soft" === e,
                            v = [];
                        if (g && i && (t = [i].concat(t)), null == t || t.length < 1 + m) throw "invalid Bezier data";
                        for (u in t[0]) v.push(u);
                        for (l = v.length; - 1 < --l;) {
                            for (f[u = v[l]] = o = [], d = 0, c = t.length, h = 0; h < c; h++) n = null == i ? t[h][u] : "string" == typeof(p = t[h][u]) && "=" === p.charAt(1) ? i[u] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && 1 < h && h < c - 1 && (o[d++] = (n + o[d - 2]) / 2), o[d++] = n;
                            for (c = d - m + 1, h = d = 0; h < c; h += m) n = o[h], r = o[h + 1], s = o[h + 2], a = 2 == m ? 0 : o[h + 3], o[d++] = p = 3 == m ? new _(n, r, s, a) : new _(n, (2 * r + n) / 3, (2 * r + s) / 3, s);
                            o.length = d
                        }
                        return f
                    }(l, e.type, h), this._segCount = this._beziers[n].length, this._timeRes && (e = function(t, e) {
                        var i, n, r, s, a = [],
                            o = [],
                            l = 0,
                            h = 0,
                            c = (e = e >> 0 || 6) - 1,
                            u = [],
                            d = [];
                        for (i in t) ! function(t, e, i) {
                            for (var n, r, s, a, o, l, h, c, u, d, p = 1 / i, f = t.length; - 1 < --f;)
                                for (s = (u = t[f]).a, a = u.d - s, o = u.c - s, l = u.b - s, r = 0, h = 1; h <= i; h++) n = r - (r = ((d = p * h) * d * a + 3 * (c = 1 - d) * (d * o + c * l)) * d), e[d = f * i + h - 1] = (e[d] || 0) + n * n
                        }(t[i], a, e);
                        for (r = a.length, n = 0; n < r; n++) l += Math.sqrt(a[n]), d[s = n % e] = l, s == c && (h += l, u[s = n / e >> 0] = d, o[s] = h, l = 0, d = []);
                        return {
                            length: h,
                            lengths: o,
                            segments: u
                        }
                    }(this._beziers, this._timeRes), this._length = e.length, this._lengths = e.lengths, this._segments = e.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length), u = this._autoRotate)
                    for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), s = u.length; - 1 < --s;) {
                        for (a = 0; a < 3; a++) n = u[s][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                        n = u[s][2], this._initialRotations[s] = this._func[n] ? this._func[n].call(this._target) : this._target[n]
                    }
                return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
            },
            set: function(t) {
                var e, i, n, r, s, a, o, l, h, c = this._segCount,
                    u = this._func,
                    d = this._target,
                    p = t !== this._startRatio;
                if (this._timeRes) {
                    if (l = this._lengths, h = this._curSeg, t *= this._length, w = this._li, t > this._l2 && w < c - 1) {
                        for (o = c - 1; w < o && (this._l2 = l[++w]) <= t;);
                        this._l1 = l[w - 1], this._li = w, this._curSeg = h = this._segments[w], this._s2 = h[this._s1 = this._si = 0]
                    } else if (t < this._l1 && 0 < w) {
                        for (; 0 < w && (this._l1 = l[--w]) >= t;);
                        0 === w && t < this._l1 ? this._l1 = 0 : w++, this._l2 = l[w], this._li = w, this._curSeg = h = this._segments[w], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si]
                    }
                    if (e = w, t -= this._l1, w = this._si, t > this._s2 && w < h.length - 1) {
                        for (o = h.length - 1; w < o && (this._s2 = h[++w]) <= t;);
                        this._s1 = h[w - 1], this._si = w
                    } else if (t < this._s1 && 0 < w) {
                        for (; 0 < w && (this._s1 = h[--w]) >= t;);
                        0 === w && t < this._s1 ? this._s1 = 0 : w++, this._s2 = h[w], this._si = w
                    }
                    s = (w + (t - this._s1) / (this._s2 - this._s1)) * this._prec
                } else s = (t - (e = t < 0 ? 0 : 1 <= t ? c - 1 : c * t >> 0) * (1 / c)) * c;
                for (i = 1 - s, w = this._props.length; - 1 < --w;) n = this._props[w], a = (s * s * (r = this._beziers[n][e]).da + 3 * i * (s * r.ca + i * r.ba)) * s + r.a, this._round[n] && (a = Math.round(a)), u[n] ? d[n](a) : d[n] = a;
                if (this._autoRotate)
                    for (var f, m, g, v, _, y, x, b = this._autoRotate, w = b.length; - 1 < --w;) n = b[w][2], y = b[w][3] || 0, x = !0 === b[w][4] ? 1 : T, r = this._beziers[b[w][0]], f = this._beziers[b[w][1]], r && f && (r = r[e], f = f[e], m = r.a + (r.b - r.a) * s, m += ((v = r.b + (r.c - r.b) * s) - m) * s, v += (r.c + (r.d - r.c) * s - v) * s, g = f.a + (f.b - f.a) * s, g += ((_ = f.b + (f.c - f.b) * s) - g) * s, _ += (f.c + (f.d - f.c) * s - _) * s, a = p ? Math.atan2(_ - g, v - m) * x + y : this._initialRotations[w], u[n] ? d[n](a) : d[n] = a)
            }
        }), t = g.prototype, g.bezierThrough = d, g.cubicToQuadratic = y, g._autoCSS = !0, g.quadraticToCubic = function(t, e, i) {
            return new _(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
        }, g._cssRegister = function() {
            var p, f, m, t = e.CSSPlugin;
            t && (t = t._internals, p = t._parseToProxy, f = t._setPluginRatio, m = t.CSSPropTween, t._registerComplexSpecialProp("bezier", {
                parser: function(t, e, i, n, r, s) {
                    e instanceof Array && (e = {
                        values: e
                    }), s = new g;
                    var a, o, l, h = e.values,
                        c = h.length - 1,
                        u = [],
                        d = {};
                    if (c < 0) return r;
                    for (a = 0; a <= c; a++) l = p(t, h[a], n, r, s, c !== a), u[a] = l.end;
                    for (o in e) d[o] = e[o];
                    return d.values = u, (r = new m(t, "bezier", 0, 0, l.pt, 2)).data = l, r.plugin = s, r.setRatio = f, 0 === d.autoRotate && (d.autoRotate = !0), !d.autoRotate || d.autoRotate instanceof Array || (a = !0 === d.autoRotate ? 0 : Number(d.autoRotate), d.autoRotate = null != l.end.left ? [
                        ["left", "top", "rotation", a, !1]
                    ] : null != l.end.x && [
                        ["x", "y", "rotation", a, !1]
                    ]), d.autoRotate && (n._transform || n._enableTransforms(!1), l.autoRotate = n._target._gsTransform), s._onInitTween(l.proxy, d, n._tween), r
                }
            }))
        }, t._roundProps = function(t, e) {
            for (var i = this._overwriteProps, n = i.length; - 1 < --n;)(t[i[n]] || t.bezier || t.bezierThrough) && (this._round[i[n]] = e)
        }, t._kill = function(t) {
            var e, i, n = this._props;
            for (e in this._beziers)
                if (e in t)
                    for (delete this._beziers[e], delete this._func[e], i = n.length; - 1 < --i;) n[i] === e && n.splice(i, 1);
            return this._super._kill.call(this, t)
        }, _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(s, L) {
            var d, w, O, u, D = function() {
                    s.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = D.prototype.setRatio
                },
                h = _gsScope._gsDefine.globals,
                p = {},
                t = D.prototype = new s("css");
            (t.constructor = D).version = "1.18.0", D.API = 2, D.defaultTransformPerspective = 0, D.defaultSkewType = "compensated", D.defaultSmoothOrigin = !0, t = "px", D.suffixMap = {
                top: t,
                right: t,
                bottom: t,
                left: t,
                width: t,
                height: t,
                fontSize: t,
                padding: t,
                margin: t,
                perspective: t,
                lineHeight: ""
            };

            function a(t, e) {
                return e.toUpperCase()
            }

            function o(t) {
                return z.test("string" == typeof t ? t : (t.currentStyle || t.style).filter || "") ? parseFloat(RegExp.$1) / 100 : 1
            }

            function f(t) {
                window.console && console.log(t)
            }

            function T(t, e) {
                var i, n, r = (e = e || J).style;
                if (void 0 !== r[t]) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; - 1 < --n && void 0 === r[i[n] + t];);
                return 0 <= n ? (tt = "-" + (et = 3 === n ? "ms" : i[n]).toLowerCase() + "-", et + t) : null
            }

            function m(t, e) {
                var i, n, r = {};
                if (e = e || it(t, null))
                    if (i = e.length)
                        for (; - 1 < --i;) - 1 !== (n = e[i]).indexOf("-transform") && Pt !== n || (r[n.replace(F, a)] = e.getPropertyValue(n));
                    else
                        for (i in e) - 1 !== i.indexOf("Transform") && At !== i || (r[i] = e[i]);
                else if (e = t.currentStyle || t.style)
                    for (i in e) "string" == typeof i && void 0 === r[i] && (r[i.replace(F, a)] = e[i]);
                return $ || (r.opacity = o(t)), t = zt(t, e, !1), r.rotation = t.rotation, r.skewX = t.skewX, r.scaleX = t.scaleX, r.scaleY = t.scaleY, r.x = t.x, r.y = t.y, Rt && (r.z = t.z, r.rotationX = t.rotationX, r.rotationY = t.rotationY, r.scaleZ = t.scaleZ), r.filters && delete r.filters, r
            }

            function g(t, e, i, n, r) {
                var s, a, o, l = {},
                    h = t.style;
                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (s = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof s && "string" != typeof s || (l[a] = "auto" !== s || "left" !== a && "top" !== a ? "" !== s && "auto" !== s && "none" !== s || "string" != typeof e[a] || "" === e[a].replace(I, "") ? s : 0 : st(t, a), void 0 !== h[a] && (o = new ft(h, a, h[a], o))));
                if (n)
                    for (a in n) "className" !== a && (l[a] = n[a]);
                return {
                    difs: l,
                    firstMPT: o
                }
            }

            function b(t, e) {
                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                null != t && "" !== t || (t = "0 0");
                var i = t.split(" "),
                    n = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0],
                    r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1];
                return null == r ? r = "center" === n ? "50%" : "0" : "center" === r && (r = "50%"), ("center" === n || isNaN(parseFloat(n)) && -1 === (n + "").indexOf("=")) && (n = "50%"), t = n + " " + r + (2 < i.length ? " " + i[2] : ""), e && (e.oxp = -1 !== n.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === n.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(n.replace(I, "")), e.oy = parseFloat(r.replace(I, "")), e.v = t), e || t
            }

            function S(t, e) {
                return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e)
            }

            function M(t, e) {
                return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t)
            }

            function E(t, e, i, n) {
                var r, s, a = null == t ? e : "number" == typeof t ? t : (r = 360, s = t.split("_"), a = ((a = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(s[0].substr(2)) : parseFloat(s[0])) * (-1 === t.indexOf("rad") ? 1 : q) - (a ? 0 : e), s.length && (n && (n[i] = e + a), -1 !== t.indexOf("short") && (a %= r) !== a % 180 && (a = a < 0 ? a + r : a - r), -1 !== t.indexOf("_cw") && a < 0 ? a = (a + 3599999999640) % r - (a / r | 0) * r : -1 !== t.indexOf("ccw") && 0 < a && (a = (a - 3599999999640) % r - (a / r | 0) * r)), e + a);
                return a < 1e-6 && -1e-6 < a && (a = 0), a
            }

            function c(t, e, i) {
                return 255 * (6 * (t = t < 0 ? t + 1 : 1 < t ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            }

            function i(t, e) {
                for (var i, n, r = t.match(ct) || [], s = 0, a = r.length ? "" : t, o = 0; o < r.length; o++) i = r[o], s += (n = t.substr(s, t.indexOf(i, s) - s)).length + i.length, 3 === (i = ht(i, e)).length && i.push(1), a += n + (e ? "hsla(" + i[0] + "," + i[1] + "%," + i[2] + "%," + i[3] : "rgba(" + i.join(",")) + ")";
                return a
            }
            var A, v, _, k, y, P, C = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
                R = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                I = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                N = /(?:\d|\-|\+|=|#|\.)*/g,
                z = /opacity *= *([^)]*)/i,
                B = /opacity:([^;]*)/i,
                r = /alpha\(opacity *=.+?\)/i,
                U = /^(rgb|hsl)/,
                l = /([A-Z])/g,
                F = /-([a-z])/gi,
                H = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                G = /(?:Left|Right|Width)/i,
                V = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                j = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                W = /,(?=[^\)]*(?:\(|$))/gi,
                X = Math.PI / 180,
                q = 180 / Math.PI,
                Y = {},
                Z = document,
                e = function(t) {
                    return Z.createElementNS ? Z.createElementNS("http://www.w3.org/1999/xhtml", t) : Z.createElement(t)
                },
                J = e("div"),
                Q = e("img"),
                n = D._internals = {
                    _specialProps: p
                },
                K = navigator.userAgent,
                $ = (Et = K.indexOf("Android"), Mt = e("a"), _ = -1 !== K.indexOf("Safari") && -1 === K.indexOf("Chrome") && (-1 === Et || 3 < Number(K.substr(Et + 8, 1))), y = _ && Number(K.substr(K.indexOf("Version/") + 8, 1)) < 6, k = -1 !== K.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(K) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(K)) && (P = parseFloat(RegExp.$1)), !!Mt && (Mt.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(Mt.style.opacity))),
                tt = "",
                et = "",
                it = Z.defaultView ? Z.defaultView.getComputedStyle : function() {},
                nt = D.getStyle = function(t, e, i, n, r) {
                    var s;
                    return $ || "opacity" !== e ? (!n && t.style[e] ? s = t.style[e] : (i = i || it(t)) ? s = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(l, "-$1").toLowerCase()) : t.currentStyle && (s = t.currentStyle[e]), null == r || s && "none" !== s && "auto" !== s && "auto auto" !== s ? s : r) : o(t)
                },
                rt = n.convertToPixels = function(t, e, i, n, r) {
                    if ("px" === n || !n) return i;
                    if ("auto" === n || !i) return 0;
                    var s, a, o, l = G.test(e),
                        h = t,
                        c = J.style,
                        u = i < 0;
                    if (u && (i = -i), "%" === n && -1 !== e.indexOf("border")) s = i / 100 * (l ? t.clientWidth : t.clientHeight);
                    else {
                        if (c.cssText = "border:0 solid red;position:" + nt(t, "position") + ";line-height:0;", "%" !== n && h.appendChild && "v" !== n.charAt(0) && "rem" !== n) c[l ? "borderLeftWidth" : "borderTopWidth"] = i + n;
                        else {
                            if (a = (h = t.parentNode || Z.body)._gsCache, o = L.ticker.frame, a && l && a.time === o) return a.width * i / 100;
                            c[l ? "width" : "height"] = i + n
                        }
                        h.appendChild(J), s = parseFloat(J[l ? "offsetWidth" : "offsetHeight"]), h.removeChild(J), l && "%" === n && !1 !== D.cacheWidths && ((a = h._gsCache = h._gsCache || {}).time = o, a.width = s / i * 100), 0 !== s || r || (s = rt(t, e, i, n, !0))
                    }
                    return u ? -s : s
                },
                st = n.calculateOffset = function(t, e, i) {
                    if ("absolute" !== nt(t, "position", i)) return 0;
                    var n = "left" === e ? "Left" : "Top",
                        i = nt(t, "margin" + n, i);
                    return t["offset" + n] - (rt(t, e, parseFloat(i), i.replace(N, "")) || 0)
                },
                at = {
                    width: ["Left", "Right"],
                    height: ["Top", "Bottom"]
                },
                ot = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                lt = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    fuchsia: [255, 0, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                },
                ht = D.parseColor = function(t, e) {
                    var i, n, r, s, a, o, l, h;
                    if (t)
                        if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                        else {
                            if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), lt[t]) i = lt[t];
                            else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (s = t.charAt(3)) + s), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                            else if ("hsl" === t.substr(0, 3))
                                if (i = h = t.match(C), e) {
                                    if (-1 !== t.indexOf("=")) return t.match(R)
                                } else a = Number(i[0]) % 360 / 360, o = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), 3 < i.length && (i[3] = Number(t[3])), i[0] = c(a + 1 / 3, n, r), i[1] = c(a, n, r), i[2] = c(a - 1 / 3, n, r);
                            else i = t.match(C) || lt.transparent;
                            i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), 3 < i.length && (i[3] = Number(i[3]))
                        }
                    else i = lt.black;
                    return e && !h && (n = i[0] / 255, r = i[1] / 255, s = i[2] / 255, l = ((t = Math.max(n, r, s)) + (e = Math.min(n, r, s))) / 2, t === e ? a = o = 0 : (h = t - e, o = .5 < l ? h / (2 - t - e) : h / (t + e), a = t === n ? (r - s) / h + (r < s ? 6 : 0) : t === r ? (s - n) / h + 2 : (n - r) / h + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * o + .5 | 0, i[2] = 100 * l + .5 | 0), i
                },
                ct = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
            for (t in lt) ct += "|" + t + "\\b";
            ct = new RegExp(ct + ")", "gi"), D.colorStringFilter = function(t) {
                var e = t[0] + t[1];
                ct.lastIndex = 0, ct.test(e) && (e = -1 !== e.indexOf("hsl(") || -1 !== e.indexOf("hsla("), t[0] = i(t[0], e), t[1] = i(t[1], e))
            }, L.defaultStringFilter || (L.defaultStringFilter = D.colorStringFilter);

            function ut(t, e, s, a) {
                if (null == t) return function(t) {
                    return t
                };
                var o, l = e ? (t.match(ct) || [""])[0] : "",
                    h = t.split(l).join("").match(x) || [],
                    c = t.substr(0, t.indexOf(h[0])),
                    u = ")" === t.charAt(t.length - 1) ? ")" : "",
                    d = -1 !== t.indexOf(" ") ? " " : ",",
                    p = h.length,
                    f = 0 < p ? h[0].replace(C, "") : "";
                return p ? o = e ? function(t) {
                    var e, i, n, r;
                    if ("number" == typeof t) t += f;
                    else if (a && W.test(t)) {
                        for (r = t.replace(W, "|").split("|"), n = 0; n < r.length; n++) r[n] = o(r[n]);
                        return r.join(",")
                    }
                    if (e = (t.match(ct) || [l])[0], n = (i = t.split(e).join("").match(x) || []).length, p > n--)
                        for (; ++n < p;) i[n] = s ? i[(n - 1) / 2 | 0] : h[n];
                    return c + i.join(d) + d + e + u + (-1 !== t.indexOf("inset") ? " inset" : "")
                } : function(t) {
                    var e, i, n;
                    if ("number" == typeof t) t += f;
                    else if (a && W.test(t)) {
                        for (i = t.replace(W, "|").split("|"), n = 0; n < i.length; n++) i[n] = o(i[n]);
                        return i.join(",")
                    }
                    if (n = (e = t.match(x) || []).length, p > n--)
                        for (; ++n < p;) e[n] = s ? e[(n - 1) / 2 | 0] : h[n];
                    return c + e.join(d) + u
                } : function(t) {
                    return t
                }
            }

            function dt(h) {
                return h = h.split(","),
                    function(t, e, i, n, r, s, a) {
                        var o, l = (e + "").split(" ");
                        for (a = {}, o = 0; o < 4; o++) a[h[o]] = l[o] = l[o] || l[(o - 1) / 2 >> 0];
                        return n.parse(t, a, r, s)
                    }
            }
            n._setPluginRatio = function(t) {
                this.plugin.setRatio(t);
                for (var e, i, n, r, s = this.data, a = s.proxy, o = s.firstMPT; o;) e = a[o.v], o.r ? e = Math.round(e) : e < 1e-6 && -1e-6 < e && (e = 0), o.t[o.p] = e, o = o._next;
                if (s.autoRotate && (s.autoRotate.rotation = a.rotation), 1 === t)
                    for (o = s.firstMPT; o;) {
                        if ((i = o.t).type) {
                            if (1 === i.type) {
                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                i.e = r
                            }
                        } else i.e = i.s + i.xs0;
                        o = o._next
                    }
            };

            function pt(t, e, i, n, r, s) {
                return (s = new mt(t, e, i, n - i, r, -1, s)).b = i, s.e = s.xs0 = n, s
            }
            var ft = function(t, e, i, n, r) {
                    this.t = t, this.p = e, this.v = i, this.r = r, n && ((n._prev = this)._next = n)
                },
                mt = (n._parseToProxy = function(t, e, i, n, r, s) {
                    var a, o, l, h, c = n,
                        u = {},
                        d = {},
                        p = i._transform,
                        f = Y;
                    for (i._transform = null, Y = e, n = r = i.parse(t, e, n, r), Y = f, s && (i._transform = p, c && (c._prev = null, c._prev && (c._prev._next = null))); n && n !== c;) {
                        if (n.type <= 1 && (d[o = n.p] = n.s + n.c, u[o] = n.s, s || (h = new ft(n, "s", o, h, n.r), n.c = 0), 1 === n.type))
                            for (a = n.l; 0 < --a;) l = "xn" + a, d[o = n.p + "_" + l] = n.data[l], u[o] = n[l], s || (h = new ft(n, l, o, h, n.rxp[l]));
                        n = n._next
                    }
                    return {
                        proxy: u,
                        end: d,
                        firstMPT: h,
                        pt: r
                    }
                }, n.CSSPropTween = function(t, e, i, n, r, s, a, o, l, h, c) {
                    this.t = t, this.p = e, this.s = i, this.c = n, this.n = a || e, t instanceof mt || u.push(this.n), this.r = o, this.type = s || 0, l && (this.pr = l, d = !0), this.b = void 0 === h ? i : h, this.e = void 0 === c ? i + n : c, r && ((this._next = r)._prev = this)
                }),
                gt = D.parseComplex = function(t, e, i, n, r, s, a, o, l, h) {
                    a = new mt(t, e, 0, 0, a, h ? 2 : 1, null, !1, o, i = i || s || "", n), n += "";
                    var c, u, d, p, f, m, g, v, _, y, x, b, w = i.split(", ").join(",").split(" "),
                        T = n.split(", ").join(",").split(" "),
                        M = w.length,
                        E = !1 !== A;
                    for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (w = w.join(" ").replace(W, ", ").split(" "), T = T.join(" ").replace(W, ", ").split(" "), M = w.length), M !== T.length && (M = (w = (s || "").split(" ")).length), a.plugin = l, a.setRatio = h, c = ct.lastIndex = 0; c < M; c++)
                        if (p = w[c], f = T[c], (v = parseFloat(p)) || 0 === v) a.appendXtra("", v, S(f, v), f.replace(R, ""), E && -1 !== f.indexOf("px"), !0);
                        else if (r && ct.test(p)) x = "," === f.charAt(f.length - 1) ? ")," : ")", b = -1 !== f.indexOf("hsl") && $, p = ht(p, b), f = ht(f, b), (v = 6 < p.length + f.length) && !$ && 0 === f[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(T[c]).join("transparent")) : ($ || (v = !1), b ? a.appendXtra(v ? "hsla(" : "hsl(", p[0], S(f[0], p[0]), ",", !1, !0).appendXtra("", p[1], S(f[1], p[1]), "%,", !1).appendXtra("", p[2], S(f[2], p[2]), v ? "%," : "%" + x, !1) : a.appendXtra(v ? "rgba(" : "rgb(", p[0], f[0] - p[0], ",", !0, !0).appendXtra("", p[1], f[1] - p[1], ",", !0).appendXtra("", p[2], f[2] - p[2], v ? "," : x, !0), v && (p = p.length < 4 ? 1 : p[3], a.appendXtra("", p, (f.length < 4 ? 1 : f[3]) - p, x, !1))), ct.lastIndex = 0;
                    else if (m = p.match(C)) {
                        if (!(g = f.match(R)) || g.length !== m.length) return a;
                        for (u = d = 0; u < m.length; u++) y = m[u], _ = p.indexOf(y, d), a.appendXtra(p.substr(d, _ - d), Number(y), S(g[u], y), "", E && "px" === p.substr(_ + y.length, 2), 0 === u), d = _ + y.length;
                        a["xs" + a.l] += p.substr(d)
                    } else a["xs" + a.l] += a.l ? " " + p : p;
                    if (-1 !== n.indexOf("=") && a.data) {
                        for (x = a.xs0 + a.data.s, c = 1; c < a.l; c++) x += a["xs" + c] + a.data["xn" + c];
                        a.e = x + a["xs" + c]
                    }
                    return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                },
                vt = 9;
            for ((t = mt.prototype).l = t.pr = 0; 0 < --vt;) t["xn" + vt] = 0, t["xs" + vt] = "";
            t.xs0 = "", t._next = t._prev = t.xfirst = t.data = t.plugin = t.setRatio = t.rxp = null, t.appendXtra = function(t, e, i, n, r, s) {
                var a = this,
                    o = a.l;
                return a["xs" + o] += s && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", 0 < o ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new mt(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0)) : (a.data = {
                    s: e + i
                }, a.rxp = {}, a.s = e, a.c = i, a.r = r), a) : (a["xs" + o] += e + (n || ""), a)
            };

            function _t(t, e) {
                e = e || {}, this.p = e.prefix && T(t) || t, (p[t] = p[this.p] = this).format = e.formatter || ut(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
            }
            var yt = n._registerComplexSpecialProp = function(t, e, i) {
                "object" != typeof e && (e = {
                    parser: i
                });
                var n, r = t.split(","),
                    s = e.defaultValue;
                for (i = i || [s], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || s, new _t(r[n], e)
            };
            (t = _t.prototype).parseComplex = function(t, e, i, n, r, s) {
                var a, o, l, h, c, u, d = this.keyword;
                if (this.multi && (W.test(i) || W.test(e) ? (o = e.replace(W, "|").split("|"), l = i.replace(W, "|").split("|")) : d && (o = [e], l = [i])), l) {
                    for (h = (l.length > o.length ? l : o).length, a = 0; a < h; a++) e = o[a] = o[a] || this.dflt, i = l[a] = l[a] || this.dflt, d && (c = e.indexOf(d)) !== (u = i.indexOf(d)) && (-1 === u ? o[a] = o[a].split(d).join("") : -1 === c && (o[a] += " " + d));
                    e = o.join(", "), i = l.join(", ")
                }
                return gt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, s)
            }, t.parse = function(t, e, i, n, r, s, a) {
                return this.parseComplex(t.style, this.format(nt(t, this.p, O, !1, this.dflt)), this.format(e), r, s)
            }, D.registerSpecialProp = function(t, o, l) {
                yt(t, {
                    parser: function(t, e, i, n, r, s, a) {
                        r = new mt(t, i, 0, 0, r, 2, i, !1, l);
                        return r.plugin = s, r.setRatio = o(t, e, n._tween, i), r
                    },
                    priority: l
                })
            }, D.useSVGTransformAttr = _ || k;

            function xt(t, e, i, n, r) {
                var s, a, o, l, h, c, u, d, p, f = t._gsTransform,
                    m = Nt(t, !0);
                f && (d = f.xOrigin, p = f.yOrigin), (!n || (s = n.split(" ")).length < 2) && (h = t.getBBox(), s = [(-1 !== (e = b(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * h.width : parseFloat(e[0])) + h.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * h.height : parseFloat(e[1])) + h.y]), i.xOrigin = a = parseFloat(s[0]), i.yOrigin = o = parseFloat(s[1]), n && m !== It && (l = m[0], h = m[1], e = m[2], c = m[3], n = m[4], c = a * (c / (u = l * c - h * e)) + o * (-e / u) + (e * (e = m[5]) - c * n) / u, u = a * (-h / u) + o * (l / u) - (l * e - h * n) / u, a = i.xOrigin = s[0] = c, o = i.yOrigin = s[1] = u), f && (r || !1 !== r && !1 !== D.defaultSmoothOrigin ? (c = a - d, u = o - p, f.xOffset += c * m[0] + u * m[2] - c, f.yOffset += c * m[1] + u * m[3] - u) : f.xOffset = f.yOffset = 0), t.setAttribute("data-svg-origin", s.join(" "))
            }

            function bt(t) {
                return !!(Ot && "function" == typeof t.getBBox && t.getCTM && (!t.parentNode || t.parentNode.getBBox && t.parentNode.getCTM))
            }

            function wt(t) {
                var e, i, n = this.data,
                    r = (m = -n.rotation * X) + n.skewX * X,
                    s = 1e5,
                    a = (Math.cos(m) * n.scaleX * s | 0) / s,
                    o = (Math.sin(m) * n.scaleX * s | 0) / s,
                    l = (Math.sin(r) * -n.scaleY * s | 0) / s,
                    h = (Math.cos(r) * n.scaleY * s | 0) / s,
                    c = this.t.style,
                    u = this.t.currentStyle;
                if (u) {
                    i = o, o = -l, l = -i, e = u.filter, c.filter = "";
                    var d = this.t.offsetWidth,
                        p = this.t.offsetHeight,
                        f = "absolute" !== u.position,
                        m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + o + ", M21=" + l + ", M22=" + h,
                        r = n.x + d * n.xPercent / 100,
                        s = n.y + p * n.yPercent / 100;
                    if (null != n.ox && (r += (y = (n.oxp ? d * n.ox * .01 : n.ox) - d / 2) - (y * a + (x = (n.oyp ? p * n.oy * .01 : n.oy) - p / 2) * o), s += x - (y * l + x * h)), m += f ? ", Dx=" + ((y = d / 2) - (y * a + (x = p / 2) * o) + r) + ", Dy=" + (x - (y * l + x * h) + s) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? c.filter = e.replace(j, m) : c.filter = m + " " + e, 0 !== t && 1 !== t || 1 == a && 0 == o && 0 == l && 1 == h && (f && -1 === m.indexOf("Dx=0, Dy=0") || z.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && c.removeAttribute("filter")), !f) {
                        var g, v, _ = P < 8 ? 1 : -1,
                            y = n.ieOffsetX || 0,
                            x = n.ieOffsetY || 0;
                        for (n.ieOffsetX = Math.round((d - ((a < 0 ? -a : a) * d + (o < 0 ? -o : o) * p)) / 2 + r), n.ieOffsetY = Math.round((p - ((h < 0 ? -h : h) * p + (l < 0 ? -l : l) * d)) / 2 + s), vt = 0; vt < 4; vt++) v = (i = -1 !== (v = u[g = ot[vt]]).indexOf("px") ? parseFloat(v) : rt(this.t, g, parseFloat(v), v.replace(N, "")) || 0) !== n[g] ? vt < 2 ? -n.ieOffsetX : -n.ieOffsetY : vt < 2 ? y - n.ieOffsetX : x - n.ieOffsetY, c[g] = (n[g] = Math.round(i - v * (0 === vt || 2 === vt ? 1 : _))) + "px"
                    }
                }
            }
            var Tt, Mt, Et, St = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                At = T("transform"),
                Pt = tt + "transform",
                Ct = T("transformOrigin"),
                Rt = null !== T("perspective"),
                Lt = n.Transform = function() {
                    this.perspective = parseFloat(D.defaultTransformPerspective) || 0, this.force3D = !(!1 === D.defaultForce3D || !Rt) && (D.defaultForce3D || "auto")
                },
                Ot = window.SVGElement,
                Dt = function(t, e, i) {
                    var n, r = Z.createElementNS("http://www.w3.org/2000/svg", t),
                        s = /([a-z])([A-Z])/g;
                    for (n in i) r.setAttributeNS(null, n.replace(s, "$1-$2").toLowerCase(), i[n]);
                    return e.appendChild(r), r
                },
                e = Z.documentElement,
                kt = (Et = P || /Android/i.test(K) && !window.chrome, Z.createElementNS && !Et && (Mt = Dt("svg", e), Dt = (K = Dt("rect", Mt, {
                    width: 100,
                    height: 50,
                    x: 100
                })).getBoundingClientRect().width, K.style[Ct] = "50% 50%", K.style[At] = "scaleX(0.5)", Et = Dt === K.getBoundingClientRect().width && !(k && Rt), e.removeChild(Mt)), Et),
                It = [1, 0, 0, 1, 0, 0],
                Nt = function(t, e) {
                    var i, n, r, s, a, o = t._gsTransform || new Lt;
                    if (At ? n = nt(t, Pt, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(V)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), o.x || 0, o.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, (o.svg || t.getBBox && bt(t)) && (i && -1 !== (t.style[At] + "").indexOf("matrix") && (n = t.style[At], i = 0), r = t.getAttribute("transform"), i && r && (-1 !== r.indexOf("matrix") ? (n = r, i = 0) : -1 !== r.indexOf("translate") && (n = "matrix(1,0,0,1," + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", i = 0))), i) return It;
                    for (r = (n || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], vt = r.length; - 1 < --vt;) s = Number(r[vt]), r[vt] = (a = s - (s |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + s : s;
                    return e && 6 < r.length ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                },
                zt = n.getTransform = function(t, e, i, n) {
                    if (t._gsTransform && i && !n) return t._gsTransform;
                    var r, s, a, o, l, h, c, u, d, p, f, m, g, v, _, y, x, b, w, T, M, E, S, A = i && t._gsTransform || new Lt,
                        P = A.scaleX < 0,
                        C = Rt && (parseFloat(nt(t, Ct, e, !1, "0 0 0").split(" ")[2]) || A.zOrigin) || 0,
                        R = parseFloat(D.defaultTransformPerspective) || 0;
                    if (A.svg = !(!t.getBBox || !bt(t)), A.svg && (xt(t, nt(t, Ct, O, !1, "50% 50%") + "", A, t.getAttribute("data-svg-origin")), Tt = D.useSVGTransformAttr || kt), s = Nt(t), s !== It)
                        for (r in 16 === s.length ? (T = s[0], E = s[1], a = s[2], o = s[3], M = s[4], S = s[5], l = s[6], h = s[7], c = s[8], u = s[9], d = s[10], p = s[12], f = s[13], w = s[14], m = s[11], g = Math.atan2(l, d), A.zOrigin && (p = c * (w = -A.zOrigin) - s[12], f = u * w - s[13], w = d * w + A.zOrigin - s[14]), A.rotationX = g * q, g && (v = M * (x = Math.cos(-g)) + c * (b = Math.sin(-g)), _ = S * x + u * b, y = l * x + d * b, c = M * -b + c * x, u = S * -b + u * x, d = l * -b + d * x, m = h * -b + m * x, M = v, S = _, l = y), g = Math.atan2(c, d), A.rotationY = g * q, g && (_ = E * (x = Math.cos(-g)) - u * (b = Math.sin(-g)), y = a * x - d * b, u = E * b + u * x, d = a * b + d * x, m = o * b + m * x, T = v = T * x - c * b, E = _, a = y), g = Math.atan2(E, T), A.rotation = g * q, g && (T = T * (x = Math.cos(-g)) + M * (b = Math.sin(-g)), _ = E * x + S * b, S = E * -b + S * x, l = a * -b + l * x, E = _), A.rotationX && 359.9 < Math.abs(A.rotationX) + Math.abs(A.rotation) && (A.rotationX = A.rotation = 0, A.rotationY += 180), A.scaleX = (1e5 * Math.sqrt(T * T + E * E) + .5 | 0) / 1e5, A.scaleY = (1e5 * Math.sqrt(S * S + u * u) + .5 | 0) / 1e5, A.scaleZ = (1e5 * Math.sqrt(l * l + d * d) + .5 | 0) / 1e5, A.skewX = 0, A.perspective = m ? 1 / (m < 0 ? -m : m) : 0, A.x = p, A.y = f, A.z = w, A.svg && (A.x -= A.xOrigin - (A.xOrigin * T - A.yOrigin * M), A.y -= A.yOrigin - (A.yOrigin * E - A.xOrigin * S))) : Rt && !n && s.length && A.x === s[4] && A.y === s[5] && (A.rotationX || A.rotationY) || void 0 !== A.x && "none" === nt(t, "display", e) || (T = (w = 6 <= s.length) ? s[0] : 1, M = s[1] || 0, E = s[2] || 0, S = w ? s[3] : 1, A.x = s[4] || 0, A.y = s[5] || 0, n = Math.sqrt(T * T + M * M), e = Math.sqrt(S * S + E * E), w = T || M ? Math.atan2(M, T) * q : A.rotation || 0, s = E || S ? Math.atan2(E, S) * q + w : A.skewX || 0, 90 < Math.abs(s) && Math.abs(s) < 270 && (P ? (n *= -1, s += w <= 0 ? 180 : -180, w += w <= 0 ? 180 : -180) : (e *= -1, s += s <= 0 ? 180 : -180)), A.scaleX = n, A.scaleY = e, A.rotation = w, A.skewX = s, Rt && (A.rotationX = A.rotationY = A.z = 0, A.perspective = R, A.scaleZ = 1), A.svg && (A.x -= A.xOrigin - (A.xOrigin * T + A.yOrigin * E), A.y -= A.yOrigin - (A.xOrigin * M + A.yOrigin * S))), A.zOrigin = C, A) A[r] < 2e-5 && -2e-5 < A[r] && (A[r] = 0);
                    return i && (t._gsTransform = A).svg && (Tt && t.style[At] ? L.delayedCall(.001, function() {
                        Ht(t.style, At)
                    }) : !Tt && t.getAttribute("transform") && L.delayedCall(.001, function() {
                        t.removeAttribute("transform")
                    })), A
                },
                Bt = n.set3DTransformRatio = n.setTransformRatio = function(t) {
                    var e, i, n, r, s, a, o, l, h, c, u, d, p, f, m, g, v, _, y = this.data,
                        x = this.t.style,
                        b = y.rotation,
                        w = y.rotationX,
                        T = y.rotationY,
                        M = y.scaleX,
                        E = y.scaleY,
                        S = y.scaleZ,
                        A = y.x,
                        P = y.y,
                        C = y.z,
                        R = y.svg,
                        L = y.perspective,
                        O = y.force3D;
                    if (!((1 !== t && 0 !== t || "auto" !== O || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && O || C || L || T || w) || Tt && R || !Rt) b || y.skewX || R ? (b *= X, v = y.skewX * X, _ = 1e5, e = Math.cos(b) * M, r = Math.sin(b) * M, i = Math.sin(b - v) * -E, s = Math.cos(b - v) * E, v && "simple" === y.skewType && (m = Math.tan(v), i *= m = Math.sqrt(1 + m * m), s *= m, y.skewY && (e *= m, r *= m)), R && (A += y.xOrigin - (y.xOrigin * e + y.yOrigin * i) + y.xOffset, P += y.yOrigin - (y.xOrigin * r + y.yOrigin * s) + y.yOffset, Tt && (y.xPercent || y.yPercent) && (d = this.t.getBBox(), A += .01 * y.xPercent * d.width, P += .01 * y.yPercent * d.height), A < (d = 1e-6) && -d < A && (A = 0), P < d && -d < P && (P = 0)), g = (e * _ | 0) / _ + "," + (r * _ | 0) / _ + "," + (i * _ | 0) / _ + "," + (s * _ | 0) / _ + "," + A + "," + P + ")", R && Tt ? this.t.setAttribute("transform", "matrix(" + g) : x[At] = (y.xPercent || y.yPercent ? "translate(" + y.xPercent + "%," + y.yPercent + "%) matrix(" : "matrix(") + g) : x[At] = (y.xPercent || y.yPercent ? "translate(" + y.xPercent + "%," + y.yPercent + "%) matrix(" : "matrix(") + M + ",0,0," + E + "," + A + "," + P + ")";
                    else {
                        if (k && (M < (d = 1e-4) && -d < M && (M = S = 2e-5), E < d && -d < E && (E = S = 2e-5), !L || y.z || y.rotationX || y.rotationY || (L = 0)), b || y.skewX) b *= X, p = e = Math.cos(b), f = r = Math.sin(b), y.skewX && (b -= y.skewX * X, p = Math.cos(b), f = Math.sin(b), "simple" === y.skewType && (m = Math.tan(y.skewX * X), p *= m = Math.sqrt(1 + m * m), f *= m, y.skewY && (e *= m, r *= m))), i = -f, s = p;
                        else {
                            if (!(T || w || 1 !== S || L || R)) return void(x[At] = (y.xPercent || y.yPercent ? "translate(" + y.xPercent + "%," + y.yPercent + "%) translate3d(" : "translate3d(") + A + "px," + P + "px," + C + "px)" + (1 !== M || 1 !== E ? " scale(" + M + "," + E + ")" : ""));
                            e = s = 1, i = r = 0
                        }
                        h = 1, n = a = o = l = c = u = 0, t = L ? -1 / L : 0, O = y.zOrigin, d = 1e-6, v = ",", _ = "0", (b = T * X) && (p = Math.cos(b), c = t * (o = -(f = Math.sin(b))), n = e * f, a = r * f, t *= h = p, e *= p, r *= p), (b = w * X) && (m = i * (p = Math.cos(b)) + n * (f = Math.sin(b)), b = s * p + a * f, l = h * f, u = t * f, n = i * -f + n * p, a = s * -f + a * p, h *= p, t *= p, i = m, s = b), 1 !== S && (n *= S, a *= S, h *= S, t *= S), 1 !== E && (i *= E, s *= E, l *= E, u *= E), 1 !== M && (e *= M, r *= M, o *= M, c *= M), (O || R) && (O && (A += n * -O, P += a * -O, C += h * -O + O), R && (A += y.xOrigin - (y.xOrigin * e + y.yOrigin * i) + y.xOffset, P += y.yOrigin - (y.xOrigin * r + y.yOrigin * s) + y.yOffset), A < d && -d < A && (A = _), P < d && -d < P && (P = _), C < d && -d < C && (C = 0)), g = y.xPercent || y.yPercent ? "translate(" + y.xPercent + "%," + y.yPercent + "%) matrix3d(" : "matrix3d(", g += (e < d && -d < e ? _ : e) + v + (r < d && -d < r ? _ : r) + v + (o < d && -d < o ? _ : o), g += v + (c < d && -d < c ? _ : c) + v + (i < d && -d < i ? _ : i) + v + (s < d && -d < s ? _ : s), w || T ? (g += v + (l < d && -d < l ? _ : l) + v + (u < d && -d < u ? _ : u) + v + (n < d && -d < n ? _ : n), g += v + (a < d && -d < a ? _ : a) + v + (h < d && -d < h ? _ : h) + v + (t < d && -d < t ? _ : t) + v) : g += ",0,0,0,0,1,0,", g += A + v + P + v + C + v + (L ? 1 + -C / L : 1) + ")", x[At] = g
                    }
                };
            (t = Lt.prototype).x = t.y = t.z = t.skewX = t.skewY = t.rotation = t.rotationX = t.rotationY = t.zOrigin = t.xPercent = t.yPercent = t.xOffset = t.yOffset = 0, t.scaleX = t.scaleY = t.scaleZ = 1, yt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                parser: function(t, e, i, n, r, s, a) {
                    if (n._lastParsedTransform === a) return r;
                    n._lastParsedTransform = a;
                    var o, l, h, c, u, d, p, f, m = t._gsTransform,
                        g = t.style,
                        v = St.length,
                        _ = a,
                        y = {},
                        x = "transformOrigin";
                    if (a.display ? (h = nt(t, "display"), g.display = "block", o = zt(t, O, !0, a.parseTransform), g.display = h) : o = zt(t, O, !0, a.parseTransform), n._transform = o, "string" == typeof _.transform && At)(h = J.style)[At] = _.transform, h.display = "block", h.position = "absolute", Z.body.appendChild(J), l = zt(J, null, !1), Z.body.removeChild(J), l.perspective || (l.perspective = o.perspective), null != _.xPercent && (l.xPercent = M(_.xPercent, o.xPercent)), null != _.yPercent && (l.yPercent = M(_.yPercent, o.yPercent));
                    else if ("object" == typeof _) {
                        if (l = {
                                scaleX: M(null != _.scaleX ? _.scaleX : _.scale, o.scaleX),
                                scaleY: M(null != _.scaleY ? _.scaleY : _.scale, o.scaleY),
                                scaleZ: M(_.scaleZ, o.scaleZ),
                                x: M(_.x, o.x),
                                y: M(_.y, o.y),
                                z: M(_.z, o.z),
                                xPercent: M(_.xPercent, o.xPercent),
                                yPercent: M(_.yPercent, o.yPercent),
                                perspective: M(_.transformPerspective, o.perspective)
                            }, null != (p = _.directionalRotation))
                            if ("object" == typeof p)
                                for (h in p) _[h] = p[h];
                            else _.rotation = p;
                        "string" == typeof _.x && -1 !== _.x.indexOf("%") && (l.x = 0, l.xPercent = M(_.x, o.xPercent)), "string" == typeof _.y && -1 !== _.y.indexOf("%") && (l.y = 0, l.yPercent = M(_.y, o.yPercent)), l.rotation = E("rotation" in _ ? _.rotation : "shortRotation" in _ ? _.shortRotation + "_short" : "rotationZ" in _ ? _.rotationZ : o.rotation, o.rotation, "rotation", y), Rt && (l.rotationX = E("rotationX" in _ ? _.rotationX : "shortRotationX" in _ ? _.shortRotationX + "_short" : o.rotationX || 0, o.rotationX, "rotationX", y), l.rotationY = E("rotationY" in _ ? _.rotationY : "shortRotationY" in _ ? _.shortRotationY + "_short" : o.rotationY || 0, o.rotationY, "rotationY", y)), l.skewX = null == _.skewX ? o.skewX : E(_.skewX, o.skewX), l.skewY = null == _.skewY ? o.skewY : E(_.skewY, o.skewY), (f = l.skewY - o.skewY) && (l.skewX += f, l.rotation += f)
                    }
                    for (Rt && null != _.force3D && (o.force3D = _.force3D, d = !0), o.skewType = _.skewType || o.skewType || D.defaultSkewType, (u = o.force3D || o.z || o.rotationX || o.rotationY || l.z || l.rotationX || l.rotationY || l.perspective) || null == _.scale || (l.scaleZ = 1); - 1 < --v;)(1e-6 < (c = l[i = St[v]] - o[i]) || c < -1e-6 || null != _[i] || null != Y[i]) && (d = !0, r = new mt(o, i, o[i], c, r), i in y && (r.e = y[i]), r.xs0 = 0, r.plugin = s, n._overwriteProps.push(r.n));
                    return c = _.transformOrigin, o.svg && (c || _.svgOrigin) && (a = o.xOffset, f = o.yOffset, xt(t, b(c), l, _.svgOrigin, _.smoothOrigin), r = pt(o, "xOrigin", (m ? o : l).xOrigin, l.xOrigin, r, x), r = pt(o, "yOrigin", (m ? o : l).yOrigin, l.yOrigin, r, x), a === o.xOffset && f === o.yOffset || (r = pt(o, "xOffset", m ? a : o.xOffset, o.xOffset, r, x), r = pt(o, "yOffset", m ? f : o.yOffset, o.yOffset, r, x)), c = Tt ? null : "0px 0px"), (c || Rt && u && o.zOrigin) && (At ? (d = !0, i = Ct, c = (c || nt(t, i, O, !1, "50% 50%")) + "", (r = new mt(g, i, 0, 0, r, -1, x)).b = g[i], r.plugin = s, Rt ? (h = o.zOrigin, c = c.split(" "), o.zOrigin = (2 < c.length && (0 === h || "0px" !== c[2]) ? parseFloat(c[2]) : h) || 0, r.xs0 = r.e = c[0] + " " + (c[1] || "50%") + " 0px", (r = new mt(o, "zOrigin", 0, 0, r, -1, r.n)).b = h, r.xs0 = r.e = o.zOrigin) : r.xs0 = r.e = c) : b(c + "", o)), d && (n._transformType = o.svg && Tt || !u && 3 !== this._transformType ? 2 : 3), r
                },
                prefix: !0
            }), yt("boxShadow", {
                defaultValue: "0px 0px 0px 0px #999",
                prefix: !0,
                color: !0,
                multi: !0,
                keyword: "inset"
            }), yt("borderRadius", {
                defaultValue: "0px",
                parser: function(t, e, i, n, r, s) {
                    e = this.format(e);
                    for (var a, o, l, h, c, u, d, p, f, m, g = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], v = t.style, _ = parseFloat(t.offsetWidth), y = parseFloat(t.offsetHeight), x = e.split(" "), b = 0; b < g.length; b++) this.p.indexOf("border") && (g[b] = T(g[b])), -1 !== (l = o = nt(t, g[b], O, !1, "0px")).indexOf(" ") && (l = (o = l.split(" "))[0], o = o[1]), h = a = x[b], f = parseFloat(l), m = l.substr((f + "").length), "" === (u = (d = "=" === h.charAt(1)) ? (c = parseInt(h.charAt(0) + "1", 10), h = h.substr(2), c *= parseFloat(h), h.substr((c + "").length - (c < 0 ? 1 : 0)) || "") : (c = parseFloat(h), h.substr((c + "").length))) && (u = w[i] || m), u !== m && (p = rt(t, "borderLeft", f, m), f = rt(t, "borderTop", f, m), o = "%" === u ? (l = p / _ * 100 + "%", f / y * 100 + "%") : "em" === u ? (l = p / (m = rt(t, "borderLeft", 1, "em")) + "em", f / m + "em") : (l = p + "px", f + "px"), d && (h = parseFloat(l) + c + u, a = parseFloat(o) + c + u)), r = gt(v, g[b], l + " " + o, h + " " + a, !1, "0px", r);
                    return r
                },
                prefix: !0,
                formatter: ut("0px 0px 0px 0px", !1, !0)
            }), yt("backgroundPosition", {
                defaultValue: "0 0",
                parser: function(t, e, i, n, r, s) {
                    var a, o, l, h, c, u, d = "background-position",
                        p = O || it(t, null),
                        f = this.format((p ? P ? p.getPropertyValue(d + "-x") + " " + p.getPropertyValue(d + "-y") : p.getPropertyValue(d) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                        e = this.format(e);
                    if (-1 !== f.indexOf("%") != (-1 !== e.indexOf("%")) && (u = nt(t, "backgroundImage").replace(H, "")) && "none" !== u) {
                        for (a = f.split(" "), o = e.split(" "), Q.setAttribute("src", u), l = 2; - 1 < --l;)(h = -1 !== (f = a[l]).indexOf("%")) != (-1 !== o[l].indexOf("%")) && (c = 0 === l ? t.offsetWidth - Q.width : t.offsetHeight - Q.height, a[l] = h ? parseFloat(f) / 100 * c + "px" : parseFloat(f) / c * 100 + "%");
                        f = a.join(" ")
                    }
                    return this.parseComplex(t.style, f, e, r, s)
                },
                formatter: b
            }), yt("backgroundSize", {
                defaultValue: "0 0",
                formatter: b
            }), yt("perspective", {
                defaultValue: "0px",
                prefix: !0
            }), yt("perspectiveOrigin", {
                defaultValue: "50% 50%",
                prefix: !0
            }), yt("transformStyle", {
                prefix: !0
            }), yt("backfaceVisibility", {
                prefix: !0
            }), yt("userSelect", {
                prefix: !0
            }), yt("margin", {
                parser: dt("marginTop,marginRight,marginBottom,marginLeft")
            }), yt("padding", {
                parser: dt("paddingTop,paddingRight,paddingBottom,paddingLeft")
            }), yt("clip", {
                defaultValue: "rect(0px,0px,0px,0px)",
                parser: function(t, e, i, n, r, s) {
                    var a, o;
                    return e = P < 9 ? (a = t.currentStyle, o = P < 8 ? " " : ",", a = "rect(" + a.clipTop + o + a.clipRight + o + a.clipBottom + o + a.clipLeft + ")", this.format(e).split(",").join(o)) : (a = this.format(nt(t, this.p, O, !1, this.dflt)), this.format(e)), this.parseComplex(t.style, a, e, r, s)
                }
            }), yt("textShadow", {
                defaultValue: "0px 0px 0px #999",
                color: !0,
                multi: !0
            }), yt("autoRound,strictUnits", {
                parser: function(t, e, i, n, r) {
                    return r
                }
            }), yt("border", {
                defaultValue: "0px solid #000",
                parser: function(t, e, i, n, r, s) {
                    return this.parseComplex(t.style, this.format(nt(t, "borderTopWidth", O, !1, "0px") + " " + nt(t, "borderTopStyle", O, !1, "solid") + " " + nt(t, "borderTopColor", O, !1, "#000")), this.format(e), r, s)
                },
                color: !0,
                formatter: function(t) {
                    var e = t.split(" ");
                    return e[0] + " " + (e[1] || "solid") + " " + (t.match(ct) || ["#000"])[0]
                }
            }), yt("borderWidth", {
                parser: dt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
            }), yt("float,cssFloat,styleFloat", {
                parser: function(t, e, i, n, r, s) {
                    var a = t.style,
                        t = "cssFloat" in a ? "cssFloat" : "styleFloat";
                    return new mt(a, t, 0, 0, r, -1, i, !1, 0, a[t], e)
                }
            });

            function Ut(t) {
                var e, i = this.t,
                    n = i.filter || nt(this.data, "filter") || "";
                100 == (t = this.s + this.c * t | 0) && (e = -1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), !nt(this.data, "filter")) : (i.filter = n.replace(r, ""), !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + t + ")"), -1 === n.indexOf("pacity") ? 0 == t && this.xn1 || (i.filter = n + " alpha(opacity=" + t + ")") : i.filter = n.replace(z, "opacity=" + t))
            }
            yt("opacity,alpha,autoAlpha", {
                defaultValue: "1",
                parser: function(t, e, i, n, r, s) {
                    var a = parseFloat(nt(t, "opacity", O, !1, "1")),
                        o = t.style,
                        l = "autoAlpha" === i;
                    return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + a), l && 1 === a && "hidden" === nt(t, "visibility", O) && 0 !== e && (a = 0), $ ? r = new mt(o, "opacity", a, e - a, r) : ((r = new mt(o, "opacity", 100 * a, 100 * (e - a), r)).xn1 = l ? 1 : 0, o.zoom = 1, r.type = 2, r.b = "alpha(opacity=" + r.s + ")", r.e = "alpha(opacity=" + (r.s + r.c) + ")", r.data = t, r.plugin = s, r.setRatio = Ut), l && ((r = new mt(o, "visibility", 0, 0, r, -1, null, !1, 0, 0 !== a ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", n._overwriteProps.push(r.n), n._overwriteProps.push(i)), r
                }
            });

            function Ft(t) {
                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Ht(i, e.p), e = e._next;
                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
            }
            var Ht = function(t, e) {
                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(l, "-$1").toLowerCase())) : t.removeAttribute(e))
            };
            yt("className", {
                parser: function(t, e, i, n, r, s, a) {
                    var o, l, h, c = t.getAttribute("class") || "",
                        u = t.style.cssText;
                    if ((r = n._classNamePT = new mt(t, i, 0, 0, r, 2)).setRatio = Ft, r.pr = -11, d = !0, r.b = c, o = m(t, O), i = t._gsClassPT) {
                        for (l = {}, h = i.data; h;) l[h.p] = 1, h = h._next;
                        i.setRatio(1)
                    }
                    return (t._gsClassPT = r).e = "=" !== e.charAt(1) ? e : c.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", r.e), a = g(t, o, m(t), a, l), t.setAttribute("class", c), r.data = a.firstMPT, t.style.cssText = u, r = r.xfirst = n.parse(t, a.difs, r, s)
                }
            });

            function Gt(t) {
                if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                    var e, i, n, r, s = this.t.style,
                        a = p.transform.parse;
                    if ("all" === this.e) r = !(s.cssText = "");
                    else
                        for (n = (e = this.e.split(" ").join("").split(",")).length; - 1 < --n;) i = e[n], p[i] && (p[i].parse === a ? r = !0 : i = "transformOrigin" === i ? Ct : p[i].p), Ht(s, i);
                    r && (Ht(s, At), (t = this.t._gsTransform) && (t.svg && this.t.removeAttribute("data-svg-origin"), delete this.t._gsTransform))
                }
            }
            for (yt("clearProps", {
                    parser: function(t, e, i, n, r) {
                        return (r = new mt(t, i, 0, 0, r, 2)).setRatio = Gt, r.e = e, r.pr = -10, r.data = n._tween, d = !0, r
                    }
                }), t = "bezier,throwProps,physicsProps,physics2D".split(","), vt = t.length; vt--;) ! function(t) {
                var l;
                p[t] || (l = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin", yt(t, {
                    parser: function(t, e, i, n, r, s, a) {
                        var o = h.com.greensock.plugins[l];
                        return o ? (o._cssRegister(), p[i].parse(t, e, i, n, r, s, a)) : (f("Error: " + l + " js file not loaded."), r)
                    }
                }))
            }(t[vt]);
            (t = D.prototype)._firstPT = t._lastParsedTransform = t._transform = null, t._onInitTween = function(t, e, i) {
                if (!t.nodeType) return !1;
                this._target = t, this._tween = i, this._vars = e, A = e.autoRound, d = !1, w = e.suffixMap || D.suffixMap, O = it(t, ""), u = this._overwriteProps;
                var n, r, s, a, o, l, h = t.style;
                if (v && "" === h.zIndex && ("auto" !== (l = nt(t, "zIndex", O)) && "" !== l || this._addLazySet(h, "zIndex", 0)), "string" == typeof e && (s = h.cssText, l = m(t, O), h.cssText = s + ";" + e, l = g(t, l, m(t)).difs, !$ && B.test(e) && (l.opacity = parseFloat(RegExp.$1)), e = l, h.cssText = s), e.className ? this._firstPT = n = p.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = n = this.parse(t, e, null), this._transformType) {
                    for (l = 3 === this._transformType, At ? _ && (v = !0, "" === h.zIndex && ("auto" !== (e = nt(t, "zIndex", O)) && "" !== e || this._addLazySet(h, "zIndex", 0)), y && this._addLazySet(h, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (l ? "visible" : "hidden"))) : h.zoom = 1, r = n; r && r._next;) r = r._next;
                    h = new mt(t, "transform", 0, 0, null, 2), this._linkCSSP(h, null, r), h.setRatio = At ? Bt : wt, h.data = this._transform || zt(t, O, !0), h.tween = i, h.pr = -1, u.pop()
                }
                if (d) {
                    for (; n;) {
                        for (o = n._next, r = s; r && r.pr > n.pr;) r = r._next;
                        (n._prev = r ? r._prev : a) ? n._prev._next = n: s = n, (n._next = r) ? r._prev = n : a = n, n = o
                    }
                    this._firstPT = s
                }
                return !0
            }, t.parse = function(t, e, i, n) {
                var r, s, a, o, l, h, c, u, d = t.style;
                for (r in e) l = e[r], (u = p[r]) ? i = u.parse(t, l, r, this, i, n, e) : (o = nt(t, r, O) + "", c = "string" == typeof l, "color" === r || "fill" === r || "stroke" === r || -1 !== r.indexOf("Color") || c && U.test(l) ? (c || (l = (3 < (l = ht(l)).length ? "rgba(" : "rgb(") + l.join(",") + ")"), i = gt(d, r, o, l, !0, "transparent", i, 0, n)) : !c || -1 === l.indexOf(" ") && -1 === l.indexOf(",") ? (h = (s = parseFloat(o)) || 0 === s ? o.substr((s + "").length) : "", "" !== o && "auto" !== o || (h = "width" === r || "height" === r ? (s = function(t, e, i) {
                    var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                        r = at[e],
                        s = r.length;
                    for (i = i || it(t, null); - 1 < --s;) n -= parseFloat(nt(t, "padding" + r[s], i, !0)) || 0, n -= parseFloat(nt(t, "border" + r[s] + "Width", i, !0)) || 0;
                    return n
                }(t, r, O), "px") : "left" === r || "top" === r ? (s = st(t, r, O), "px") : (s = "opacity" !== r ? 0 : 1, "")), "" === (c = (u = c && "=" === l.charAt(1)) ? (a = parseInt(l.charAt(0) + "1", 10), l = l.substr(2), a *= parseFloat(l), l.replace(N, "")) : (a = parseFloat(l), c ? l.replace(N, "") : "")) && (c = r in w ? w[r] : h), l = a || 0 === a ? (u ? a + s : a) + c : e[r], h !== c && "" !== c && (a || 0 === a) && s && (s = rt(t, r, s, h), "%" === c ? (s /= rt(t, r, 100, "%") / 100, !0 !== e.strictUnits && (o = s + "%")) : "em" === c || "rem" === c ? s /= rt(t, r, 1, c) : "px" !== c && (a = rt(t, r, a, c), c = "px"), u && (!a && 0 !== a || (l = a + s + c))), u && (a += s), !s && 0 !== s || !a && 0 !== a ? void 0 !== d[r] && (l || l + "" != "NaN" && null != l) ? (i = new mt(d, r, a || s || 0, 0, i, -1, r, !1, 0, o, l)).xs0 = "none" !== l || "display" !== r && -1 === r.indexOf("Style") ? l : o : f("invalid " + r + " tween value: " + e[r]) : (i = new mt(d, r, s, a - s, i, 0, r, !1 !== A && ("px" === c || "zIndex" === r), 0, o, l)).xs0 = c) : i = gt(d, r, o, l, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n);
                return i
            }, t.setRatio = function(t) {
                var e, i, n, r = this._firstPT;
                if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                    if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                        for (; r;) {
                            if (e = r.c * t + r.s, r.r ? e = Math.round(e) : e < 1e-6 && -1e-6 < e && (e = 0), r.type)
                                if (1 === r.type)
                                    if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                    else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                            else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                            else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                            else {
                                for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                r.t[r.p] = i
                            } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                            else r.t[r.p] = e + r.xs0;
                            r = r._next
                        } else
                            for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                    else
                        for (; r;) {
                            if (2 !== r.type)
                                if (r.r && -1 !== r.type)
                                    if (e = Math.round(r.s + r.c), r.type) {
                                        if (1 === r.type) {
                                            for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                            r.t[r.p] = i
                                        }
                                    } else r.t[r.p] = e + r.xs0;
                            else r.t[r.p] = r.e;
                            else r.setRatio(t);
                            r = r._next
                        }
            }, t._enableTransforms = function(t) {
                this._transform = this._transform || zt(this._target, O, !0), this._transformType = this._transform.svg && Tt || !t && 3 !== this._transformType ? 2 : 3
            };

            function Vt(t) {
                this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
            }
            t._addLazySet = function(t, e, i) {
                e = this._firstPT = new mt(t, e, 0, 0, this._firstPT, 2);
                e.e = i, e.setRatio = Vt, e.data = this
            }, t._linkCSSP = function(t, e, i, n) {
                return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
            }, t._kill = function(t) {
                var e, i, n, r = t;
                if (t.autoAlpha || t.alpha) {
                    for (i in r = {}, t) r[i] = t[i];
                    r.opacity = 1, r.autoAlpha && (r.visibility = 1)
                }
                return t.className && (e = this._classNamePT) && ((n = e.xfirst) && n._prev ? this._linkCSSP(n._prev, e._next, n._prev._prev) : n === this._firstPT && (this._firstPT = e._next), e._next && this._linkCSSP(e._next, e._next._next, n._prev), this._classNamePT = null), s.prototype._kill.call(this, r)
            };
            var jt = function(t, e, i) {
                var n, r, s, a;
                if (t.slice)
                    for (r = t.length; - 1 < --r;) jt(t[r], e, i);
                else
                    for (r = (n = t.childNodes).length; - 1 < --r;) a = (s = n[r]).type, s.style && (e.push(m(s)), i && i.push(s)), 1 !== a && 9 !== a && 11 !== a || !s.childNodes.length || jt(s, e, i)
            };
            return D.cascadeTo = function(t, e, i) {
                var n, r, s, a, o = L.to(t, e, i),
                    l = [o],
                    h = [],
                    c = [],
                    u = [],
                    d = L._internals.reservedProps;
                for (t = o._targets || o.target, jt(t, h, u), o.render(e, !0, !0), jt(t, c), o.render(0, !0, !0), o._enabled(!0), n = u.length; - 1 < --n;)
                    if ((r = g(u[n], h[n], c[n])).firstMPT) {
                        for (s in r = r.difs, i) d[s] && (r[s] = i[s]);
                        for (s in a = {}, r) a[s] = h[n][s];
                        l.push(L.fromTo(u[n], e, a, r))
                    }
                return l
            }, s.activate([D]), D
        }, !0), (t = (t = _gsScope._gsDefine.plugin({
            propName: "roundProps",
            version: "1.5",
            priority: -1,
            API: 2,
            init: function(t, e, i) {
                return this._tween = i, !0
            }
        })).prototype)._onInitAllProps = function() {
            for (var t, e, i, n = this._tween, r = n.vars.roundProps.join ? n.vars.roundProps : n.vars.roundProps.split(","), s = r.length, a = {}, o = n._propLookup.roundProps; - 1 < --s;) a[r[s]] = 1;
            for (s = r.length; - 1 < --s;)
                for (t = r[s], e = n._firstPT; e;) i = e._next, e.pg ? e.t._roundProps(a, !0) : e.n === t && (2 === e.f && e.t ? function(t) {
                    for (; t;) t.f || t.blob || (t.r = 1), t = t._next
                }(e.t._firstPT) : (this._add(e.t, t, e.s, e.c), i && (i._prev = e._prev), e._prev ? e._prev._next = i : n._firstPT === e && (n._firstPT = i), e._next = e._prev = null, n._propLookup[t] = o)), e = i;
            return !1
        }, t._add = function(t, e, i, n) {
            this._addTween(t, e, i, i + n, e, !0), this._overwriteProps.push(e)
        }, _gsScope._gsDefine.plugin({
            propName: "attr",
            API: 2,
            version: "0.5.0",
            init: function(t, e, i) {
                if ("function" != typeof t.setAttribute) return !1;
                for (var n in e) this._addTween(t, "setAttribute", t.getAttribute(n) + "", e[n] + "", n, !1, n), this._overwriteProps.push(n);
                return !0
            }
        }), _gsScope._gsDefine.plugin({
            propName: "directionalRotation",
            version: "0.2.1",
            API: 2,
            init: function(t, e, i) {
                "object" != typeof e && (e = {
                    rotation: e
                }), this.finals = {};
                var n, r, s, a, o, l = !0 === e.useRadians ? 2 * Math.PI : 360;
                for (n in e) "useRadians" !== n && (r = (o = (e[n] + "").split("_"))[0], s = parseFloat("function" != typeof t[n] ? t[n] : t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]()), a = (this.finals[n] = "string" == typeof r && "=" === r.charAt(1) ? s + parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2)) : Number(r) || 0) - s, o.length && (-1 !== (r = o.join("_")).indexOf("short") && (a %= l) !== a % (l / 2) && (a = a < 0 ? a + l : a - l), -1 !== r.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * l) % l - (a / l | 0) * l : -1 !== r.indexOf("ccw") && 0 < a && (a = (a - 9999999999 * l) % l - (a / l | 0) * l)), (1e-6 < a || a < -1e-6) && (this._addTween(t, n, s, s + a, n), this._overwriteProps.push(n)));
                return !0
            },
            set: function(t) {
                var e;
                if (1 !== t) this._super.setRatio.call(this, t);
                else
                    for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
            }
        })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(g) {
            function t(t, e) {
                var i = l("easing." + t, function() {}, !0);
                return (t = i.prototype = new g).constructor = i, t.getRatio = e, i
            }

            function e(t, e, i, n, r) {
                return n = l("easing." + t, {
                    easeOut: new e,
                    easeIn: new i,
                    easeInOut: new n
                }, !0), h(n, t), n
            }

            function v(t, e, i) {
                this.t = t, this.v = e, i && (((this.next = i).prev = this).c = i.v - e, this.gap = i.t - t)
            }
            var i, n, r = _gsScope.GreenSockGlobals || _gsScope,
                s = r.com.greensock,
                a = 2 * Math.PI,
                o = Math.PI / 2,
                l = s._class,
                h = g.register || function() {},
                c = function(t, e) {
                    var i = l("easing." + t, function(t) {
                            this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                        }, !0),
                        t = i.prototype = new g;
                    return t.constructor = i, t.getRatio = e, t.config = function(t) {
                        return new i(t)
                    }, i
                },
                s = e("Back", c("BackOut", function(t) {
                    return --t * t * ((this._p1 + 1) * t + this._p1) + 1
                }), c("BackIn", function(t) {
                    return t * t * ((this._p1 + 1) * t - this._p1)
                }), c("BackInOut", function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                })),
                u = l("easing.SlowMo", function(t, e, i) {
                    e = e || 0 === e ? e : .7, null == t ? t = .7 : 1 < t && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                }, !0),
                c = u.prototype = new g;
            return c.constructor = u, c.getRatio = function(t) {
                var e = t + (.5 - t) * this._p;
                return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
            }, u.ease = new u(.7, .7), c.config = u.config = function(t, e, i) {
                return new u(t, e, i)
            }, (c = (i = l("easing.SteppedEase", function(t) {
                t = t || 1, this._p1 = 1 / t, this._p2 = t + 1
            }, !0)).prototype = new g).constructor = i, c.getRatio = function(t) {
                return t < 0 ? t = 0 : 1 <= t && (t = .999999999), (this._p2 * t >> 0) * this._p1
            }, c.config = i.config = function(t) {
                return new i(t)
            }, (c = (n = l("easing.RoughEase", function(t) {
                for (var e, i, n, r, s, a, o = (t = t || {}).taper || "none", l = [], h = 0, c = 0 | (t.points || 20), u = c, d = !1 !== t.randomize, p = !0 === t.clamp, f = t.template instanceof g ? t.template : null, m = "number" == typeof t.strength ? .4 * t.strength : .4; - 1 < --u;) e = d ? Math.random() : 1 / c * u, i = f ? f.getRatio(e) : e, n = "none" === o ? m : "out" === o ? (r = 1 - e) * r * m : "in" === o ? e * e * m : e < .5 ? (r = 2 * e) * r * .5 * m : (r = 2 * (1 - e)) * r * .5 * m, d ? i += Math.random() * n - .5 * n : u % 2 ? i += .5 * n : i -= .5 * n, p && (1 < i ? i = 1 : i < 0 && (i = 0)), l[h++] = {
                    x: e,
                    y: i
                };
                for (l.sort(function(t, e) {
                        return t.x - e.x
                    }), a = new v(1, 1, null), u = c; - 1 < --u;) s = l[u], a = new v(s.x, s.y, a);
                this._prev = new v(0, 0, 0 !== a.t ? a : a.next)
            }, !0)).prototype = new g).constructor = n, c.getRatio = function(t) {
                var e = this._prev;
                if (t > e.t) {
                    for (; e.next && t >= e.t;) e = e.next;
                    e = e.prev
                } else
                    for (; e.prev && t <= e.t;) e = e.prev;
                return (this._prev = e).v + (t - e.t) / e.gap * e.c
            }, c.config = function(t) {
                return new n(t)
            }, n.ease = new n, e("Bounce", t("BounceOut", function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }), t("BounceIn", function(t) {
                return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
            }), t("BounceInOut", function(t) {
                var e = t < .5;
                return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
            })), e("Circ", t("CircOut", function(t) {
                return Math.sqrt(1 - --t * t)
            }), t("CircIn", function(t) {
                return -(Math.sqrt(1 - t * t) - 1)
            }), t("CircInOut", function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            })), e("Elastic", (c = function(t, e, i) {
                var n = l("easing." + t, function(t, e) {
                        this._p1 = 1 <= t ? t : 1, this._p2 = (e || i) / (t < 1 ? t : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2
                    }, !0),
                    t = n.prototype = new g;
                return t.constructor = n, t.getRatio = e, t.config = function(t, e) {
                    return new n(t, e)
                }, n
            })("ElasticOut", function(t) {
                return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
            }, .3), c("ElasticIn", function(t) {
                return -(this._p1 * Math.pow(2, 10 * --t) * Math.sin((t - this._p3) * this._p2))
            }, .3), c("ElasticInOut", function(t) {
                return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * --t) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * --t) * Math.sin((t - this._p3) * this._p2) * .5 + 1
            }, .45)), e("Expo", t("ExpoOut", function(t) {
                return 1 - Math.pow(2, -10 * t)
            }), t("ExpoIn", function(t) {
                return Math.pow(2, 10 * (t - 1)) - .001
            }), t("ExpoInOut", function(t) {
                return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            })), e("Sine", t("SineOut", function(t) {
                return Math.sin(t * o)
            }), t("SineIn", function(t) {
                return 1 - Math.cos(t * o)
            }), t("SineInOut", function(t) {
                return -.5 * (Math.cos(Math.PI * t) - 1)
            })), l("easing.EaseLookup", {
                find: function(t) {
                    return g.map[t]
                }
            }, !0), h(r.SlowMo, "SlowMo", "ease,"), h(n, "RoughEase", "ease,"), h(i, "SteppedEase", "ease,"), s
        }, !0)
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function(d) {
        "use strict";
        var p = d.GreenSockGlobals = d.GreenSockGlobals || d;
        if (!p.TweenLite) {
            var f, e, i, m = function(t) {
                    for (var e = t.split("."), i = p, n = 0; n < e.length; n++) i[e[n]] = i = i[e[n]] || {};
                    return i
                },
                u = m("com.greensock"),
                g = 1e-10,
                o = function(t) {
                    for (var e = [], i = t.length, n = 0; n !== i; e.push(t[n++]));
                    return e
                },
                v = function() {},
                _ = (e = Object.prototype.toString, i = e.call([]), function(t) {
                    return null != t && (t instanceof Array || "object" == typeof t && !!t.push && e.call(t) === i)
                }),
                y = {},
                x = function(o, l, h, c) {
                    this.sc = y[o] ? y[o].sc : [], (y[o] = this).gsClass = null, this.func = h;
                    var u = [];
                    this.check = function(t) {
                        for (var e, i, n, r, s = l.length, a = s; - 1 < --s;)(e = y[l[s]] || new x(l[s], [])).gsClass ? (u[s] = e.gsClass, a--) : t && e.sc.push(this);
                        if (0 === a && h)
                            for (r = (i = ("com.greensock." + o).split(".")).pop(), n = m(i.join("."))[r] = this.gsClass = h.apply(h, u), c && (p[r] = n, !(r = "undefined" != typeof module && module.exports) && "function" == typeof define && define.amd ? define((d.GreenSockAMDPath ? d.GreenSockAMDPath + "/" : "") + o.split(".").pop(), [], function() {
                                    return n
                                }) : "TweenMax" === o && r && (module.exports = n)), s = 0; s < this.sc.length; s++) this.sc[s].check()
                    }, this.check(!0)
                },
                n = d._gsDefine = function(t, e, i, n) {
                    return new x(t, e, i, n)
                },
                b = u._class = function(t, e, i) {
                    return e = e || function() {}, n(t, [], function() {
                        return e
                    }, i), e
                };
            n.globals = p;
            var t, r = [0, 0, 1, 1],
                s = [],
                c = b("easing.Ease", function(t, e, i, n) {
                    this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? r.concat(e) : r
                }, !0),
                w = c.map = {},
                a = c.register = function(t, e, i, n) {
                    for (var r, s, a, o, l = e.split(","), h = l.length, c = (i || "easeIn,easeOut,easeInOut").split(","); - 1 < --h;)
                        for (s = l[h], r = n ? b("easing." + s, null, !0) : u.easing[s] || {}, a = c.length; - 1 < --a;) o = c[a], w[s + "." + o] = w[o + s] = r[o] = t.getRatio ? t : t[o] || new t
                };
            for ((t = c.prototype)._calcEnd = !1, t.getRatio = function(t) {
                    if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                    var e = this._type,
                        i = this._power,
                        n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                    return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                }, h = (l = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; - 1 < --h;) t = l[h] + ",Power" + h, a(new c(null, null, 1, h), t, "easeOut", !0), a(new c(null, null, 2, h), t, "easeIn" + (0 === h ? ",easeNone" : "")), a(new c(null, null, 3, h), t, "easeInOut");
            w.linear = u.easing.Linear.easeIn, w.swing = u.easing.Quad.easeInOut;
            var T = b("events.EventDispatcher", function(t) {
                this._listeners = {}, this._eventTarget = t || this
            });
            (t = T.prototype).addEventListener = function(t, e, i, n, r) {
                r = r || 0;
                var s, a, o = this._listeners[t],
                    l = 0;
                for (null == o && (this._listeners[t] = o = []), a = o.length; - 1 < --a;)(s = o[a]).c === e && s.s === i ? o.splice(a, 1) : 0 === l && s.pr < r && (l = a + 1);
                o.splice(l, 0, {
                    c: e,
                    s: i,
                    up: n,
                    pr: r
                }), this !== C || f || C.wake()
            }, t.removeEventListener = function(t, e) {
                var i, n = this._listeners[t];
                if (n)
                    for (i = n.length; - 1 < --i;)
                        if (n[i].c === e) return void n.splice(i, 1)
            }, t.dispatchEvent = function(t) {
                var e, i, n, r = this._listeners[t];
                if (r)
                    for (e = r.length, i = this._eventTarget; - 1 < --e;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                        type: t,
                        target: i
                    }) : n.c.call(n.s || i))
            };
            for (var l, M = d.requestAnimationFrame, E = d.cancelAnimationFrame, S = Date.now || function() {
                    return (new Date).getTime()
                }, A = S(), h = (l = ["ms", "moz", "webkit", "o"]).length; - 1 < --h && !M;) M = d[l[h] + "RequestAnimationFrame"], E = d[l[h] + "CancelAnimationFrame"] || d[l[h] + "CancelRequestAnimationFrame"];
            b("Ticker", function(t, e) {
                var n, r, s, a, o, l = this,
                    h = S(),
                    i = !1 !== e && M,
                    c = 500,
                    u = 33,
                    d = function(t) {
                        var e, i = S() - A;
                        c < i && (h += i - u), A += i, l.time = (A - h) / 1e3, i = l.time - o, (!n || 0 < i || !0 === t) && (l.frame++, o += i + (a <= i ? .004 : a - i), e = !0), !0 !== t && (s = r(d)), e && l.dispatchEvent("tick")
                    };
                T.call(l), l.time = l.frame = 0, l.tick = function() {
                    d(!0)
                }, l.lagSmoothing = function(t, e) {
                    c = t || 1e10, u = Math.min(e, c, 0)
                }, l.sleep = function() {
                    null != s && ((i && E ? E : clearTimeout)(s), r = v, s = null, l === C && (f = !1))
                }, l.wake = function() {
                    null !== s ? l.sleep() : 10 < l.frame && (A = S() - c + 5), r = 0 === n ? v : i && M ? M : function(t) {
                        return setTimeout(t, 1e3 * (o - l.time) + 1 | 0)
                    }, l === C && (f = !0), d(2)
                }, l.fps = function(t) {
                    if (!arguments.length) return n;
                    a = 1 / ((n = t) || 60), o = this.time + a, l.wake()
                }, l.useRAF = function(t) {
                    if (!arguments.length) return i;
                    l.sleep(), i = t, l.fps(n)
                }, l.fps(t), setTimeout(function() {
                    i && l.frame < 5 && l.useRAF(!1)
                }, 1500)
            }), (t = u.Ticker.prototype = new u.events.EventDispatcher).constructor = u.Ticker;
            var P = b("core.Animation", function(t, e) {
                    this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, q && (f || C.wake(), (e = this.vars.useFrames ? X : q).add(this, e._time), this.vars.paused && this.paused(!0))
                }),
                C = P.ticker = new u.Ticker;
            (t = P.prototype)._dirty = t._gc = t._initted = t._paused = !1, t._totalTime = t._time = 0, t._rawPrevTime = -1, t._next = t._last = t._onUpdate = t._timeline = t.timeline = null, t._paused = !1;
            var R = function() {
                f && 2e3 < S() - A && C.wake(), setTimeout(R, 2e3)
            };
            R(), t.play = function(t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, t.pause = function(t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, t.resume = function(t, e) {
                return null != t && this.seek(t, e), this.paused(!1)
            }, t.seek = function(t, e) {
                return this.totalTime(Number(t), !1 !== e)
            }, t.restart = function(t, e) {
                return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
            }, t.reverse = function(t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, t.render = function(t, e, i) {}, t.invalidate = function() {
                return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
            }, t.isActive = function() {
                var t, e = this._timeline,
                    i = this._startTime;
                return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime()) >= i && t < i + this.totalDuration() / this._timeScale
            }, t._enabled = function(t, e) {
                return f || C.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
            }, t._kill = function(t, e) {
                return this._enabled(!1, !1)
            }, t.kill = function(t, e) {
                return this._kill(t, e), this
            }, t._uncache = function(t) {
                for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                return this
            }, t._swapSelfInParams = function(t) {
                for (var e = t.length, i = t.concat(); - 1 < --e;) "{self}" === t[e] && (i[e] = this);
                return i
            }, t._callback = function(t) {
                var e = this.vars;
                e[t].apply(e[t + "Scope"] || e.callbackScope || this, e[t + "Params"] || s)
            }, t.eventCallback = function(t, e, i, n) {
                if ("on" === (t || "").substr(0, 2)) {
                    var r = this.vars;
                    if (1 === arguments.length) return r[t];
                    null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = _(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                }
                return this
            }, t.delay = function(t) {
                return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
            }, t.duration = function(t) {
                return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && 0 < this._time && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
            }, t.totalDuration = function(t) {
                return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
            }, t.time = function(t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
            }, t.totalTime = function(t, e, i) {
                if (f || C.wake(), !arguments.length) return this._totalTime;
                if (this._timeline) {
                    if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                        this._dirty && this.totalDuration();
                        var n = this._totalDuration,
                            r = this._timeline;
                        if (n < t && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                            for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                    }
                    this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (k.length && Z(), this.render(t, e, !1), k.length && Z())
                }
                return this
            }, t.progress = t.totalProgress = function(t, e) {
                var i = this.duration();
                return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
            }, t.startTime = function(t) {
                return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
            }, t.endTime = function(t) {
                return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
            }, t.timeScale = function(t) {
                return arguments.length ? (t = t || g, this._timeline && this._timeline.smoothChildTiming && (e = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = e - (e - this._startTime) * this._timeScale / t), this._timeScale = t, this._uncache(!1)) : this._timeScale;
                var e
            }, t.reversed = function(t) {
                return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
            }, t.paused = function(t) {
                if (!arguments.length) return this._paused;
                var e, i, n = this._timeline;
                return t != this._paused && n && (f || t || C.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 != i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
            };
            var L = b("core.SimpleTimeline", function(t) {
                P.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            (t = L.prototype = new P).constructor = L, t.kill()._gc = !1, t._first = t._last = t._recent = null, t._sortChildren = !1, t.add = t.insert = function(t, e, i, n) {
                var r, s;
                if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                    for (s = t._startTime; r && r._startTime > s;) r = r._prev;
                return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
            }, t._remove = function(t, e) {
                return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
            }, t.render = function(t, e, i) {
                var n, r = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
            }, t.rawTime = function() {
                return f || C.wake(), this._totalTime
            };
            var O = b("TweenLite", function(t, e, i) {
                    if (P.call(this, e, i), this.render = O.prototype.render, null == t) throw "Cannot tween a null target.";
                    this.target = t = "string" == typeof t && O.selector(t) || t;
                    var n, r, s, i = t.jquery || t.length && t !== d && t[0] && (t[0] === d || t[0].nodeType && t[0].style && !t.nodeType),
                        a = this.vars.overwrite;
                    if (this._overwrite = a = null == a ? W[O.defaultOverwrite] : "number" == typeof a ? a >> 0 : W[a], (i || t instanceof Array || t.push && _(t)) && "number" != typeof t[0])
                        for (this._targets = s = o(t), this._propLookup = [], this._siblings = [], n = 0; n < s.length; n++)(r = s[n]) ? "string" != typeof r ? r.length && r !== d && r[0] && (r[0] === d || r[0].nodeType && r[0].style && !r.nodeType) ? (s.splice(n--, 1), this._targets = s = s.concat(o(r))) : (this._siblings[n] = J(r, this, !1), 1 === a && 1 < this._siblings[n].length && K(r, this, null, 1, this._siblings[n])) : "string" == typeof(r = s[n--] = O.selector(r)) && s.splice(n + 1, 1) : s.splice(n--, 1);
                    else this._propLookup = {}, this._siblings = J(t, this, !1), 1 === a && 1 < this._siblings.length && K(t, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -g, this.render(-this._delay))
                }, !0),
                D = function(t) {
                    return t && t.length && t !== d && t[0] && (t[0] === d || t[0].nodeType && t[0].style && !t.nodeType)
                };
            (t = O.prototype = new P).constructor = O, t.kill()._gc = !1, t.ratio = 0, t._firstPT = t._targets = t._overwrittenProps = t._startAt = null, t._notifyPluginsOfEnabled = t._lazy = !1, O.version = "1.18.0", O.defaultEase = t._ease = new c(null, null, 1, 1), O.defaultOverwrite = "auto", O.ticker = C, O.autoSleep = 120, O.lagSmoothing = function(t, e) {
                C.lagSmoothing(t, e)
            }, O.selector = d.$ || d.jQuery || function(t) {
                var e = d.$ || d.jQuery;
                return e ? (O.selector = e)(t) : "undefined" == typeof document ? t : document.querySelectorAll ? document.querySelectorAll(t) : document.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
            };
            var k = [],
                I = {},
                N = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                z = function(t) {
                    for (var e, i = this._firstPT; i;) e = i.blob ? t ? this.join("") : this.start : i.c * t + i.s, i.r ? e = Math.round(e) : e < 1e-6 && -1e-6 < e && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                },
                B = function(t, e, i, n) {
                    var r, s, a, o, l, h, c = [t, e],
                        u = 0,
                        d = "",
                        p = 0;
                    for (c.start = t, i && (i(c), t = c[0], e = c[1]), c.length = 0, r = t.match(N) || [], s = e.match(N) || [], n && (n._next = null, n.blob = 1, c._firstPT = n), o = s.length, a = 0; a < o; a++) h = s[a], d += (l = e.substr(u, e.indexOf(h, u) - u)) || !a ? l : ",", u += l.length, p ? p = (p + 1) % 5 : "rgba(" === l.substr(-5) && (p = 1), h === r[a] || r.length <= a ? d += h : (d && (c.push(d), d = ""), l = parseFloat(r[a]), c.push(l), c._firstPT = {
                        _next: c._firstPT,
                        t: c,
                        p: c.length - 1,
                        s: l,
                        c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - l) || 0,
                        f: 0,
                        r: p && p < 4
                    }), u += h.length;
                    return (d += e.substr(u)) && c.push(d), c.setRatio = z, c
                },
                U = function(t, e, i, n, r, s, a, o) {
                    var l = "get" === i ? t[e] : i,
                        h = typeof t[e],
                        c = "string" == typeof n && "=" === n.charAt(1),
                        s = {
                            t: t,
                            p: e,
                            s: l,
                            f: "function" == h,
                            pg: 0,
                            n: r || e,
                            r: s,
                            pr: 0,
                            c: c ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - l || 0
                        };
                    if ("number" != h && ("function" == h && "get" === i && (i = e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3), s.s = l = a ? t[i](a) : t[i]()), "string" == typeof l && (a || isNaN(l)) ? (s.fp = a, s = {
                            t: B(l, n, o || O.defaultStringFilter, s),
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 2,
                            pg: 0,
                            n: r || e,
                            pr: 0
                        }) : c || (s.c = parseFloat(n) - parseFloat(l) || 0)), s.c) return (s._next = this._firstPT) && (s._next._prev = s), this._firstPT = s
                },
                F = O._internals = {
                    isArray: _,
                    isSelector: D,
                    lazyTweens: k,
                    blobDif: B
                },
                H = O._plugins = {},
                G = F.tweenLookup = {},
                V = 0,
                j = F.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1,
                    stringFilter: 1
                },
                W = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    true: 1,
                    false: 0
                },
                X = P._rootFramesTimeline = new L,
                q = P._rootTimeline = new L,
                Y = 30,
                Z = F.lazyRender = function() {
                    var t, e = k.length;
                    for (I = {}; - 1 < --e;)(t = k[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                    k.length = 0
                };
            q._startTime = C.time, X._startTime = C.frame, q._active = X._active = !0, setTimeout(Z, 1), P._updateRoot = O.render = function() {
                var t, e, i;
                if (k.length && Z(), q.render((C.time - q._startTime) * q._timeScale, !1, !1), X.render((C.frame - X._startTime) * X._timeScale, !1, !1), k.length && Z(), C.frame >= Y) {
                    for (i in Y = C.frame + (parseInt(O.autoSleep, 10) || 120), G) {
                        for (t = (e = G[i].tweens).length; - 1 < --t;) e[t]._gc && e.splice(t, 1);
                        0 === e.length && delete G[i]
                    }
                    if (i = q._first, (!i || i._paused) && O.autoSleep && !X._first && 1 === C._listeners.tick.length) {
                        for (; i && i._paused;) i = i._next;
                        i || C.sleep()
                    }
                }
            }, C.addEventListener("tick", P._updateRoot);
            var J = function(t, e, i) {
                    var n, r, s = t._gsTweenID;
                    if (G[s || (t._gsTweenID = s = "t" + V++)] || (G[s] = {
                            target: t,
                            tweens: []
                        }), e && ((n = G[s].tweens)[r = n.length] = e, i))
                        for (; - 1 < --r;) n[r] === e && n.splice(r, 1);
                    return G[s].tweens
                },
                Q = function(t, e, i, n) {
                    var r, s, a = t.vars.onOverwrite;
                    return a && (r = a(t, e, i, n)), (a = O.onOverwrite) && (s = a(t, e, i, n)), !1 !== r && !1 !== s
                },
                K = function(t, e, i, n, r) {
                    var s, a, o;
                    if (1 === n || 4 <= n) {
                        for (o = r.length, p = 0; p < o; p++)
                            if ((a = r[p]) !== e) a._gc || a._kill(null, t, e) && (s = !0);
                            else if (5 === n) break;
                        return s
                    }
                    for (var l, h = e._startTime + g, c = [], u = 0, d = 0 === e._duration, p = r.length; - 1 < --p;)(a = r[p]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (l = l || $(e, 0, d), 0 === $(a, l, d) && (c[u++] = a)) : a._startTime <= h && a._startTime + a.totalDuration() / a._timeScale > h && ((d || !a._initted) && h - a._startTime <= 2e-10 || (c[u++] = a)));
                    for (p = u; - 1 < --p;) a = c[p], 2 === n && a._kill(i, t, e) && (s = !0), (2 !== n || !a._firstPT && a._initted) && (2 === n || Q(a, e)) && a._enabled(!1, !1) && (s = !0);
                    return s
                },
                $ = function(t, e, i) {
                    for (var n = t._timeline, r = n._timeScale, s = t._startTime; n._timeline;) {
                        if (s += n._startTime, r *= n._timeScale, n._paused) return -100;
                        n = n._timeline
                    }
                    return e < (s /= r) ? s - e : i && s === e || !t._initted && s - e < 2 * g ? g : (s += t.totalDuration() / t._timeScale / r) > e + g ? 0 : s - e - g
                };
            t._init = function() {
                var t, e, i, n, r, s = this.vars,
                    a = this._overwrittenProps,
                    o = this._duration,
                    l = !!s.immediateRender,
                    h = s.ease;
                if (s.startAt) {
                    for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, s.startAt) r[n] = s.startAt[n];
                    if (r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== s.lazy, r.startAt = r.delay = null, this._startAt = O.to(this.target, 0, r), l)
                        if (0 < this._time) this._startAt = null;
                        else if (0 !== o) return
                } else if (s.runBackwards && 0 !== o)
                    if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                    else {
                        for (n in 0 !== this._time && (l = !1), i = {}, s) j[n] && "autoCSS" !== n || (i[n] = s[n]);
                        if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && !1 !== s.lazy, i.immediateRender = l, this._startAt = O.to(this.target, 0, i), l) {
                            if (0 === this._time) return
                        } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                    }
                if (this._ease = h = h ? h instanceof c ? h : "function" == typeof h ? new c(h, s.easeParams) : w[h] || O.defaultEase : O.defaultEase, s.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                    for (t = this._targets.length; - 1 < --t;) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null) && (e = !0);
                else e = this._initProps(this.target, this._propLookup, this._siblings, a);
                if (e && O._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards)
                    for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                this._onUpdate = s.onUpdate, this._initted = !0
            }, t._initProps = function(t, e, i, n) {
                var r, s, a, o, l, h;
                if (null == t) return !1;
                for (r in I[t._gsTweenID] && Z(), this.vars.css || t.style && t !== d && t.nodeType && H.css && !1 !== this.vars.autoCSS && function(t, e) {
                        var i, n = {};
                        for (i in t) j[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!H[i] || H[i] && H[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                        t.css = n
                    }(this.vars, t), this.vars)
                    if (h = this.vars[r], j[r]) h && (h instanceof Array || h.push && _(h)) && -1 !== h.join("").indexOf("{self}") && (this.vars[r] = h = this._swapSelfInParams(h, this));
                    else if (H[r] && (o = new H[r])._onInitTween(t, this.vars[r], this)) {
                    for (this._firstPT = l = {
                            _next: this._firstPT,
                            t: o,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 1,
                            n: r,
                            pg: 1,
                            pr: o._priority
                        }, s = o._overwriteProps.length; - 1 < --s;) e[o._overwriteProps[s]] = this._firstPT;
                    (o._priority || o._onInitAllProps) && (a = !0), (o._onDisable || o._onEnable) && (this._notifyPluginsOfEnabled = !0), l._next && (l._next._prev = l)
                } else e[r] = U.call(this, t, r, "get", h, r, 0, null, this.vars.stringFilter);
                return n && this._kill(n, t) ? this._initProps(t, e, i, n) : 1 < this._overwrite && this._firstPT && 1 < i.length && K(t, this, e, this._overwrite, i) ? (this._kill(e, t), this._initProps(t, e, i, n)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (I[t._gsTweenID] = !0), a)
            }, t.render = function(t, e, i) {
                var n, r, s, a, o, l, h, c = this._time,
                    u = this._duration,
                    d = this._rawPrevTime;
                if (u <= t ? (this._totalTime = this._time = u, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === u && (!this._initted && this.vars.lazy && !i || (this._startTime === this._timeline._duration && (t = 0), (0 === t || d < 0 || d === g && "isPause" !== this.data) && d !== t && (i = !0, g < d && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || d === t ? t : g))) : t < 1e-7 ? (this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== c || 0 === u && 0 < d) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === u && (!this._initted && this.vars.lazy && !i || (0 <= d && (d !== g || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || d === t ? t : g))), this._initted || (i = !0)) : (this._totalTime = this._time = t, this._easeType ? (o = t / u, (1 === (l = this._easeType) || 3 === l && .5 <= o) && (o = 1 - o), 3 === l && (o *= 2), 1 === (h = this._easePower) ? o *= o : 2 === h ? o *= o * o : 3 === h ? o *= o * o * o : 4 === h && (o *= o * o * o * o), this.ratio = 1 === l ? 1 - o : 2 === l ? o : t / u < .5 ? o / 2 : 1 - o / 2) : this.ratio = this._ease.getRatio(t / u)), this._time !== c || i) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = c, this._rawPrevTime = d, k.push(this), void(this._lazy = [t, e]);
                        this._time && !n ? this.ratio = this._ease.getRatio(this._time / u) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== c && 0 <= t && (this._active = !0), 0 === c && (this._startAt && (0 <= t ? this._startAt.render(t, e, i) : r = r || "_dummyGS"), this.vars.onStart && (0 === this._time && 0 !== u || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                    this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, e, i), e || this._time === c && !n || this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, e, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === u && this._rawPrevTime === g && a !== g && (this._rawPrevTime = 0)))
                }
            }, t._kill = function(t, e, i) {
                if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                e = "string" != typeof e ? e || this._targets || this.target : O.selector(e) || e;
                var n, r, s, a, o, l, h, c, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                if ((_(e) || D(e)) && "number" != typeof e[0])
                    for (n = e.length; - 1 < --n;) this._kill(t, e[n], i) && (l = !0);
                else {
                    if (this._targets) {
                        for (n = this._targets.length; - 1 < --n;)
                            if (e === this._targets[n]) {
                                o = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                break
                            }
                    } else {
                        if (e !== this.target) return !1;
                        o = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                    }
                    if (o) {
                        if (h = t || o, c = t !== r && "all" !== r && t !== o && ("object" != typeof t || !t._tempKill), i && (O.onOverwrite || this.vars.onOverwrite)) {
                            for (s in h) o[s] && (u = u || []).push(s);
                            if ((u || !t) && !Q(this, i, e, u)) return !1
                        }
                        for (s in h)(a = o[s]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(h) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete o[s]), c && (r[s] = 1);
                        !this._firstPT && this._initted && this._enabled(!1, !1)
                    }
                }
                return l
            }, t.invalidate = function() {
                return this._notifyPluginsOfEnabled && O._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], P.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -g, this.render(-this._delay)), this
            }, t._enabled = function(t, e) {
                if (f || C.wake(), t && this._gc) {
                    var i, n = this._targets;
                    if (n)
                        for (i = n.length; - 1 < --i;) this._siblings[i] = J(n[i], this, !0);
                    else this._siblings = J(this.target, this, !0)
                }
                return P.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && O._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
            }, O.to = function(t, e, i) {
                return new O(t, e, i)
            }, O.from = function(t, e, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new O(t, e, i)
            }, O.fromTo = function(t, e, i, n) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new O(t, e, n)
            }, O.delayedCall = function(t, e, i, n, r) {
                return new O(e, 0, {
                    delay: t,
                    onComplete: e,
                    onCompleteParams: i,
                    callbackScope: n,
                    onReverseComplete: e,
                    onReverseCompleteParams: i,
                    immediateRender: !1,
                    lazy: !1,
                    useFrames: r,
                    overwrite: 0
                })
            }, O.set = function(t, e) {
                return new O(t, 0, e)
            }, O.getTweensOf = function(t, e) {
                if (null == t) return [];
                var i, n, r, s;
                if (t = "string" == typeof t && O.selector(t) || t, (_(t) || D(t)) && "number" != typeof t[0]) {
                    for (i = t.length, n = []; - 1 < --i;) n = n.concat(O.getTweensOf(t[i], e));
                    for (i = n.length; - 1 < --i;)
                        for (s = n[i], r = i; - 1 < --r;) s === n[r] && n.splice(i, 1)
                } else
                    for (i = (n = J(t).concat()).length; - 1 < --i;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                return n
            }, O.killTweensOf = O.killDelayedCallsTo = function(t, e, i) {
                "object" == typeof e && (i = e, e = !1);
                for (var n = O.getTweensOf(t, e), r = n.length; - 1 < --r;) n[r]._kill(i, t)
            };
            var tt = b("plugins.TweenPlugin", function(t, e) {
                this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = tt.prototype
            }, !0);
            if (t = tt.prototype, tt.version = "1.18.0", tt.API = 2, t._firstPT = null, t._addTween = U, t.setRatio = z, t._kill = function(t) {
                    var e, i = this._overwriteProps,
                        n = this._firstPT;
                    if (null != t[this._propName]) this._overwriteProps = [];
                    else
                        for (e = i.length; - 1 < --e;) null != t[i[e]] && i.splice(e, 1);
                    for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                    return !1
                }, t._roundProps = function(t, e) {
                    for (var i = this._firstPT; i;)(t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next
                }, O._onPluginEvent = function(t, e) {
                    var i, n, r, s, a, o = e._firstPT;
                    if ("_onInitAllProps" === t) {
                        for (; o;) {
                            for (a = o._next, n = r; n && n.pr > o.pr;) n = n._next;
                            (o._prev = n ? n._prev : s) ? o._prev._next = o: r = o, (o._next = n) ? n._prev = o : s = o, o = a
                        }
                        o = e._firstPT = r
                    }
                    for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;
                    return i
                }, tt.activate = function(t) {
                    for (var e = t.length; - 1 < --e;) t[e].API === tt.API && (H[(new t[e])._propName] = t[e]);
                    return !0
                }, n.plugin = function(t) {
                    if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                    var e, i = t.propName,
                        n = t.priority || 0,
                        r = t.overwriteProps,
                        s = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_roundProps",
                            initAll: "_onInitAllProps"
                        },
                        a = b("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                            tt.call(this, i, n), this._overwriteProps = r || []
                        }, !0 === t.global),
                        o = a.prototype = new tt(i);
                    for (e in (o.constructor = a).API = t.API, s) "function" == typeof t[e] && (o[s[e]] = t[e]);
                    return a.version = t.version, tt.activate([a]), a
                }, l = d._gsQueue) {
                for (h = 0; h < l.length; h++) l[h]();
                for (t in y) y[t].func || d.console.log("GSAP encountered missing dependency: com.greensock." + t)
            }
            f = !1
        }
    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window), define("TweenMax", function() {}), define("helpers", ["dispatcher", "bezier", "TweenMax"], function(t, e, i) {
        "use strict";
        i._easings = {
            strong: e(.845, .005, .175, .995),
            medium: e(.55, .005, .205, 1),
            basic: e(.25, .1, .25, 1)
        }, (e = Element.prototype).matches = e.matches || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector || e.webkitMatchesSelector, e.closest = e.closest || function(t) {
            return this ? this.matches(t) ? this : this.parentElement ? this.parentElement.closest(t) : null : null
        }
    }), define("domReady", [], function() {
        "use strict";
        var t, e, i, n, r = "undefined" != typeof window && window.document,
            s = !r,
            a = r ? document : null,
            o = [],
            n = (n = 999, -1 != navigator.appVersion.indexOf("MSIE") && (n = parseFloat(navigator.appVersion.split("MSIE")[1])), n);

        function l() {
            var t = o;
            s && t.length && (o = [], function(t) {
                for (var e = 0; e < t.length; e += 1) t[e](a)
            }(t))
        }

        function h() {
            s || (s = !0, i && clearInterval(i), l())
        }
        if (r) {
            if (document.addEventListener) document.addEventListener("DOMContentLoaded", h, !1), window.addEventListener("load", h, !1);
            else if (window.attachEvent) {
                window.attachEvent("onload", h), e = document.createElement("div");
                try {
                    t = null === window.frameElement
                } catch (t) {}
                e.doScroll && t && window.external && (i = setInterval(function() {
                    try {
                        e.doScroll(), h()
                    } catch (t) {}
                }, 30))
            }
            9 < n ? "complete" !== document.readyState && "interactive" !== document.readyState || h() : "complete" === document.readyState && h()
        }

        function c(t) {
            return s ? t(a) : o.push(t), c
        }
        return c.version = "2.0.1", c.load = function(t, e, i, n) {
            n.isBuild ? i(null) : c(i)
        }, c
    }), define("config", ["dispatcher"], function(t) {
        "use strict";
        var e, i;
        return {
            dev: 0,
            maxDPR: (i = !1, e = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))) && (i = !0), i) ? 2 : 1.5
        }
    }), define("page-load/page-load.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            "page-load:load" === t.type && (r = !0, n.dispatch()), "page-load:reset" === t.type && (r = !1, n.dispatch())
        }
        var n = new e,
            r = !1;
        return t.subscribe("page-load", i), {
            subscribe: n.subscribe.bind(n),
            unsubscribe: n.unsubscribe.bind(n),
            getData: function() {
                return {
                    loaded: r
                }
            }
        }
    }), define("page-load/preloader-simple.view", ["dispatcher", "config", "page-load/page-load.store"], function(i, n, e) {
        "use strict";

        function t() {
            var t = e.getData();
            r !== t.loaded && (r = t.loaded, t = document.getElementsByClassName("page-wrapper")[0], r ? (t.classList.add("load-complete"), t.classList.add("load-complete-once")) : t.classList.remove("load-complete"))
        }
        var r = !1;
        return {
            init: function() {
                e.subscribe(t), setTimeout(function() {
                    var t = document.getElementsByClassName("preloader-full")[0],
                        e = document.getElementById("init-preloader");
                    t && !n.dev || (e && (e.classList.remove("start"), e.classList.add("end"), setTimeout(function() {
                        e.parentNode.removeChild(e)
                    }, 1e3)), i.dispatch({
                        type: "page-load:load"
                    }), i.dispatch({
                        type: "stage:show"
                    }), Modernizr.mobile || i.dispatch({
                        type: "audio:play"
                    }))
                }, 0)
            }
        }
    }), define("page-helper/page-helper.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            "page-helper:set" === t.type && t.name !== r && (r = t.name, n.dispatch())
        }
        var n = new e,
            r = null;
        return t.subscribe("page-helper", i), {
            subscribe: n.subscribe.bind(n),
            unsubscribe: n.unsubscribe.bind(n),
            getData: function() {
                return {
                    type: r
                }
            }
        }
    }), define("page-helper/page-helper.view", ["dispatcher", "page-helper/page-helper.store"], function(e, t) {
        "use strict";

        function i() {
            var t = document.getElementsByTagName("page-helper")[0].getAttribute("data-type");
            e.dispatch({
                type: "page-helper:set",
                name: t
            })
        }

        function n(t) {
            "content:replaced" === t.type && i()
        }
        return {
            init: function() {
                i(), e.subscribe(n)
            }
        }
    }), define("slide-scroll/slide-scroll.store", ["dispatcher", "utils/EventEmitter", "page-load/page-load.store"], function(t, e, n) {
        "use strict";

        function i(t) {
            var e = !1,
                i = n.getData().loaded;
            if ("slide-scroll:add" === t.type) {
                if (s.hasOwnProperty(t.id)) return;
                u = t.id, s[t.id] = {
                    id: t.id,
                    index: t.index,
                    total: t.total,
                    active: !1,
                    shift: t.shift || 0
                }, r.dispatch()
            }
            if ("slide-scroll:remove" === t.type) {
                if (!s.hasOwnProperty(t.id)) return;
                delete s[t.id]
            }
            if ("slide-scroll:set-props" === t.type && (t.hasOwnProperty("speed") && (o = t.speed), t.hasOwnProperty("block") && (a = t.block), t.hasOwnProperty("delay") && (l = t.delay)), "slide-scroll:reset-props" === t.type && (o = p.animationSpeed, a = p.timeForBlocking, l = p.appearDelay), "slide-scroll:reset-props-after" === t.type && (h = !0), "slide-scroll:direction" === t.type) {
                if (!s.hasOwnProperty(t.id)) return;
                if (!i) return;
                if (d) return;
                if ("up" === t.direction) {
                    if (0 === s[t.id].index) return;
                    s[t.id].index--
                }
                if ("down" === t.direction) {
                    if (s[t.id].index === s[t.id].total - 1) return;
                    s[t.id].index++
                }
                t.hasOwnProperty("native") && (c = t.native), t.setFocus && (s[t.id].setFocus = !0), e = d = !0, r.dispatch(), c = !1, s[t.id].setFocus = !1
            }
            if ("slide-scroll:to" === t.type) {
                if (d) return;
                if (!i) return;
                if (!s.hasOwnProperty(t.id)) return;
                if (s[t.id].index === t.index) return;
                if (t.index < 0) {
                    if (0 === s[t.id].index) return;
                    s[t.id].index = 0
                } else if (t.index > s[t.id].total - 1) {
                    if (s[t.id].index === s[t.id].total - 1) return;
                    s[t.id].index = s[t.id].total - 1
                } else s[t.id].index = t.index;
                t.hasOwnProperty("native") && (c = t.native), t.setFocus && (s[t.id].setFocus = !0), e = d = !0, r.dispatch(), c = !1, s[t.id].setFocus = !1
            }
            if ("slide-scroll:enable" === t.type) {
                if (s[t.id].active) return;
                s[t.id].active = !0, r.dispatch()
            }
            if ("slide-scroll:disable" === t.type) {
                if (!s[t.id].active) return;
                s[t.id].active = !0, r.dispatch()
            }
            e && setTimeout(function() {
                setTimeout(function() {
                    d = !1, h && (o = p.animationSpeed, a = p.timeForBlocking, l = p.appearDelay, h = !1)
                }, a)
            }, 0)
        }
        var r = new e,
            s = {},
            a = 700,
            o = 700,
            l = 0,
            h = !1,
            c = !1,
            u = "",
            d = !1,
            p = {
                timeForBlocking: a,
                animationSpeed: o,
                appearDelay: l
            };
        return t.subscribe(i), {
            subscribe: r.subscribe.bind(r),
            unsubscribe: r.unsubscribe.bind(r),
            getData: function() {
                return {
                    items: s,
                    timeForBlocking: a,
                    animationSpeed: o,
                    appearDelay: l,
                    nativeScroll: c,
                    lastAdded: u,
                    isBlocked: d
                }
            }
        }
    }), define("trigger/slide-trigger.view", ["dispatcher", "page-load/page-load.store", "slide-scroll/slide-scroll.store"], function(t, e, i) {
        "use strict";

        function n() {
            var n, t = i.getData().items["main-scroll"];
            t && (n = t.index, t.active ? Array.prototype.forEach.call(s, function(t) {
                var e, i;
                (e = t)._slideIndex ? i = e._slideIndex : (t = e.closest(".s-slide"), i = Array.prototype.indexOf.call(a, t), e._slideIndex = i), e.hasOwnProperty("_triggered") || (e._triggered = !1), e._slideIndex === n ? (e.classList.remove("hidden"), e._triggered || e.trigger && e.trigger()) : (e.classList.add("hidden"), e._triggered && e.untrigger && e.untrigger())
            }) : Array.prototype.forEach.call(s, function(t) {
                t.trigger && t.trigger(0)
            }))
        }

        function r(t) {
            "content:replaced" === t.type && (s = document.getElementsByClassName("slide-trigger"), a = document.getElementsByClassName("s-slide"), n())
        }
        var s, a;
        return {
            init: function() {
                s = document.getElementsByClassName("slide-trigger"), a = document.getElementsByClassName("s-slide"), n(), i.subscribe(n), t.subscribe(r), e.subscribe(n)
            }
        }
    }), define("events/keyboard.view", ["dispatcher"], function(i) {
        "use strict";

        function t(t) {
            var e = t.which;
            i.dispatch({
                type: "keyboard:any"
            }), 9 === e ? i.dispatch({
                type: "keyboard:tab",
                event: t
            }) : 17 === e ? i.dispatch({
                type: "keyboard:ctrl",
                event: t
            }) : 27 === e ? i.dispatch({
                type: "keyboard:esc",
                event: t
            }) : 38 === e || 33 === e ? i.dispatch({
                type: "keyboard:up",
                event: t
            }) : 40 === e || 34 === e ? i.dispatch({
                type: "keyboard:down",
                event: t
            }) : 37 === e ? i.dispatch({
                type: "keyboard:left",
                event: t
            }) : 39 === e && i.dispatch({
                type: "keyboard:right",
                event: t
            })
        }

        function e() {
            i.dispatch({
                type: "keyboard:keyup"
            })
        }
        document.addEventListener("keydown", t), document.addEventListener("keyup", e)
    }), define("accessibility/outliner.view", [], function() {
        "use strict";

        function t() {
            n || (n = !0, i.innerHTML = "* {outline:none}")
        }

        function e() {
            n && (n = !1, i.innerHTML = "")
        }
        var i, n = !1;
        i = document.createElement("style"), document.head.appendChild(i), t(), document.addEventListener("mousedown", t), document.addEventListener("touchstart", t), document.addEventListener("keydown", e)
    }), define("touch/touch.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";
        var e = new e,
            i = !1;
        return {
            eventEmitter: e,
            getData: function() {
                return {
                    touch: i
                }
            }
        }
    }),
    function() {
        "use strict";

        function a(r, t) {
            var e;
            if (t = t || {}, this.trackingClick = !1, this.trackingClickStart = 0, this.targetElement = null, this.touchStartX = 0, this.touchStartY = 0, this.lastTouchIdentifier = 0, this.touchBoundary = t.touchBoundary || 10, this.layer = r, this.tapDelay = t.tapDelay || 200, !a.notNeeded(r)) {
                for (var i = ["onMouse", "onClick", "onTouchStart", "onTouchMove", "onTouchEnd", "onTouchCancel"], n = 0, s = i.length; n < s; n++) this[i[n]] = function(t, e) {
                    return function() {
                        return t.apply(e, arguments)
                    }
                }(this[i[n]], this);
                o && (r.addEventListener("mouseover", this.onMouse, !0), r.addEventListener("mousedown", this.onMouse, !0), r.addEventListener("mouseup", this.onMouse, !0)), r.addEventListener("click", this.onClick, !0), r.addEventListener("touchstart", this.onTouchStart, !1), r.addEventListener("touchmove", this.onTouchMove, !1), r.addEventListener("touchend", this.onTouchEnd, !1), r.addEventListener("touchcancel", this.onTouchCancel, !1), Event.prototype.stopImmediatePropagation || (r.removeEventListener = function(t, e, i) {
                    var n = Node.prototype.removeEventListener;
                    "click" === t ? n.call(r, t, e.hijacked || e, i) : n.call(r, t, e, i)
                }, r.addEventListener = function(t, e, i) {
                    var n = Node.prototype.addEventListener;
                    "click" === t ? n.call(r, t, e.hijacked || (e.hijacked = function(t) {
                        t.propagationStopped || e(t)
                    }), i) : n.call(r, t, e, i)
                }), "function" == typeof r.onclick && (e = r.onclick, r.addEventListener("click", function(t) {
                    e(t)
                }, !1), r.onclick = null)
            }
        }
        var o = 0 < navigator.userAgent.indexOf("Android"),
            l = /iP(ad|hone|od)/.test(navigator.userAgent),
            h = l && /OS 4_\d(_\d)?/.test(navigator.userAgent),
            c = l && /OS ([6-9]|\d{2})_\d/.test(navigator.userAgent),
            n = 0 < navigator.userAgent.indexOf("BB10");
        a.prototype.needsClick = function(t) {
            switch (t.nodeName.toLowerCase()) {
                case "button":
                case "select":
                case "textarea":
                    if (t.disabled) return !0;
                    break;
                case "input":
                    if (l && "file" === t.type || t.disabled) return !0;
                    break;
                case "label":
                case "iframe":
                case "video":
                    return !0
            }
            return /\bneedsclick\b/.test(t.className)
        }, a.prototype.needsFocus = function(t) {
            switch (t.nodeName.toLowerCase()) {
                case "textarea":
                    return !0;
                case "select":
                    return !o;
                case "input":
                    switch (t.type) {
                        case "button":
                        case "checkbox":
                        case "file":
                        case "image":
                        case "radio":
                        case "submit":
                            return !1
                    }
                    return !t.disabled && !t.readOnly;
                default:
                    return /\bneedsfocus\b/.test(t.className)
            }
        }, a.prototype.sendClick = function(t, e) {
            var i;
            document.activeElement && document.activeElement !== t && document.activeElement.blur(), i = e.changedTouches[0], (e = document.createEvent("MouseEvents")).initMouseEvent(this.determineEventType(t), !0, !0, window, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), e.forwardedTouchEvent = !0, t.dispatchEvent(e)
        }, a.prototype.determineEventType = function(t) {
            return o && "select" === t.tagName.toLowerCase() ? "mousedown" : "click"
        }, a.prototype.focus = function(t) {
            var e;
            l && t.setSelectionRange && 0 !== t.type.indexOf("date") && "time" !== t.type && "month" !== t.type ? (e = t.value.length, t.setSelectionRange(e, e)) : t.focus()
        }, a.prototype.updateScrollParent = function(t) {
            var e, i = t.fastClickScrollParent;
            if (!i || !i.contains(t)) {
                e = t;
                do {
                    if (e.scrollHeight > e.offsetHeight) {
                        i = e, t.fastClickScrollParent = e;
                        break
                    }
                } while (e = e.parentElement)
            }
            i && (i.fastClickLastScrollTop = i.scrollTop)
        }, a.prototype.getTargetElementFromEventTarget = function(t) {
            return t.nodeType === Node.TEXT_NODE ? t.parentNode : t
        }, a.prototype.onTouchStart = function(t) {
            var e, i, n;
            if (1 < t.targetTouches.length) return !0;
            if (e = this.getTargetElementFromEventTarget(t.target), i = t.targetTouches[0], l) {
                if ((n = window.getSelection()).rangeCount && !n.isCollapsed) return !0;
                if (!h) {
                    if (i.identifier && i.identifier === this.lastTouchIdentifier) return t.preventDefault(), !1;
                    this.lastTouchIdentifier = i.identifier, this.updateScrollParent(e)
                }
            }
            return this.trackingClick = !0, this.trackingClickStart = t.timeStamp, this.targetElement = e, this.touchStartX = i.pageX, this.touchStartY = i.pageY, t.timeStamp - this.lastClickTime < this.tapDelay && t.preventDefault(), !0
        }, a.prototype.touchHasMoved = function(t) {
            var e = t.changedTouches[0],
                t = this.touchBoundary;
            return Math.abs(e.pageX - this.touchStartX) > t || Math.abs(e.pageY - this.touchStartY) > t
        }, a.prototype.onTouchMove = function(t) {
            return this.trackingClick && (this.targetElement === this.getTargetElementFromEventTarget(t.target) && !this.touchHasMoved(t) || (this.trackingClick = !1, this.targetElement = null)), !0
        }, a.prototype.findControl = function(t) {
            return void 0 !== t.control ? t.control : t.htmlFor ? document.getElementById(t.htmlFor) : t.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea")
        }, a.prototype.onTouchEnd = function(t) {
            var e, i, n, r, s = this.targetElement;
            if (!this.trackingClick) return !0;
            if (t.timeStamp - this.lastClickTime < this.tapDelay) return this.cancelNextClick = !0;
            if (this.cancelNextClick = !1, this.lastClickTime = t.timeStamp, e = this.trackingClickStart, this.trackingClick = !1, this.trackingClickStart = 0, c && (r = t.changedTouches[0], (s = document.elementFromPoint(r.pageX - window.pageXOffset, r.pageY - window.pageYOffset) || s).fastClickScrollParent = this.targetElement.fastClickScrollParent), "label" === (i = s.tagName.toLowerCase())) {
                if (r = this.findControl(s)) {
                    if (this.focus(s), o) return !1;
                    s = r
                }
            } else if (this.needsFocus(s)) return 100 < t.timeStamp - e || l && window.top !== window && "input" === i ? this.targetElement = null : (this.focus(s), this.sendClick(s, t), l && "select" === i || (this.targetElement = null, t.preventDefault())), !1;
            return !(!l || h || !(n = s.fastClickScrollParent) || n.fastClickLastScrollTop === n.scrollTop) || (this.needsClick(s) || (t.preventDefault(), this.sendClick(s, t)), !1)
        }, a.prototype.onTouchCancel = function() {
            this.trackingClick = !1, this.targetElement = null
        }, a.prototype.onMouse = function(t) {
            return !this.targetElement || (!!t.forwardedTouchEvent || (!t.cancelable || (!(!this.needsClick(this.targetElement) || this.cancelNextClick) || (t.stopImmediatePropagation ? t.stopImmediatePropagation() : t.propagationStopped = !0, t.stopPropagation(), t.preventDefault(), !1))))
        }, a.prototype.onClick = function(t) {
            return this.trackingClick ? (this.targetElement = null, !(this.trackingClick = !1)) : "submit" === t.target.type && 0 === t.detail || ((t = this.onMouse(t)) || (this.targetElement = null), t)
        }, a.prototype.destroy = function() {
            var t = this.layer;
            o && (t.removeEventListener("mouseover", this.onMouse, !0), t.removeEventListener("mousedown", this.onMouse, !0), t.removeEventListener("mouseup", this.onMouse, !0)), t.removeEventListener("click", this.onClick, !0), t.removeEventListener("touchstart", this.onTouchStart, !1), t.removeEventListener("touchmove", this.onTouchMove, !1), t.removeEventListener("touchend", this.onTouchEnd, !1), t.removeEventListener("touchcancel", this.onTouchCancel, !1)
        }, a.notNeeded = function(t) {
            var e, i;
            if (void 0 === window.ontouchstart) return !0;
            if (i = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1]) {
                if (!o) return !0;
                if (e = document.querySelector("meta[name=viewport]")) {
                    if (-1 !== e.content.indexOf("user-scalable=no")) return !0;
                    if (31 < i && document.documentElement.scrollWidth <= window.outerWidth) return !0
                }
            }
            if (n && (i = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/), 10 <= i[1] && 3 <= i[2] && (e = document.querySelector("meta[name=viewport]")))) {
                if (-1 !== e.content.indexOf("user-scalable=no")) return !0;
                if (document.documentElement.scrollWidth <= window.outerWidth) return !0
            }
            return "none" === t.style.msTouchAction
        }, a.attach = function(t, e) {
            return new a(t, e)
        }, "function" == typeof define && "object" == typeof define.amd && define.amd ? define("fastClick", [], function() {
            return a
        }) : "undefined" != typeof module && module.exports ? (module.exports = a.attach, module.exports.FastClick = a) : window.FastClick = a
    }(), define("touch/touch.view", ["dispatcher", "touch/touch.store", "fastClick"], function(n, t, r) {
        "use strict";
        ! function() {
            navigator.userAgent.toLowerCase().indexOf("firefox");
            var t, e = document.getElementsByTagName("html")[0],
                i = (i = !1, t = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (i = !0), i);
            (Modernizr.mobile = i) ? (e.classList.add("mobile"), e.classList.remove("no-mobile")) : (e.classList.remove("mobile"), e.classList.add("no-mobile")), i = Modernizr.touchevents, n.dispatch({
                type: "touch-set",
                touch: i
            }), i ? (e.classList.add("touch-detected"), e.classList.remove("touch-undetected"), r.attach(document.body)) : (e.classList.remove("touch-detected"), e.classList.add("touch-undetected"))
        }()
    }), define("utils", [], function() {
        var a = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t, e) {
            window.setTimeout(t, 1e3 / 60)
        };
        return {
            offset: function(t) {
                return function(t) {
                    for (var e = 0, i = 0; t;) e += parseInt(t.offsetTop), i += parseInt(t.offsetLeft), t = t.offsetParent;
                    return {
                        top: e,
                        left: i
                    }
                }(t)
            },
            offsetFrom: function(t, n) {
                return function(t) {
                    for (var e = 0, i = 0; t && t !== n;) e += parseInt(t.offsetTop), i += parseInt(t.offsetLeft), t = t.offsetParent;
                    return {
                        top: e,
                        left: i
                    }
                }(t)
            },
            Tween: function(n, r, t, s, e) {
                this.i = 0, this.duration = 60 * t, this.current = n, this.func = e, this.to = r, this.halt = !1, this.stop = function() {
                    this.halt = !0, this.i = 0, this.current = n
                }, this.animate = function() {
                    var e = this;
                    this.halt = !1, this.func(this.current);
                    var i = function() {
                        var t;
                        e.halt || (e.i++, 1 < (t = e.i / e.duration) && (t = 1), t = s ? s(t) : t, e.current = n + (r - n) * t, e.func(e.current), 0 !== Math.floor(e.current - e.to) && a(i))
                    };
                    i()
                }
            },
            getRequestAnimationFrame: function() {
                return a
            },
            http: function(i) {
                var n = function(h, c, u, d) {
                    return new Promise(function(t, e) {
                        var i, n, r, s, a, o = new XMLHttpRequest;
                        if (o.onload = function() {
                                200 <= this.status && this.status < 300 ? t(this.response) : e(this.statusText)
                            }, o.onerror = function() {
                                e(this.statusText)
                            }, u) {
                            if (d && "urlencoded" !== d) {
                                if ("json" === d) {
                                    a = u.entries(), n = {};
                                    for (var l = 0; l < a.length; l++) n[a[l][0]] = a[l][1];
                                    n = JSON.stringify(n)
                                }
                            } else
                                for (s in i = "", r = 0, u) u.hasOwnProperty(s) && (r++ && (i += "&"), i += encodeURIComponent(s) + "=" + encodeURIComponent(u[s]));
                            "GET" === h || "DELETE" === h ? (o.open(h, c + "?" + i), o.send()) : (o.open(h, c), "json" === d ? (o.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), o.send(n)) : "urlencoded" === d ? (o.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), o.send(i)) : o.send(u))
                        } else o.open(h, c), o.send()
                    })
                };
                return {
                    get: function(t, e) {
                        return n("GET", i, t, e)
                    },
                    post: function(t, e) {
                        return n("POST", i, t, e)
                    },
                    put: function(t, e) {
                        return n("PUT", i, t, e)
                    },
                    delete: function(t, e) {
                        return n("DELETE", i, t, e)
                    }
                }
            },
            queryParse: function(t) {
                return "string" == typeof t && (t = t.trim().replace(/^(\?|#|&)/, "")) ? t.split("&").reduce(function(t, e) {
                    var i = e.replace(/\+/g, " ").split("="),
                        e = i[0],
                        i = i[1],
                        e = decodeURIComponent(e),
                        i = void 0 === i ? null : decodeURIComponent(i);
                    return t.hasOwnProperty(e) ? Array.isArray(t[e]) ? t[e].push(i) : t[e] = [t[e], i] : t[e] = i, t
                }, {}) : {}
            },
            getIEVersion: function() {
                var t, e = -1;
                return "Microsoft Internet Explorer" == navigator.appName && (t = navigator.userAgent, null != new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})").exec(t) && (e = parseFloat(RegExp.$1))), e
            }
        }
    }), define("scroll/scroll.store", ["dispatcher", "utils/EventEmitter", "page-load/page-load.store"], function(t, e, i) {
        "use strict";

        function n() {
            var t, e = i.getData().loaded;
            a.top = (t = (window.pageYOffset || window.document.scrollTop) - (window.document.clientTop || 0), !isNaN(t) && void 0 !== t || (t = 0), t), a.left = (t = (window.pageXOffset || window.document.scrollLeft) - (window.document.clientLeft || 0), !isNaN(t) && void 0 !== t || (t = 0), t), e && s.dispatch()
        }

        function r(t) {}
        var s = new e,
            a = {
                top: 0,
                left: 0
            };
        return t.subscribe(r), n(), window.addEventListener("scroll", n, {
            passive: !0
        }), {
            subscribe: s.subscribe.bind(s),
            unsubscribe: s.unsubscribe.bind(s),
            getData: function() {
                return a
            }
        }
    }), define("resize/resize.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i() {
            s = {
                width: document.body.clientWidth,
                height: document.body.clientHeight
            }, r.dispatch()
        }

        function n(t) {
            "resize:store-fire" === t.type && r.dispatch()
        }
        var r = new e,
            s = {
                width: 0,
                height: 0
            };
        return i(), window.addEventListener("resize", i, {
            passive: !0
        }), window.addEventListener("orientationchange", i, {
            passive: !0
        }), window.addEventListener("load", i, {
            passive: !0
        }), t.subscribe("resize", n), {
            subscribe: r.subscribe.bind(r),
            unsubscribe: r.unsubscribe.bind(r),
            getData: function() {
                return s
            }
        }
    }), define("scroll/synth-scroll.view", ["dispatcher", "utils", "TweenMax", "scroll/scroll.store", "resize/resize.store"], function(r, s, a, o, l) {
        "use strict";

        function e(t) {
            function e() {
                var t = {
                        y: 0
                    },
                    e = o.getData().top;
                t.y = e, a.to(t, .6, {
                    y: i,
                    ease: Expo.easeInOut,
                    onUpdate: function() {
                        window.scrollTo(0, t.y), r.dispatch({
                            type: "scroll:synth-change",
                            position: t.y
                        })
                    }
                })
            }
            var i, n = document.getElementsByClassName("page-wrapper")[0];
            t.hasOwnProperty("speed") && t.speed, t.hasOwnProperty("position") && "number" == typeof t.position ? (i = t.position, e()) : t.hasOwnProperty("position") && "home" === t.position ? (i = 0, e()) : t.hasOwnProperty("position") && "end" === t.position ? (i = n.clientHeight - l.getData().height, e()) : t.hasOwnProperty("element") && ((i = s.offset(t.element).top) > n.clientHeight - l.getData().height && (i = n.clientHeight - l.getData().height), e())
        }
        r.subscribe(function(t) {
            "scroll:to" === t.type && e(t)
        })
    }), define("stage/particles/particles.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            if ("stage:change-map" === t.type) {
                if (r === t.particleMap) return;
                r = t.particleMap, n.dispatch()
            }
            if ("stage:reset" === t.type) {
                if (!r) return;
                r = null, n.dispatch()
            }
            "stage:particle-data" === t.type && (a = t.particleData, n.dispatch()), "stage:particles-ready" === t.type && (s = !0, n.dispatch())
        }
        var n = new e,
            r = null,
            s = !1,
            a = [1, 1, 0];
        return t.subscribe(i), {
            subscribe: n.subscribe.bind(n),
            unsubscribe: n.unsubscribe.bind(n),
            getData: function() {
                return {
                    map: r,
                    particleData: a,
                    ready: s
                }
            }
        }
    }), define("stage/stage.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            "stage:ready" === t.type && (r = !0, n.dispatch())
        }
        var n = new e,
            r = !1;
        return t.subscribe(i), {
            subscribe: n.subscribe.bind(n),
            unsubscribe: n.unsubscribe.bind(n),
            getData: function() {
                return {
                    ready: r
                }
            }
        }
    }), define("page-load/preloader-full.component", ["dispatcher", "config", "page-load/page-load.store", "stage/particles/particles.store", "stage/stage.store"], function(n, t, e, r, i) {
        "use strict";

        function s(t, e, i, n, r) {
            r = "transform " + n + "s ease " + r + "s,opacity " + n + "s ease " + r + "s", i = "scale(" + i + ")", t && t.style && (t.style.transition = t.style.webkitTransition = r, t.style.transform = t.style.webkitTransform = i, t.style.opacity = e)
        }
        var a = Object.create(HTMLElement.prototype);
        a.createdCallback = function() {
            this._step = 0, this.handleStage = function() {
                var t = i.getData().ready,
                    e = document.getElementsByTagName("main")[0];
                t && this._startTime && 1 === this._step && (this._step = 2, this._endTime = Date.now(), t = Math.max(0, 3e3 - (this._endTime - this._startTime)), document.getElementsByClassName("s-slide")[0], setTimeout(function() {
                    n.dispatch({
                        type: "page-load:load"
                    }), s(e, 1, 1, 1.2, 1.2)
                }, t))
            }.bind(this), this.handleParticles = function() {
                var t = r.getData().ready,
                    e = document.getElementsByTagName("main")[0],
                    i = this;
                t && 0 === this._step && (this._step = 1, this._startTime = Date.now(), s(e, 0, .95, 0, 0), setTimeout(function() {
                    i._initPreloader.classList.remove("start"), i._initPreloader.classList.add("end"), n.dispatch({
                        type: "stage:particle-data",
                        particleData: [1, 1, 0]
                    }), n.dispatch({
                        type: "stage:change-map",
                        particleMap: "map-vd",
                        map: "map-blank"
                    }), setTimeout(function() {
                        i._initPreloader.parentNode.removeChild(i._initPreloader)
                    }, 4e3)
                }, 20))
            }.bind(this)
        }, a.attachedCallback = function() {
            t.dev ? this.style.display = "none" : (this._initPreloader = document.getElementById("init-preloader"), this._initPreloader ? (this.handleParticles(), this.handleStage(), r.subscribe(this.handleParticles), r.subscribe(this.handleStage), i.subscribe(this.handleStage)) : console.warn("init preloader missing"))
        }, a.detachedCallback = function() {
            r.unsubscribe(this.handleParticles), r.unsubscribe(this.handleStage), i.unsubscribe(this.handleStage)
        }, document.registerElement("preloader-full", {
            prototype: a
        })
    }), define("map/map-link.component", ["dispatcher"], function(t) {
        "use strict";
        var e = Object.create(HTMLAnchorElement.prototype);
        e.createdCallback = function() {}, e.attachedCallback = function() {
            var t, e = this.getAttribute("data-lat") || 0,
                i = this.getAttribute("data-lng") || 0,
                t = (t = navigator.userAgent || navigator.vendor || window.opera).match(/iPad/i) || t.match(/iPhone/i) || t.match(/iPod/i) ? "iOS" : t.match(/Android/i) ? "Android" : "unknown";
            "android" !== t.toLowerCase() && "ios" === t.toLowerCase() ? this.setAttribute("href", "https://maps.apple.com/?q=" + e + "," + i) : this.setAttribute("href", "https://maps.google.com/?q=" + e + "," + i)
        }, e.detachedCallback = function() {}, document.registerElement("map-link", {
            prototype: e,
            extends: "a"
        })
    }), define("popup/popup.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            if ("popup:toggle" === t.type) {
                if (s) return;
                s = !0, setTimeout(function() {
                    s = !1
                }, 600), n = n !== t.id && t.id, r = t.element, t.userData && (a = t.userData), o.dispatch(), a = {}
            }
            if ("popup:open" === t.type) {
                if (s) return;
                if (n === t.id) return;
                s = !0, setTimeout(function() {
                    s = !1
                }, 600), n = t.id, r = t.element, t.userData && (a = t.userData), o.dispatch(), a = {}
            }
            if ("popup:close" === t.type) {
                if (s) return;
                if (!1 === n) return;
                s = !0, setTimeout(function() {
                    s = !1
                }, 600), n = !1, r = t.element, t.userData && (a = t.userData), o.dispatch(), a = {}
            }
            "popup:close-all" === t.type && !1 !== n && (n = !1, r = t.element, t.userData && (a = t.userData), o.dispatch(), a = {})
        }
        var n = !1,
            r = null,
            s = !1,
            a = {},
            o = new e;
        return t.subscribe(i), {
            subscribe: o.subscribe.bind(o),
            unsubscribe: o.unsubscribe.bind(o),
            getData: function() {
                return {
                    active: n,
                    toggleElement: r,
                    userData: a
                }
            }
        }
    }), define("utils/WheelHandler", [], function() {
        "use strict";
        return function() {
            this._time = null, this._ctrl = !1, this._isScrolling = !1, this.handle = function() {}, this._resetBuffer = function() {
                this._scrollBuffer = [];
                for (var t = 0; t < 40; t++) this._scrollBuffer.push(0)
            }, this._resetBuffer(), this.onWheel = function(t) {
                var e = t.wheelDelta || -t.deltaY || -t.detail,
                    i = 0 < e ? "up" : "down";
                this._ctrl || Math.abs(t.wheelDeltaX) > Math.abs(t.wheelDelta) || Math.abs(t.deltaX) > Math.abs(t.deltaY) || (t = this._time, this._time = (new Date).getTime(), t && 300 < this._time - t && this._resetBuffer(), this._scrollBuffer.push(Math.abs(e)), this._scrollBuffer.shift(), this._isScrolling || (t = this._scrollBuffer.slice(30, 40), e = this._scrollBuffer.slice(0, 30), t = t.reduce(function(t, e) {
                    return t + e
                }), e = e.reduce(function(t, e) {
                    return t + e
                }), (e /= 30) < (t /= 10) && this.handle(i)))
            }.bind(this), this.attach = function() {
                document.addEventListener("mousewheel", this.onWheel), document.addEventListener("wheel", this.onWheel)
            }, this.detach = function() {
                document.removeEventListener("mousewheel", this.onWheel), document.removeEventListener("wheel", this.onWheel)
            }
        }
    }), define("utils/VerticalSwipe", [], function() {
        "use strict";
        return function(t) {
            this.component = t, this._start = {}, this._delta = {}, this._horizontal = void 0, this._edge = !1, this.ontouchstart = function(t) {
                t = t.touches[0];
                this.wh = this.component.clientHeight, this.index = this.component._index || 0, this.total = this.component._total || 0, this._start = {
                    x: t.pageX,
                    y: t.pageY,
                    time: +new Date
                }, this._delta = {}, this._horizontal = void 0, this.component.addEventListener("touchmove", this.ontouchmove), this.component.addEventListener("touchend", this.ontouchend)
            }.bind(this), this.ontouchmove = function(t) {
                var e = 0;
                1 < t.touches.length || t.scale && 1 !== t.scale || (event.touches[0], this.touches = event.touches[0], this._delta = {
                    x: this.touches.pageX - this._start.x,
                    y: this.touches.pageY - this._start.y
                }, this._horizontal, this._horizontal || (e = this._delta.y / 3, (this.index || this.total) && (0 < this._delta.y && this.index <= 0 || this._delta.y < 0 && this.index >= this.total - 1) ? this._edge = !0 : this._edge = !1, this._edge && (e /= 4), t = new CustomEvent("touchshift", {
                    detail: e
                }), this.component.dispatchEvent(t), this.move && this.move(e)))
            }.bind(this), this.ontouchend = function(t) {
                var e = +new Date - this._start.time,
                    i = parseInt(e) < 250 && 20 < Math.abs(this._delta.y) || 100 < Math.abs(this._delta.y),
                    e = 250;
                this.component.removeEventListener("touchmove", this.ontouchmove, !1), this.component.removeEventListener("touchend", this.ontouchend, !1), this._horizontal || (i && !this._edge ? this.handle && this.handle(0 < this._delta.y ? "up" : "down") : (this._edge && (e = 150), this.cancel && this.cancel(e), e = new CustomEvent("touchcancel"), this.component.dispatchEvent(e)))
            }.bind(this), this.attach = function() {
                this.component.addEventListener("touchstart", this.ontouchstart)
            }, this.detach = function() {
                this.component.removeEventListener("touchstart", this.ontouchstart), this.component.removeEventListener("touchmove", this.ontouchmove), this.component.removeEventListener("touchend", this.ontouchend)
            }
        }
    }), define("slide-scroll/slide-scroll.component", ["dispatcher", "slide-scroll/slide-scroll.store", "resize/resize.store", "scroll/scroll.store", "popup/popup.store", "utils/WheelHandler", "utils/VerticalSwipe"], function(h, c, e, i, n, t, r) {
        "use strict";

        function s() {
            var t = document.createEvent("HTMLEvents");
            t.initEvent("resize", !0, !1), window.dispatchEvent(t)
        }

        function u(t, e, i) {
            t.style.transitionDuration = i + "ms", t.style.transform = "translateY(" + e + "px) translateZ(0)"
        }

        function a(t) {
            this.component = t, this.focusable = [], this.onKeyDown = function(t) {
                var e, i = t.which,
                    n = this;
                if (9 === i) {
                    if (t = document.activeElement) {
                        if (e = Array.prototype.indexOf.call(this.focusable, t), (++e < 0 || e > this.focusable.length) && (e = 0), !(t = this.focusable[e])) return;
                        if (!(t = t.closest(".s-slide"))) return;
                        t = Array.prototype.indexOf.call(this.component._slides, t), h.dispatch({
                            type: "slide-scroll:to",
                            id: this.component._id,
                            index: t
                        })
                    } else e = 0;
                    setTimeout(function() {
                        n.component.scrollTo && n.component.scrollTo(0, 0)
                    }, 0)
                }
                17 === i && (this.component._ctrl = !0), 38 === i || 33 === i ? h.dispatch({
                    type: "slide-scroll:direction",
                    id: this.component._id,
                    direction: "up"
                }) : 40 !== i && 34 !== i || h.dispatch({
                    type: "slide-scroll:direction",
                    id: this.component._id,
                    direction: "down"
                })
            }.bind(this), this.onKeyUp = function() {
                this.component._ctrl = !1
            }.bind(this), this.update = function() {
                var t = navigator.vendor && -1 < navigator.vendor.indexOf("Apple") && navigator.userAgent && !navigator.userAgent.match("CriOS");
                this.focusable = t ? document.querySelectorAll("button, a, input, select, textarea") : document.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"]')
            }.bind(this), this.attach = function() {
                document.addEventListener("keydown", this.onKeyDown), document.addEventListener("keyup", this.onKeyUp), this.update()
            }, this.detach = function() {
                document.removeEventListener("keydown", this.onKeyDown), document.removeEventListener("keyup", this.onKeyUp)
            }
        }
        var o = 1,
            l = Object.create(HTMLElement.prototype);
        return l.createdCallback = function() {
            this._ctrl = !1, this._active = null, this.handleStore = function() {
                var i, t, e, n = c.getData().items[this._id],
                    r = c.getData().nativeScroll,
                    s = window.innerHeight,
                    a = document.getElementsByClassName("page-wrapper")[0],
                    o = this,
                    l = this._index;
                this._index = n.index, this._isScrolling = !0, this.onSlide && this.onSlide(), h.dispatch({
                    type: "slide-scroll"
                }), e = this._slides[this._index], l > n.index ? (a.classList.add("slide-direction-up"), a.classList.remove("slide-direction-down"), this._direction = "up") : (a.classList.remove("slide-direction-up"), a.classList.add("slide-direction-down"), this._direction = "down"), a = c.getData().animationSpeed, i = c.getData().appearDelay, setTimeout(function() {
                    o._isScrolling = !1
                }, c.getData().timeForBlocking), this._active ? (Array.prototype.forEach.call(this._slides, function(t, e) {
                    e > n.index ? (t.classList.remove("slide-delayed"), t.classList.remove("slide-previous"), t.classList.remove("slide-current"), t.classList.add("slide-next")) : e < n.index ? (t.classList.remove("slide-delayed"), t.classList.remove("slide-next"), t.classList.remove("slide-current"), t.classList.add("slide-previous")) : i ? (clearTimeout(o._appearDelayTo), i < 0 && (i = 0), o._appearDelayTo = setTimeout(function() {
                        t.classList.add("slide-delayed"), t.classList.remove("slide-next"), t.classList.remove("slide-previous"), t.classList.add("slide-current")
                    }, i)) : (t.classList.remove("slide-delayed"), t.classList.remove("slide-next"), t.classList.remove("slide-previous"), t.classList.add("slide-current"))
                }), this._shift ? u(this._wrapper, -this._shift * this._index, a) : void 0 === this._shift && u(this._wrapper, -s * this._index, a), n.setFocus && (t = (t = e.querySelector(".focus-target")) || e.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"]')) && (t.focus(), this.scrollTo && this.scrollTo(0, 0))) : r || h.dispatch({
                    type: "scroll:to",
                    element: e,
                    speed: .45
                })
            }.bind(this), this.handleResize = function() {
                var t, i = this,
                    e = c.getData().items[this._id],
                    n = window.innerHeight,
                    r = window.innerWidth;
                document.getElementsByTagName("html")[0];
                e ? (this._minHeights ? (t = this._minHeights.reduce(function(t, e) {
                    return e.bp < r ? e : t
                }), this._minHeight = t, n < t.h && !1 !== this._active ? this.deactivate() : n >= t.h && !0 !== this._active && this.activate()) : this._active || this.activate(), this._active ? (Array.prototype.forEach.call(this._slides, function(t, e) {
                    t.style.position = "absolute", t.style.height = "100%", t.style.width = "100%", void 0 !== i._shift ? t.style.top = i._shift * e + "px" : t.style.top = n * e + "px"
                }), void 0 !== this._shift ? u(this._wrapper, -this._shift * e.index, 0) : u(this._wrapper, -n * e.index, 0)) : Array.prototype.forEach.call(this._slides, function(t, e) {
                    t.style.position = null, t.style.height = null, t.style.width = null, t.style.top = null
                })) : console.warn("slide-scroll store error")
            }.bind(this), this.handleScroll = function(t) {
                var i = window.scrollY,
                    n = 0;
                !0 !== this._active && (Array.prototype.forEach.call(this._slides, function(t, e) {
                    i + 50 >= t.offsetTop && (n = e)
                }), n !== this.index && (this._index = n, h.dispatch({
                    type: "slide-scroll:to",
                    id: this._id,
                    index: n,
                    native: !0
                })))
            }.bind(this), this.handlePopup = function() {
                var t = n.getData().active;
                this._popupId && this._active && ("null" === this._popupId ? t ? this.removeInputHandlers() : this.setInputHandlers() : t === this._popupId ? this.setInputHandlers() : this.removeInputHandlers())
            }.bind(this), this.touchHandler = new r(this), this.wheelHandler = new t, this.keyboardHandler = new a(this), this.activate = function() {
                document.getElementsByTagName("html")[0], window.innerHeight;
                var t = document.querySelector(".page-wrapper");
                !0 !== this._active && (this._active = !0, this.setInputHandlers(), this.classList.add("slide-mode"), this.classList.remove("scroll-mode"), t.classList.add("slide-scroll-active"), this.scrollTop = 0, this.handleResize(), this.handleStore(), setTimeout(s, 20), h.dispatch({
                    type: "slide-scroll:enable",
                    id: this._id
                }))
            }.bind(this), this.deactivate = function() {
                var i = this,
                    t = (document.getElementsByTagName("html")[0], document.querySelector(".page-wrapper"));
                !1 !== this._active && (this._active = !1, this.removeInputHandlers(), this.classList.remove("slide-mode"), this.classList.add("scroll-mode"), t.classList.remove("slide-scroll-active"), Array.prototype.forEach.call(this._slides, function(t, e) {
                    t.style.position = "relative", i._minHeight ? t.style.height = i._minHeight + "px" : t.style.height = "", t.style.top = "0px", t.classList.remove("slide-next"), t.classList.remove("slide-previous")
                }), u(this._wrapper, 0, 0), setTimeout(s, 20), h.dispatch({
                    type: "slide-scroll:disable",
                    id: this._id
                }))
            }.bind(this), this.setInputHandlers = function() {
                var i = this;
                this._hadlersSet = !0, this.touchHandler.attach(), this.wheelHandler.attach(), this.keyboardHandler.attach(), this.wheelHandler.handle = function(t) {
                    h.dispatch({
                        type: "slide-scroll:direction",
                        id: i._id,
                        direction: t
                    })
                }, this.touchHandler.move = function(t) {
                    var e = i.clientHeight;
                    void 0 !== i._shift ? u(i._wrapper, -i._shift * i._index + t, 0) : u(i._wrapper, -e * i._index + t, 0)
                }, this.touchHandler.cancel = function(t) {
                    var e = i.clientHeight;
                    void 0 !== i._shift ? u(i._wrapper, -i._shift * i._index, t) : u(i._wrapper, -e * i._index, t)
                }, this.touchHandler.handle = function(t) {
                    h.dispatch({
                        type: "slide-scroll:direction",
                        id: i._id,
                        direction: t
                    })
                }
            }.bind(this), this.removeInputHandlers = function() {
                this._hadlersSet = !1, this.touchHandler.detach(), this.wheelHandler.detach(), this.keyboardHandler.detach()
            }.bind(this), this._index = 0, this._hadlersSet = !1
        }, l.attachedCallback = function() {
            var t = this;
            this._slides = this.getElementsByClassName("s-slide"), this._active = void 0, this._wrapper = this.getElementsByClassName("s-wrapper")[0], this._total = this._slides.length, this._id = this.getAttribute("data-id") || "slide-scroll-" + o++, this.setAttribute("data-id", this._id), this._popupId = this.getAttribute("data-popup-id") || "null", this._shift = this.getAttribute("data-shift"), this._shift && (this._shift = parseInt(this._shift)), this._minHeights = this.getAttribute("data-min-heights"), this._minHeights = this._minHeights ? this._minHeights.split(";").map(function(t) {
                t = t.split(":");
                return {
                    bp: parseInt(t[0]),
                    h: "inf" === t[1] ? 1 / 0 : parseInt(t[1])
                }
            }) : null, h.dispatch({
                type: "slide-scroll:add",
                id: this._id,
                index: 0,
                total: this._total,
                shift: this._shift
            }), Array.prototype.forEach.call(this._slides, function(t, e) {
                0 < e && t.classList.add("slide-next")
            }), this.handleResize(), this.handleScroll(), this.handlePopup(), i.subscribe(this.handleScroll), n.subscribe(this.handlePopup), c.subscribe(this.handleStore), e.subscribe(this.handleResize), setTimeout(function() {
                t.classList.add("slide-scroll-ready")
            }, 20)
        }, l.detachedCallback = function() {
            i.unsubscribe(this.handleScroll), n.unsubscribe(this.handlePopup), c.unsubscribe(this.handleStore), e.unsubscribe(this.handleResize), this.deactivate(), h.dispatch({
                type: "slide-scroll:remove",
                id: this._id
            })
        }, document.registerElement("slide-scroll", {
            prototype: l
        }), l
    }), define("decor/cursor-interactive.component", ["dispatcher"], function(s) {
        "use strict";
        var t = Object.create(HTMLButtonElement.prototype);
        return t.createdCallback = function() {
            this.handleMouseEnter = function() {
                var t, e, i, n, r = this.getAttribute("data-target");
                this.classList.contains(this._disabledClass) || (r = (r = r && this.querySelector(r)) || this, "mask" === this._hover && (t = (n = r.getBoundingClientRect()).x + n.width / 2, e = n.y + n.height / 2, i = n.width / 2 - 5, n = n.height / 2 + 20), "glow" === this._hover && (i = 0, n = 200), s.dispatch({
                    type: "cursor:force-position",
                    x: t,
                    y: e,
                    r1: i,
                    r2: n,
                    color: .5
                }))
            }.bind(this), this.handleMouseLeave = function() {
                s.dispatch({
                    type: "cursor:free-position"
                })
            }.bind(this), this._disabledClass = "active"
        }, t.attachedCallback = function() {
            this._hover = this.getAttribute("data-hover"), this._hover || (this._hover = "glow"), this.addEventListener("mouseenter", this.handleMouseEnter), this.addEventListener("mouseleave", this.handleMouseLeave)
        }, t.detachedCallback = function() {}, document.registerElement("cursor-interactive", {
            prototype: t,
            extends: "button"
        }), t
    }), define("slide-scroll/slide-scroll-control.component", ["dispatcher", "slide-scroll/slide-scroll.store", "decor/cursor-interactive.component"], function(e, n, t) {
        "use strict";
        var i = Object.create(HTMLButtonElement.prototype);
        i.createdCallback = function() {
            t.createdCallback.apply(this), this._animating = !1, this._index = null, this.handleStore = function() {
                var t, e = n.getData().items[this._id],
                    i = this;
                e && e.index !== this._index && (t = e.timeForBlocking || 800, this._index = e.index, this._animating = !0, setTimeout(function() {
                    i._animating = !1
                }, t), "prev" === this._to ? 0 === this._index ? this.classList.add("inactive") : this.classList.remove("inactive") : "next" === this._to && (this._index === e.total - 1 ? this.classList.add("inactive") : this.classList.remove("inactive")))
            }.bind(this), this.handleClick = function() {
                var t;
                this._animating || (t = (t = (t = this.getAttribute("data-target")) && this.querySelector(t)) || this, e.dispatch({
                    type: "slide-scroll:click",
                    element: t,
                    originalTarget: this
                }), "false" === (t = this.getAttribute("data-set-focus") || "true") && (t = !1), "next" === this._to ? e.dispatch({
                    type: "slide-scroll:direction",
                    direction: "down",
                    id: this._id,
                    setFocus: t
                }) : "prev" === this._to ? e.dispatch({
                    type: "slide-scroll:direction",
                    direction: "up",
                    id: this._id,
                    setFocus: t
                }) : e.dispatch({
                    type: "slide-scroll:to",
                    index: parseInt(this._to),
                    id: this._id,
                    setFocus: t
                }))
            }.bind(this)
        }, i.attachedCallback = function() {
            t.attachedCallback.apply(this), this._id = this.getAttribute("data-id"), this._id || console.warn("data-id attribute is missing on slide-scroll-control"), this._to = this.getAttribute("data-to"), this._to || console.warn("data-to attribute is missing on slide-scroll-control"), this.addEventListener("click", this.handleClick), n.subscribe(this.handleStore), this.handleStore()
        }, i.detachedCallback = function() {
            t.detachedCallback.apply(this), this.removeEventListener("click", this.handleClick), n.unsubscribe(this.handleStore)
        }, document.registerElement("s-control", {
            extends: "button",
            prototype: i
        })
    }), define("stage/mesh/mesh.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            "stage:change-map" === t.type && r !== t.map && (r = t.map, n.dispatch())
        }
        var n = new e,
            r = null;
        return t.subscribe(i), {
            subscribe: n.subscribe.bind(n),
            unsubscribe: n.unsubscribe.bind(n),
            getData: function() {
                return {
                    map: r
                }
            }
        }
    }), define("stage/post/post.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            if ("stage:color-scheme" === t.type) {
                if (s.color === t.scheme) return;
                s.color = t.scheme, s.direction = t.direction, n.dispatch()
            }
            "stage:mask" === t.type && r !== t.mask && (r = t.mask || null, n.dispatch())
        }
        var n = new e,
            r = null,
            s = {
                color: "dark",
                direction: null
            };
        return t.subscribe(i), {
            subscribe: n.subscribe.bind(n),
            unsubscribe: n.unsubscribe.bind(n),
            getData: function() {
                return {
                    mask: r,
                    scheme: s
                }
            }
        }
    }), define("stage/stage-transform.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
        "use strict";

        function i(t) {
            "stage:transform" === t.type && (t.transform[0] === r[0] && t.transform[1] === r[1] || (r[0] = t.transform[0], r[1] = t.transform[1], n.dispatch()))
        }
        var n = new e,
            r = [0, 1];
        return t.subscribe(i), {
            subscribe: n.subscribe.bind(n),
            unsubscribe: n.unsubscribe.bind(n),
            getData: function() {
                return {
                    transform: r
                }
            }
        }
    }), define("slide-scroll/slide-scroll-wrapper.component", ["dispatcher", "popup/popup.store", "resize/resize.store", "slide-scroll/slide-scroll.store", "page-load/page-load.store", "stage/mesh/mesh.store", "stage/particles/particles.store", "stage/post/post.store", "stage/stage-transform.store", "slide-scroll/slide-scroll.component", "TweenMax"], function(x, t, b, i, w, e, n, r, s, a, o) {
        "use strict";

        function l() {
            var t, e, i, n, o, l, h, c, r, s, a, u, d, p, f, m = document.getElementsByClassName("page-wrapper")[0],
                g = this,
                v = [0, 0],
                _ = 0,
                y = !1;
            w.getData().loaded && this._slides && (f = this._slides[this._index]) && (this._wrapper.style.perspectiveOrigin = "50% " + (b.getData().height / 2 + this._shift * this._index / 2) + "px", f.classList.contains("dark") ? (t = "dark", m.classList.add("pw-dark"), m.classList.remove("pw-white")) : (t = "white", m.classList.remove("pw-dark"), m.classList.add("pw-white")), e = (e = f.getAttribute("data-transform")) ? e.split(" ").map(function(t) {
                return parseFloat(t)
            }) : [0, 1], x.dispatch({
                type: "stage:transform",
                transform: e
            }), i = f.getAttribute("data-map"), n = (n = f.getAttribute("data-particleMap")) || i, this._stageMap && this._active && (this._stageMap !== i && (_ = -300), x.dispatch({
                type: "slide-scroll:set-props",
                delay: _,
                block: 1300
            }), x.dispatch({
                type: "slide-scroll:reset-props-after"
            })), this._stageMap = i, x.dispatch({
                type: "stage:change-map",
                map: i,
                particleMap: n
            }), n = (n = f.getAttribute("data-particle")) ? n.split(" ").map(function(t) {
                return parseFloat(t)
            }) : [1, 1, 0], x.dispatch({
                type: "stage:particle-data",
                particleData: n
            }), this._active && (f = (f = f.getElementsByTagName("big-svg")[0]) ? f.getAttribute("data-mask") : null, x.dispatch({
                type: "stage:mask",
                mask: f
            }), t !== this._colorScheme ? (y = !0, this._colorScheme && (x.dispatch({
                type: "slide-scroll:set-props",
                delay: -300
            }), x.dispatch({
                type: "slide-scroll:reset-props-after"
            }), _ = -300), "dark" === (g._colorScheme = t) ? (m.classList.remove("to-white"), m.classList.add("to-dark")) : "white" === t && (m.classList.add("to-white"), m.classList.remove("to-dark")), setTimeout(function() {
                x.dispatch({
                    type: "stage:color-scheme",
                    scheme: t,
                    direction: g._direction
                })
            }, 0)) : (m.classList.remove("to-white"), m.classList.remove("to-dark")), this._previousIndex !== this._index && (v = [Math.round(10 * (this._previousTransform[0] - e[0])) / 10, Math.round(10 * (this._previousTransform[1] - e[1])) / 10], !y && "white" !== t || (v = [0, 0]), o = this._slides[this._previousIndex], l = this._slides[this._index], h = o.getElementsByClassName("wrapper")[0], c = l.getElementsByClassName("wrapper")[0], y = o.getElementsByClassName("drop-down"), Array.prototype.forEach.call(y, function(t) {
                "accordeon-control-group" !== t.parentNode.tagName.toLowerCase() && t.hide()
            }), function(t, e, i, n) {
                n = "opacity " + i + "s ease " + n + "s,transform " + 1.2 * i + "s cubic-bezier(0.55, 0.005, 0.205, 1) " + n + "s", e = "rotate3d(0.0, 0.0, 1, " + e[0] / 15 + "deg) scale(0.94)";
                t.style.transition = t.style.webkitTransition = n, t.style.transform = t.style.webkitTransform = e, t.style.opacity = 0
            }(o, v, .4, 0), r = l, s = v, a = .6, u = .4 + Math.abs(_ / 1e3), s = "rotate3d(0.0, 0.0, 1, " + -s[0] / 15 + "deg) scale(0.94)", d = d || 0, r.style.transition = r.style.webkitTransition = "opacity 0s ease 0s, transform 0s ease 0s", r.style.transform = r.style.webkitTransform = s, r.style.opacity = d, setTimeout(function() {
                p = "opacity " + a + "s ease " + u + "s,transform " + 1.2 * a + "s ease " + u + "s", s = "rotate3d(0.0, 0.0, 1, 0deg) scale(1)", r.style.transition = r.style.webkitTransition = p, r.style.transform = r.style.webkitTransform = s, r.style.opacity = 1
            }, 20), setTimeout(function() {
                var t, e, i, n, r, s, a;
                o.classList.contains("dark") || function(t, e, i, n, r) {
                    r = "transform " + n + "s ease " + r + "s", e = "scaleY(" + e + ")";
                    t.style.transformOrigin = t.style.webkitTransformOrigin = "50% " + i, t.style.transition = t.style.webkitTransition = r, t.style.transform = t.style.webkitTransform = e
                }(h, 1.035, "up" === g._direction ? "0%" : "100%", .7, 0), l.classList.contains("dark") || (t = c, e = 1.035, i = "up" === g._direction ? "100%" : "0%", n = .7, r = .4 + Math.abs(_ / 1e3), a = "scaleY(" + e + ")", t.style.transformOrigin = t.style.webkitTransformOrigin = "50% " + i, t.style.transition = t.style.webkitTransition = "transform 0s ease 0s", t.style.transform = t.style.webkitTransform = a, setTimeout(function() {
                    s = "transform " + n + "s ease " + r + "s", a = "scaleY(1)", t.style.transition = t.style.webkitTransition = s, t.style.transform = t.style.webkitTransform = a
                }, 20))
            }, 0), x.dispatch({
                type: "slide-scroll:transform",
                transform: v,
                previous: this._slides[this._previousIndex],
                current: this._slides[this._index],
                speed: .4
            })), this._previousTransform = e), this._previousIndex = this._index)
        }
        var h = Object.create(HTMLElement.prototype);
        h.createdCallback = function() {
            a.createdCallback.apply(this), this.onSlide = l.bind(this), this.additionalHandleDispatcher = function(t) {
                var e = document.getElementsByClassName("page-wrapper")[0];
                this._slides[this._index], i.getData().isBlocked;
                "popup:close-all" !== t.type && "popup:toggle" !== t.type || (e.classList.remove("to-white"), e.classList.remove("to-dark"))
            }.bind(this), this.additionalHandlePopup = function() {
                Array.prototype.forEach.call(this._slides, function(t) {
                    t.classList.remove("slide-delayed")
                })
            }.bind(this), this._previousIndex = this._index, this._previousTransform = [0, 0]
        }, h.attachedCallback = function() {
            a.attachedCallback.apply(this), x.subscribe(this.additionalHandleDispatcher), t.subscribe(this.additionalHandlePopup), this.onSlide(), w.subscribe(this.onSlide)
        }, h.detachedCallback = function() {
            a.detachedCallback.apply(this), x.unsubscribe(this.additionalHandleDispatcher), t.unsubscribe(this.additionalHandlePopup), w.unsubscribe(this.onSlide)
        }, document.registerElement("slide-scroll-wrapper", {
            prototype: h
        })
    }), define("events/cursor.store", ["dispatcher", "utils/EventEmitter", "resize/resize.store"], function(t, e, i) {
        "use strict";

        function n(t) {}

        function r(t) {
            a = t.pageX, o = t.pageY, l = t.clientX, h = t.clientY, Modernizr.mobile && Modernizr.touchevents || (u = t.movementX, d = t.movementY, c = Math.pow(Math.pow(u, 2) + Math.pow(d, 2), .5), s.dispatch())
        }
        var s = new e,
            a = i.getData().width / 2,
            o = i.getData().height / 2,
            l = a,
            h = o,
            c = 0,
            u = 0,
            d = 0;
        return t.subscribe(n), window.addEventListener("mousemove", r, {
            passive: !0
        }), {
            subscribe: s.subscribe.bind(s),
            unsubscribe: s.unsubscribe.bind(s),
            getData: function() {
                return {
                    pageX: a,
                    pageY: o,
                    screenX: l,
                    screenY: h,
                    speedX: u,
                    speedY: d,
                    speed: c
                }
            }
        }
    }),
    function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define("THREE", ["exports"], e) : e(t.THREE = {})
    }(this, function(t) {
        function e() {}

        function X(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function Et() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        function o(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
        }

        function St(t, e, i) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0
        }

        function g() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        function d(t, e, i, n, r, s, a, o, l, h) {
            Object.defineProperty(this, "id", {
                value: rs++
            }), this.uuid = es.generateUUID(), this.name = "", this.image = void 0 !== t ? t : d.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : d.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : 1001, this.wrapT = void 0 !== n ? n : 1001, this.magFilter = void 0 !== r ? r : 1006, this.minFilter = void 0 !== s ? s : 1008, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : 1023, this.type = void 0 !== o ? o : 1009, this.offset = new X(0, 0), this.repeat = new X(1, 1), this.center = new X(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new g, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : 3e3, this.version = 0, this.onUpdate = null
        }

        function At(t, e, i, n) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
        }

        function S(t, e, i) {
            this.uuid = es.generateUUID(), this.width = t, this.height = e, this.scissor = new At(0, 0, t, e), this.scissorTest = !1, this.viewport = new At(0, 0, t, e), void 0 === (i = i || {}).minFilter && (i.minFilter = 1006), this.texture = new d(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }

        function n(t, e, i) {
            S.call(this, t, e, i), this.activeMipMapLevel = this.activeCubeFace = 0
        }

        function Pt(t, e, i, n, r, s, a, o, l, h, c, u) {
            d.call(this, null, s, a, o, l, h, n, r, c, u), this.image = {
                data: t,
                width: e,
                height: i
            }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
        }

        function l(t, e, i, n, r, s, a, o, l, h) {
            d.call(this, t = void 0 !== t ? t : [], void 0 !== e ? e : 301, i, n, r, s, a, o, l, h), this.flipY = !1
        }

        function i(t, e, i) {
            var n = t[0];
            if (n <= 0 || 0 < n) return t;
            var r = e * i,
                s = os[r];
            if (void 0 === s && (s = new Float32Array(r), os[r] = s), 0 !== e)
                for (n.toArray(s, 0), n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(s, r);
            return s
        }

        function s(t, e) {
            var i = ls[e];
            void 0 === i && (i = new Int32Array(e), ls[e] = i);
            for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
            return i
        }

        function r(t, e) {
            t.uniform1f(this.addr, e)
        }

        function a(t, e) {
            t.uniform1i(this.addr, e)
        }

        function h(t, e) {
            void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
        }

        function c(t, e) {
            void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
        }

        function u(t, e) {
            void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
        }

        function p(t, e) {
            t.uniformMatrix2fv(this.addr, !1, e.elements || e)
        }

        function f(t, e) {
            void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (cs.set(e.elements), t.uniformMatrix3fv(this.addr, !1, cs))
        }

        function m(t, e) {
            void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (hs.set(e.elements), t.uniformMatrix4fv(this.addr, !1, hs))
        }

        function v(t, e, i) {
            var n = i.allocTextureUnit();
            t.uniform1i(this.addr, n), i.setTexture2D(e || ss, n)
        }

        function _(t, e, i) {
            var n = i.allocTextureUnit();
            t.uniform1i(this.addr, n), i.setTextureCube(e || as, n)
        }

        function y(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function x(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function b(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function w(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function T(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function M(t, e) {
            t.uniform2fv(this.addr, i(e, this.size, 2))
        }

        function E(t, e) {
            t.uniform3fv(this.addr, i(e, this.size, 3))
        }

        function A(t, e) {
            t.uniform4fv(this.addr, i(e, this.size, 4))
        }

        function P(t, e) {
            t.uniformMatrix2fv(this.addr, !1, i(e, this.size, 4))
        }

        function C(t, e) {
            t.uniformMatrix3fv(this.addr, !1, i(e, this.size, 9))
        }

        function R(t, e) {
            t.uniformMatrix4fv(this.addr, !1, i(e, this.size, 16))
        }

        function L(t, e, i) {
            var n = e.length,
                r = s(i, n);
            for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t) i.setTexture2D(e[t] || ss, r[t])
        }

        function O(t, e, i) {
            var n = e.length,
                r = s(i, n);
            for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t) i.setTextureCube(e[t] || as, r[t])
        }

        function D(t, e, i) {
            this.id = t, this.addr = i, this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return r;
                    case 35664:
                        return h;
                    case 35665:
                        return c;
                    case 35666:
                        return u;
                    case 35674:
                        return p;
                    case 35675:
                        return f;
                    case 35676:
                        return m;
                    case 35678:
                    case 36198:
                        return v;
                    case 35680:
                        return _;
                    case 5124:
                    case 35670:
                        return a;
                    case 35667:
                    case 35671:
                        return y;
                    case 35668:
                    case 35672:
                        return x;
                    case 35669:
                    case 35673:
                        return b
                }
            }(e.type)
        }

        function k(t, e, i) {
            this.id = t, this.addr = i, this.size = e.size, this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return w;
                    case 35664:
                        return M;
                    case 35665:
                        return E;
                    case 35666:
                        return A;
                    case 35674:
                        return P;
                    case 35675:
                        return C;
                    case 35676:
                        return R;
                    case 35678:
                        return L;
                    case 35680:
                        return O;
                    case 5124:
                    case 35670:
                        return T;
                    case 35667:
                    case 35671:
                        return y;
                    case 35668:
                    case 35672:
                        return x;
                    case 35669:
                    case 35673:
                        return b
                }
            }(e.type)
        }

        function I(t) {
            this.id = t, this.seq = [], this.map = {}
        }

        function Ct(t, e, i) {
            this.seq = [], this.map = {}, this.renderer = i, i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for (var n = 0; n < i; ++n) {
                var r = t.getActiveUniform(e, n),
                    s = t.getUniformLocation(e, r.name),
                    a = this,
                    o = r.name,
                    l = o.length;
                for (us.lastIndex = 0;;) {
                    var h = us.exec(o),
                        c = us.lastIndex,
                        u = h[1],
                        d = h[3];
                    if ("]" === h[2] && (u |= 0), void 0 === d || "[" === d && c + 2 === l) {
                        o = a, r = new(void 0 === d ? D : k)(u, r, s), o.seq.push(r), o.map[r.id] = r;
                        break
                    }
                    void 0 === (d = a.map[u]) && (d = new I(u), u = a, a = d, u.seq.push(a), u.map[a.id] = a), a = d
                }
            }
        }

        function N(t, e, i) {
            return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }

        function z(t, e) {
            this.min = void 0 !== t ? t : new X(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new X(-1 / 0, -1 / 0)
        }

        function Rt(t, _, y, x, b) {
            var w, T, M, E, S, A, P, C, R, L, O, D, k, I, N;
            this.render = function(t, e, i, n) {
                if (0 !== t.length) {
                    e = new St;
                    var r, s, a, o = n.w / n.z,
                        l = .5 * n.z,
                        h = .5 * n.w,
                        c = 16 / n.w,
                        u = new X(c * o, c),
                        d = new St(1, 1, 0),
                        p = new X(1, 1),
                        f = new z;
                    for (f.min.set(n.x, n.y), f.max.set(n.x + (n.z - 16), n.y + (n.w - 16)), void 0 === k && (c = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), r = new Uint16Array([0, 1, 2, 0, 2, 3]), O = _.createBuffer(), D = _.createBuffer(), _.bindBuffer(_.ARRAY_BUFFER, O), _.bufferData(_.ARRAY_BUFFER, c, _.STATIC_DRAW), _.bindBuffer(_.ELEMENT_ARRAY_BUFFER, D), _.bufferData(_.ELEMENT_ARRAY_BUFFER, r, _.STATIC_DRAW), I = _.createTexture(), N = _.createTexture(), y.bindTexture(_.TEXTURE_2D, I), _.texImage2D(_.TEXTURE_2D, 0, _.RGB, 16, 16, 0, _.RGB, _.UNSIGNED_BYTE, null), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, _.NEAREST), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, _.NEAREST), y.bindTexture(_.TEXTURE_2D, N), _.texImage2D(_.TEXTURE_2D, 0, _.RGBA, 16, 16, 0, _.RGBA, _.UNSIGNED_BYTE, null), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, _.NEAREST), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, _.NEAREST), c = {
                            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tvUV = uv;\n\tvec2 pos = position;\n\tif ( renderType == 2 ) {\n\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\t\tvVisibility =        visibility.r / 9.0;\n\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\tvVisibility *=       visibility.b / 9.0;\n\t\tvVisibility *= 1.0 - visibility.a / 9.0;\n\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\n\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n\t}\n\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                            fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tif ( renderType == 0 ) {\n\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n\t} else if ( renderType == 1 ) {\n\t\tgl_FragColor = texture2D( map, vUV );\n\t} else {\n\t\tvec4 texture = texture2D( map, vUV );\n\t\ttexture.a *= opacity * vVisibility;\n\t\tgl_FragColor = texture;\n\t\tgl_FragColor.rgb *= color;\n\t}\n}"
                        }, r = _.createProgram(), s = _.createShader(_.FRAGMENT_SHADER), a = _.createShader(_.VERTEX_SHADER), m = "precision " + b.precision + " float;\n", _.shaderSource(s, m + c.fragmentShader), _.shaderSource(a, m + c.vertexShader), _.compileShader(s), _.compileShader(a), _.attachShader(r, s), _.attachShader(r, a), _.linkProgram(r), k = r, R = _.getAttribLocation(k, "position"), L = _.getAttribLocation(k, "uv"), w = _.getUniformLocation(k, "renderType"), T = _.getUniformLocation(k, "map"), M = _.getUniformLocation(k, "occlusionMap"), E = _.getUniformLocation(k, "opacity"), S = _.getUniformLocation(k, "color"), A = _.getUniformLocation(k, "scale"), P = _.getUniformLocation(k, "rotation"), C = _.getUniformLocation(k, "screenPosition")), y.useProgram(k), y.initAttributes(), y.enableAttribute(R), y.enableAttribute(L), y.disableUnusedAttributes(), _.uniform1i(M, 0), _.uniform1i(T, 1), _.bindBuffer(_.ARRAY_BUFFER, O), _.vertexAttribPointer(R, 2, _.FLOAT, !1, 16, 0), _.vertexAttribPointer(L, 2, _.FLOAT, !1, 16, 8), _.bindBuffer(_.ELEMENT_ARRAY_BUFFER, D), y.disable(_.CULL_FACE), y.buffers.depth.setMask(!1), r = 0, s = t.length; r < s; r++)
                        if (c = 16 / n.w, u.set(c * o, c), a = t[r], e.set(a.matrixWorld.elements[12], a.matrixWorld.elements[13], a.matrixWorld.elements[14]), e.applyMatrix4(i.matrixWorldInverse), e.applyMatrix4(i.projectionMatrix), d.copy(e), p.x = n.x + d.x * l + l - 8, p.y = n.y + d.y * h + h - 8, !0 === f.containsPoint(p)) {
                            y.activeTexture(_.TEXTURE0), y.bindTexture(_.TEXTURE_2D, null), y.activeTexture(_.TEXTURE1), y.bindTexture(_.TEXTURE_2D, I), _.copyTexImage2D(_.TEXTURE_2D, 0, _.RGB, p.x, p.y, 16, 16, 0), _.uniform1i(w, 0), _.uniform2f(A, u.x, u.y), _.uniform3f(C, d.x, d.y, d.z), y.disable(_.BLEND), y.enable(_.DEPTH_TEST), _.drawElements(_.TRIANGLES, 6, _.UNSIGNED_SHORT, 0), y.activeTexture(_.TEXTURE0), y.bindTexture(_.TEXTURE_2D, N), _.copyTexImage2D(_.TEXTURE_2D, 0, _.RGBA, p.x, p.y, 16, 16, 0), _.uniform1i(w, 1), y.disable(_.DEPTH_TEST), y.activeTexture(_.TEXTURE1), y.bindTexture(_.TEXTURE_2D, I), _.drawElements(_.TRIANGLES, 6, _.UNSIGNED_SHORT, 0), a.positionScreen.copy(d), a.customUpdateCallback ? a.customUpdateCallback(a) : a.updateLensFlares(), _.uniform1i(w, 2), y.enable(_.BLEND);
                            for (var m = 0, g = a.lensFlares.length; m < g; m++) {
                                var v = a.lensFlares[m];
                                .001 < v.opacity && .001 < v.scale && (d.x = v.x, d.y = v.y, d.z = v.z, c = v.size * v.scale / n.w, u.x = c * o, u.y = c, _.uniform3f(C, d.x, d.y, d.z), _.uniform2f(A, u.x, u.y), _.uniform1f(P, v.rotation), _.uniform1f(E, v.opacity), _.uniform3f(S, v.color.r, v.color.g, v.color.b), y.setBlending(v.blending, v.blendEquation, v.blendSrc, v.blendDst), x.setTexture2D(v.texture, 1), _.drawElements(_.TRIANGLES, 6, _.UNSIGNED_SHORT, 0))
                            }
                        }
                    y.enable(_.CULL_FACE), y.enable(_.DEPTH_TEST), y.buffers.depth.setMask(!0), y.reset()
                }
            }
        }

        function H(t, e, i, n, r, s, a, o, l) {
            d.call(this, t, e, i, n, r, s, a, o, l), this.needsUpdate = !0
        }

        function Lt(u, d, p, f, m) {
            var g, v, _, y, x, b, w, T, M, E, S, A, P, C, R, L, O;

            function D(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
            }
            var k, I, N, z, B = new St,
                U = new o,
                F = new St;
            this.render = function(t, e, i) {
                if (0 !== t.length) {
                    var n, r, s;
                    void 0 === N && (n = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), r = new Uint16Array([0, 1, 2, 0, 2, 3]), k = d.createBuffer(), I = d.createBuffer(), d.bindBuffer(d.ARRAY_BUFFER, k), d.bufferData(d.ARRAY_BUFFER, n, d.STATIC_DRAW), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, I), d.bufferData(d.ELEMENT_ARRAY_BUFFER, r, d.STATIC_DRAW), n = d.createProgram(), r = d.createShader(d.VERTEX_SHADER), s = d.createShader(d.FRAGMENT_SHADER), d.shaderSource(r, ["precision " + m.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvUV = uvOffset + uv * uvScale;\n\tvec2 alignedPosition = position * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\tfogDepth = - mvPosition.z;\n}"].join("\n")), d.shaderSource(s, ["precision " + m.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvec4 texture = texture2D( map, vUV );\n\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\n\tif ( gl_FragColor.a < alphaTest ) discard;\n\tif ( fogType > 0 ) {\n\t\tfloat fogFactor = 0.0;\n\t\tif ( fogType == 1 ) {\n\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t\t} else {\n\t\t\tconst float LOG2 = 1.442695;\n\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );\n\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\t\t}\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}"].join("\n")), d.compileShader(r), d.compileShader(s), d.attachShader(n, r), d.attachShader(n, s), d.linkProgram(n), N = n, L = d.getAttribLocation(N, "position"), O = d.getAttribLocation(N, "uv"), g = d.getUniformLocation(N, "uvOffset"), v = d.getUniformLocation(N, "uvScale"), _ = d.getUniformLocation(N, "rotation"), y = d.getUniformLocation(N, "scale"), x = d.getUniformLocation(N, "color"), b = d.getUniformLocation(N, "map"), w = d.getUniformLocation(N, "opacity"), T = d.getUniformLocation(N, "modelViewMatrix"), M = d.getUniformLocation(N, "projectionMatrix"), E = d.getUniformLocation(N, "fogType"), S = d.getUniformLocation(N, "fogDensity"), A = d.getUniformLocation(N, "fogNear"), P = d.getUniformLocation(N, "fogFar"), C = d.getUniformLocation(N, "fogColor"), d.getUniformLocation(N, "fogDepth"), R = d.getUniformLocation(N, "alphaTest"), (n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = 8, n.height = 8, (r = n.getContext("2d")).fillStyle = "white", r.fillRect(0, 0, 8, 8), z = new H(n)), p.useProgram(N), p.initAttributes(), p.enableAttribute(L), p.enableAttribute(O), p.disableUnusedAttributes(), p.disable(d.CULL_FACE), p.enable(d.BLEND), d.bindBuffer(d.ARRAY_BUFFER, k), d.vertexAttribPointer(L, 2, d.FLOAT, !1, 16, 0), d.vertexAttribPointer(O, 2, d.FLOAT, !1, 16, 8), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, I), d.uniformMatrix4fv(M, !1, i.projectionMatrix.elements), p.activeTexture(d.TEXTURE0), d.uniform1i(b, 0), r = n = 0, (s = e.fog) ? (d.uniform3f(C, s.color.r, s.color.g, s.color.b), s.isFog ? (d.uniform1f(A, s.near), d.uniform1f(P, s.far), d.uniform1i(E, 1), r = n = 1) : s.isFogExp2 && (d.uniform1f(S, s.density), d.uniform1i(E, 2), r = n = 2)) : (d.uniform1i(E, 0), r = n = 0);
                    for (var a = 0, o = t.length; a < o; a++)(s = t[a]).modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, s.matrixWorld), s.z = -s.modelViewMatrix.elements[14];
                    t.sort(D);
                    for (var l = [], a = 0, o = t.length; a < o; a++) {
                        var h, c = (s = t[a]).material;
                        !1 !== c.visible && (s.onBeforeRender(u, e, i, void 0, c, void 0), d.uniform1f(R, c.alphaTest), d.uniformMatrix4fv(T, !1, s.modelViewMatrix.elements), s.matrixWorld.decompose(B, U, F), l[0] = F.x, l[1] = F.y, h = 0, e.fog && c.fog && (h = r), n !== h && (d.uniform1i(E, h), n = h), null !== c.map ? (d.uniform2f(g, c.map.offset.x, c.map.offset.y), d.uniform2f(v, c.map.repeat.x, c.map.repeat.y)) : (d.uniform2f(g, 0, 0), d.uniform2f(v, 1, 1)), d.uniform1f(w, c.opacity), d.uniform3f(x, c.color.r, c.color.g, c.color.b), d.uniform1f(_, c.rotation), d.uniform2fv(y, l), p.setBlending(c.blending, c.blendEquation, c.blendSrc, c.blendDst, c.blendEquationAlpha, c.blendSrcAlpha, c.blendDstAlpha, c.premultipliedAlpha), p.buffers.depth.setTest(c.depthTest), p.buffers.depth.setMask(c.depthWrite), p.buffers.color.setMask(c.colorWrite), f.setTexture2D(c.map || z, 0), d.drawElements(d.TRIANGLES, 6, d.UNSIGNED_SHORT, 0), s.onAfterRender(u, e, i, void 0, c, void 0))
                    }
                    p.enable(d.CULL_FACE), p.reset()
                }
            }
        }

        function B() {
            Object.defineProperty(this, "id", {
                value: Hs++
            }), this.uuid = es.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
        }

        function U(t) {
            B.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t)
        }

        function F(t) {
            B.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new St, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(t)
        }

        function G(t, e) {
            this.min = void 0 !== t ? t : new St(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new St(-1 / 0, -1 / 0, -1 / 0)
        }

        function V(t, e) {
            this.center = void 0 !== t ? t : new St, this.radius = void 0 !== e ? e : 0
        }

        function j(t, e) {
            this.normal = void 0 !== t ? t : new St(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }

        function Ot(t, e, i, n, r, s) {
            this.planes = [void 0 !== t ? t : new j, void 0 !== e ? e : new j, void 0 !== i ? i : new j, void 0 !== n ? n : new j, void 0 !== r ? r : new j, void 0 !== s ? s : new j]
        }

        function Dt(d, p, t) {
            function f(t, e, i, n, r, s) {
                var a = t.geometry,
                    o = h,
                    l = t.customDepthMaterial;
                return i && (o = c, l = t.customDistanceMaterial), o = l || (l = !1, e.morphTargets && (a && a.isBufferGeometry ? l = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : a && a.isGeometry && (l = a.morphTargets && 0 < a.morphTargets.length)), t.isSkinnedMesh && !1 === e.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t), a = 0, l && (a |= 1), (t = t.isSkinnedMesh && e.skinning) && (a |= 2), o[a]), d.localClippingEnabled && !0 === e.clipShadows && 0 !== e.clippingPlanes.length && (a = o.uuid, l = e.uuid, void 0 === (t = u[a]) && (t = {}, u[a] = t), void 0 === (a = t[l]) && (a = o.clone(), t[l] = a), o = a), o.visible = e.visible, o.wireframe = e.wireframe, o.side = null != e.shadowSide ? e.shadowSide : b[e.side], o.clipShadows = e.clipShadows, o.clippingPlanes = e.clippingPlanes, o.clipIntersection = e.clipIntersection, o.wireframeLinewidth = e.wireframeLinewidth, o.linewidth = e.linewidth, i && o.isMeshDistanceMaterial && (o.referencePosition.copy(n), o.nearDistance = r, o.farDistance = s), o
            }
            var m = new Ot,
                g = new Et,
                v = new X,
                _ = new X(t, t),
                y = new St,
                x = new St,
                h = Array(4),
                c = Array(4),
                u = {},
                b = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                w = [new St(1, 0, 0), new St(-1, 0, 0), new St(0, 0, 1), new St(0, 0, -1), new St(0, 1, 0), new St(0, -1, 0)],
                T = [new St(0, 1, 0), new St(0, 1, 0), new St(0, 1, 0), new St(0, 1, 0), new St(0, 0, 1), new St(0, 0, -1)],
                M = [new At, new At, new At, new At, new At, new At];
            for (t = 0; 4 !== t; ++t) {
                var e = 0 != (1 & t),
                    i = 0 != (2 & t),
                    n = new U({
                        depthPacking: 3201,
                        morphTargets: e,
                        skinning: i
                    });
                h[t] = n, e = new F({
                    morphTargets: e,
                    skinning: i
                }), c[t] = e
            }
            var E = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(t, e, i) {
                if (!1 !== E.enabled && (!1 !== E.autoUpdate || !1 !== E.needsUpdate) && 0 !== t.length) {
                    var n = d.state;
                    n.disable(d.context.BLEND), n.buffers.color.setClear(1, 1, 1, 1), n.buffers.depth.setTest(!0), n.setScissorTest(!1);
                    for (var r = 0, s = t.length; r < s; r++) {
                        var a = t[r],
                            o = a.shadow,
                            l = a && a.isPointLight;
                        if (void 0 === o) console.warn("THREE.WebGLShadowMap:", a, "has no shadow.");
                        else {
                            var h, c, u = o.camera;
                            for (v.copy(o.mapSize), v.min(_), l && (h = v.x, c = v.y, M[0].set(2 * h, c, h, c), M[1].set(0, c, h, c), M[2].set(3 * h, c, h, c), M[3].set(h, c, h, c), M[4].set(3 * h, 0, h, c), M[5].set(h, 0, h, c), v.x *= 4, v.y *= 2), null === o.map && (o.map = new S(v.x, v.y, {
                                    minFilter: 1003,
                                    magFilter: 1003,
                                    format: 1023
                                }), o.map.texture.name = a.name + ".shadowMap", u.updateProjectionMatrix()), o.isSpotLightShadow && o.update(a), h = o.map, c = o.matrix, x.setFromMatrixPosition(a.matrixWorld), u.position.copy(x), l ? (o = 6, c.makeTranslation(-x.x, -x.y, -x.z)) : (o = 1, y.setFromMatrixPosition(a.target.matrixWorld), u.lookAt(y), u.updateMatrixWorld(), c.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), c.multiply(u.projectionMatrix), c.multiply(u.matrixWorldInverse)), d.setRenderTarget(h), d.clear(), a = 0; a < o; a++) l && (y.copy(u.position), y.add(w[a]), u.up.copy(T[a]), u.lookAt(y), u.updateMatrixWorld(), n.viewport(M[a])), g.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), m.setFromMatrix(g),
                                function t(e, i, n, r) {
                                    var s;
                                    if (!1 !== e.visible) {
                                        if (e.layers.test(i.layers) && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || m.intersectsObject(e))) {
                                            e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                                            var a = p.update(e),
                                                o = e.material;
                                            if (Array.isArray(o))
                                                for (var l = a.groups, h = 0, c = l.length; h < c; h++) {
                                                    var u = l[h];
                                                    (s = o[u.materialIndex]) && s.visible && (s = f(e, s, r, x, n.near, n.far), d.renderBufferDirect(n, null, a, s, e, u))
                                                } else o.visible && (s = f(e, o, r, x, n.near, n.far), d.renderBufferDirect(n, null, a, s, e, null))
                                        }
                                        for (a = 0, o = (e = e.children).length; a < o; a++) t(e[a], i, n, r)
                                    }
                                }(e, i, u, l)
                        }
                    }
                    E.needsUpdate = !1
                }
            }
        }

        function kt(a) {
            var o = {};
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), o[t.uuid]
                },
                remove: function(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var e = o[t.uuid];
                    e && (a.deleteBuffer(e.buffer), delete o[t.uuid])
                },
                update: function(t, e) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var i, n, r, s = o[t.uuid];
                    void 0 === s ? (s = t.uuid, i = t.array, n = t.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW, r = a.createBuffer(), a.bindBuffer(e, r), a.bufferData(e, i, n), t.onUploadCallback(), e = a.FLOAT, i instanceof Float32Array ? e = a.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? e = a.UNSIGNED_SHORT : i instanceof Int16Array ? e = a.SHORT : i instanceof Uint32Array ? e = a.UNSIGNED_INT : i instanceof Int32Array ? e = a.INT : i instanceof Int8Array ? e = a.BYTE : i instanceof Uint8Array && (e = a.UNSIGNED_BYTE), o[s] = {
                        buffer: r,
                        type: e,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: t.version
                    }) : s.version < t.version && (r = (i = t).array, n = i.updateRange, a.bindBuffer(e, s.buffer), !1 === i.dynamic ? a.bufferData(e, r, a.STATIC_DRAW) : -1 === n.count ? a.bufferSubData(e, 0, r) : 0 === n.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(e, n.offset * r.BYTES_PER_ELEMENT, r.subarray(n.offset, n.offset + n.count)), n.count = -1), s.version = t.version)
                }
            }
        }

        function W(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || W.DefaultOrder
        }

        function q() {
            this.mask = 1
        }

        function Y() {
            Object.defineProperty(this, "id", {
                value: la++
            }), this.uuid = es.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Y.DefaultUp.clone();
            var t = new St,
                e = new W,
                i = new o,
                n = new St(1, 1, 1);
            e.onChange(function() {
                i.setFromEuler(e, !1)
            }), i.onChange(function() {
                e.setFromQuaternion(i, void 0, !1)
            }), Object.defineProperties(this, {
                position: {
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    enumerable: !0,
                    value: i
                },
                scale: {
                    enumerable: !0,
                    value: n
                },
                modelViewMatrix: {
                    value: new Et
                },
                normalMatrix: {
                    value: new g
                }
            }), this.matrix = new Et, this.matrixWorld = new Et, this.matrixAutoUpdate = Y.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new q, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        function Z() {
            Y.call(this), this.type = "Camera", this.matrixWorldInverse = new Et, this.projectionMatrix = new Et
        }

        function J(t, e, i, n, r, s) {
            Z.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== s ? s : 2e3, this.updateProjectionMatrix()
        }

        function Q(t, e, i, n, r, s) {
            this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new St, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new N, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== s ? s : 0
        }

        function K() {
            Object.defineProperty(this, "id", {
                value: ma += 2
            }), this.uuid = es.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
        }

        function $(t, e, i) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.uuid = es.generateUUID(), this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function() {}, this.version = 0
        }

        function tt(t, e, i) {
            $.call(this, new Int8Array(t), e, i)
        }

        function et(t, e, i) {
            $.call(this, new Uint8Array(t), e, i)
        }

        function it(t, e, i) {
            $.call(this, new Uint8ClampedArray(t), e, i)
        }

        function nt(t, e, i) {
            $.call(this, new Int16Array(t), e, i)
        }

        function rt(t, e, i) {
            $.call(this, new Uint16Array(t), e, i)
        }

        function st(t, e, i) {
            $.call(this, new Int32Array(t), e, i)
        }

        function at(t, e, i) {
            $.call(this, new Uint32Array(t), e, i)
        }

        function ot(t, e, i) {
            $.call(this, new Float32Array(t), e, i)
        }

        function lt(t, e, i) {
            $.call(this, new Float64Array(t), e, i)
        }

        function ht() {
            this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
        }

        function ct(t) {
            if (0 === t.length) return -1 / 0;
            for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
            return e
        }

        function ut() {
            Object.defineProperty(this, "id", {
                value: co += 2
            }), this.uuid = es.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }

        function dt(t, e, i, n, r, s) {
            K.call(this), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: s
            }, this.fromBufferGeometry(new pt(t, e, i, n, r, s)), this.mergeVertices()
        }

        function pt(t, e, i, n, r, s) {
            function a(t, e, i, n, r, s, a, o, l, h, c) {
                var u = s / l,
                    d = a / h,
                    p = s / 2,
                    f = a / 2,
                    m = o / 2;
                a = l + 1;
                for (var g = h + 1, v = s = 0, _ = new St, y = 0; y < g; y++)
                    for (var x = y * d - f, b = 0; b < a; b++) _[t] = (b * u - p) * n, _[e] = x * r, _[i] = m, M.push(_.x, _.y, _.z), _[t] = 0, _[e] = 0, _[i] = 0 < o ? 1 : -1, E.push(_.x, _.y, _.z), S.push(b / l), S.push(1 - y / h), s += 1;
                for (y = 0; y < h; y++)
                    for (b = 0; b < l; b++) t = A + b + a * (y + 1), e = A + (b + 1) + a * (y + 1), i = A + (b + 1) + a * y, T.push(A + b + a * y, t, i), T.push(t, e, i), v += 6;
                w.addGroup(P, v, c), P += v, A += s
            }
            ut.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: s
            };
            var w = this;
            t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, s = Math.floor(s) || 1;
            var T = [],
                M = [],
                E = [],
                S = [],
                A = 0,
                P = 0;
            a("z", "y", "x", -1, -1, i, e, t, s, r, 0), a("z", "y", "x", 1, -1, i, e, -t, s, r, 1), a("x", "z", "y", 1, 1, t, i, e, n, s, 2), a("x", "z", "y", 1, -1, t, i, -e, n, s, 3), a("x", "y", "z", 1, -1, t, e, i, n, r, 4), a("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(T), this.addAttribute("position", new ot(M, 3)), this.addAttribute("normal", new ot(E, 3)), this.addAttribute("uv", new ot(S, 2))
        }

        function ft(t, e, i, n) {
            K.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            }, this.fromBufferGeometry(new mt(t, e, i, n)), this.mergeVertices()
        }

        function mt(t, e, i, n) {
            ut.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            };
            var r = (t = t || 1) / 2,
                s = (e = e || 1) / 2,
                a = (i = Math.floor(i) || 1) + 1,
                o = (n = Math.floor(n) || 1) + 1,
                l = t / i,
                h = e / n,
                c = [],
                u = [],
                d = [],
                p = [];
            for (t = 0; t < o; t++) {
                var f = t * h - s;
                for (e = 0; e < a; e++) u.push(e * l - r, -f, 0), d.push(0, 0, 1), p.push(e / i), p.push(1 - t / n)
            }
            for (t = 0; t < n; t++)
                for (e = 0; e < i; e++) r = e + a * (t + 1), s = e + 1 + a * (t + 1), o = e + 1 + a * t, c.push(e + a * t, r, o), c.push(r, s, o);
            this.setIndex(c), this.addAttribute("position", new ot(u, 3)), this.addAttribute("normal", new ot(d, 3)), this.addAttribute("uv", new ot(p, 2))
        }

        function gt(t) {
            B.call(this), this.type = "MeshBasicMaterial", this.color = new N(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function vt(t) {
            B.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, (this.index0AttributeName = void 0) !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }

        function _t(t, e) {
            this.origin = void 0 !== t ? t : new St, this.direction = void 0 !== e ? e : new St
        }

        function yt(t, e) {
            this.start = void 0 !== t ? t : new St, this.end = void 0 !== e ? e : new St
        }

        function xt(t, e, i) {
            this.a = void 0 !== t ? t : new St, this.b = void 0 !== e ? e : new St, this.c = void 0 !== i ? i : new St
        }

        function bt(t, e) {
            Y.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ut, this.material = void 0 !== e ? e : new gt({
                color: 16777215 * Math.random()
            }), this.drawMode = 0, this.updateMorphTargets()
        }

        function It(r, i, s, n) {
            function a(t, e) {
                i.buffers.color.setClear(t.r, t.g, t.b, e, n)
            }
            var o, l, h, c = new N(0),
                u = 0;
            return {
                getClearColor: function() {
                    return c
                },
                setClearColor: function(t, e) {
                    c.set(t), a(c, u = void 0 !== e ? e : 1)
                },
                getClearAlpha: function() {
                    return u
                },
                setClearAlpha: function(t) {
                    a(c, u = t)
                },
                render: function(t, e, i, n) {
                    null === (e = e.background) ? a(c, u) : e && e.isColor && (a(e, 1), n = !0), (r.autoClear || n) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil), e && e.isCubeTexture ? (void 0 === h && ((h = new bt(new pt(1, 1, 1), new vt({
                        uniforms: ys.cube.uniforms,
                        vertexShader: ys.cube.vertexShader,
                        fragmentShader: ys.cube.fragmentShader,
                        side: 1,
                        depthTest: !0,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"), h.geometry.removeAttribute("uv"), h.onBeforeRender = function(t, e, i) {
                        this.matrixWorld.copyPosition(i.matrixWorld)
                    }, s.update(h.geometry)), h.material.uniforms.tCube.value = e, t.push(h, h.geometry, h.material, 0, null)) : e && e.isTexture && (void 0 === o && (o = new J(-1, 1, 1, -1, 0, 1), l = new bt(new mt(2, 2), new gt({
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), s.update(l.geometry)), l.material.map = e, r.renderBufferDirect(o, null, l.geometry, l.material, l, null))
                }
            }
        }

        function wt(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Tt(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Mt() {
            var a = [],
                o = 0,
                l = [],
                h = [];
            return {
                opaque: l,
                transparent: h,
                init: function() {
                    o = 0, l.length = 0, h.length = 0
                },
                push: function(t, e, i, n, r) {
                    var s = a[o];
                    void 0 === s ? (s = {
                        id: t.id,
                        object: t,
                        geometry: e,
                        material: i,
                        program: i.program,
                        renderOrder: t.renderOrder,
                        z: n,
                        group: r
                    }, a[o] = s) : (s.id = t.id, s.object = t, s.geometry = e, s.material = i, s.program = i.program, s.renderOrder = t.renderOrder, s.z = n, s.group = r), (!0 === i.transparent ? h : l).push(s), o++
                },
                sort: function() {
                    1 < l.length && l.sort(wt), 1 < h.length && h.sort(Tt)
                }
            }
        }

        function Nt() {
            var i = {};
            return {
                get: function(t, e) {
                    return t = t.id + "," + e.id, void 0 === (e = i[t]) && (e = new Mt, i[t] = e), e
                },
                dispose: function() {
                    i = {}
                }
            }
        }

        function zt(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function Bt(h) {
            var c = {},
                u = new Float32Array(8);
            return {
                update: function(t, e, i, n) {
                    var r = t.morphTargetInfluences,
                        s = r.length;
                    if (void 0 === (t = c[e.id])) {
                        t = [];
                        for (var a = 0; a < s; a++) t[a] = [a, 0];
                        c[e.id] = t
                    }
                    var o = i.morphTargets && e.morphAttributes.position;
                    for (i = i.morphNormals && e.morphAttributes.normal, a = 0; a < s; a++) {
                        var l = t[a];
                        0 !== l[1] && (o && e.removeAttribute("morphTarget" + a), i && e.removeAttribute("morphNormal" + a))
                    }
                    for (a = 0; a < s; a++)(l = t[a])[0] = a, l[1] = r[a];
                    for (t.sort(zt), a = 0; a < 8; a++)(l = t[a]) && (r = l[0], l = l[1]) ? (o && e.addAttribute("morphTarget" + a, o[r]), i && e.addAttribute("morphNormal" + a, i[r]), u[a] = l) : u[a] = 0;
                    n.getUniforms().setValue(h, "morphTargetInfluences", u)
                }
            }
        }

        function Ut(r, s, a) {
            var o, l, h;
            this.setMode = function(t) {
                o = t
            }, this.setIndex = function(t) {
                l = t.type, h = t.bytesPerElement
            }, this.render = function(t, e) {
                r.drawElements(o, e, l, t * h), a.calls++, a.vertices += e, o === r.TRIANGLES ? a.faces += e / 3 : o === r.POINTS && (a.points += e)
            }, this.renderInstances = function(t, e, i) {
                var n = s.get("ANGLE_instanced_arrays");
                null === n ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (n.drawElementsInstancedANGLE(o, i, l, e * h, t.maxInstancedCount), a.calls++, a.vertices += i * t.maxInstancedCount, o === r.TRIANGLES ? a.faces += t.maxInstancedCount * i / 3 : o === r.POINTS && (a.points += t.maxInstancedCount * i))
            }
        }

        function Ft(s, a, o) {
            var l;
            this.setMode = function(t) {
                l = t
            }, this.render = function(t, e) {
                s.drawArrays(l, t, e), o.calls++, o.vertices += e, l === s.TRIANGLES ? o.faces += e / 3 : l === s.POINTS && (o.points += e)
            }, this.renderInstances = function(t, e, i) {
                var n, r = a.get("ANGLE_instanced_arrays");
                null === r ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : ((n = t.attributes.position).isInterleavedBufferAttribute ? (i = n.data.count, r.drawArraysInstancedANGLE(l, 0, i, t.maxInstancedCount)) : r.drawArraysInstancedANGLE(l, e, i, t.maxInstancedCount), o.calls++, o.vertices += i * t.maxInstancedCount, l === s.TRIANGLES ? o.faces += t.maxInstancedCount * i / 3 : l === s.POINTS && (o.points += t.maxInstancedCount * i))
            }
        }

        function Ht(l, h, n) {
            function r(t) {
                t = t.target;
                var e, i = s[t.id];
                for (e in null !== i.index && h.remove(i.index), i.attributes) h.remove(i.attributes[e]);
                t.removeEventListener("dispose", r), delete s[t.id], (e = c[t.id]) && (h.remove(e), delete c[t.id]), (e = c[i.id]) && (h.remove(e), delete c[i.id]), n.geometries--
            }
            var s = {},
                c = {};
            return {
                get: function(t, e) {
                    var i = s[e.id];
                    return i || (e.addEventListener("dispose", r), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new ut).setFromObject(t)), i = e._bufferGeometry), s[e.id] = i, n.geometries++, i)
                },
                update: function(t) {
                    var e, i = t.index,
                        n = t.attributes;
                    for (e in null !== i && h.update(i, l.ELEMENT_ARRAY_BUFFER), n) h.update(n[e], l.ARRAY_BUFFER);
                    for (e in t = t.morphAttributes)
                        for (var i = t[e], n = 0, r = i.length; n < r; n++) h.update(i[n], l.ARRAY_BUFFER)
                },
                getWireframeAttribute: function(t) {
                    var e = c[t.id];
                    if (e) return e;
                    e = [];
                    var i = t.index,
                        n = t.attributes;
                    if (null !== i)
                        for (var r = i.array, s = 0, a = r.length; s < a; s += 3) {
                            var o = r[s + 0],
                                n = r[s + 1],
                                i = r[s + 2];
                            e.push(o, n, n, i, i, o)
                        } else
                            for (s = 0, a = (r = n.position.array).length / 3 - 1; s < a; s += 3) o = s + 0, n = s + 1, i = s + 2, e.push(o, n, n, i, i, o);
                    return e = new(65535 < ct(e) ? at : rt)(e, 1), h.update(e, l.ELEMENT_ARRAY_BUFFER), c[t.id] = e
                }
            }
        }

        function Gt() {
            var i = {};
            return {
                get: function(t) {
                    if (void 0 !== i[t.id]) return i[t.id];
                    switch (t.type) {
                        case "DirectionalLight":
                            var e = {
                                direction: new St,
                                color: new N,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new X
                            };
                            break;
                        case "SpotLight":
                            e = {
                                position: new St,
                                direction: new St,
                                color: new N,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new X
                            };
                            break;
                        case "PointLight":
                            e = {
                                position: new St,
                                color: new N,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new X,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            };
                            break;
                        case "HemisphereLight":
                            e = {
                                direction: new St,
                                skyColor: new N,
                                groundColor: new N
                            };
                            break;
                        case "RectAreaLight":
                            e = {
                                color: new N,
                                position: new St,
                                halfWidth: new St,
                                halfHeight: new St
                            }
                    }
                    return i[t.id] = e
                }
            }
        }

        function Vt() {
            var y = new Gt,
                x = {
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                },
                b = new St,
                w = new Et,
                T = new Et;
            return {
                setup: function(t, e, i) {
                    for (var n = 0, r = 0, s = 0, a = 0, o = 0, l = 0, h = 0, c = 0, u = i.matrixWorldInverse, d = 0, p = t.length; d < p; d++) {
                        var f = t[d],
                            m = f.color,
                            g = f.intensity,
                            v = f.distance,
                            _ = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
                        f.isAmbientLight ? (n += m.r * g, r += m.g * g, s += m.b * g) : f.isDirectionalLight ? ((i = y.get(f)).color.copy(f.color).multiplyScalar(f.intensity), i.direction.setFromMatrixPosition(f.matrixWorld), b.setFromMatrixPosition(f.target.matrixWorld), i.direction.sub(b), i.direction.transformDirection(u), (i.shadow = f.castShadow) && (m = f.shadow, i.shadowBias = m.bias, i.shadowRadius = m.radius, i.shadowMapSize = m.mapSize), x.directionalShadowMap[a] = _, x.directionalShadowMatrix[a] = f.shadow.matrix, x.directional[a] = i, a++) : f.isSpotLight ? ((i = y.get(f)).position.setFromMatrixPosition(f.matrixWorld), i.position.applyMatrix4(u), i.color.copy(m).multiplyScalar(g), i.distance = v, i.direction.setFromMatrixPosition(f.matrixWorld), b.setFromMatrixPosition(f.target.matrixWorld), i.direction.sub(b), i.direction.transformDirection(u), i.coneCos = Math.cos(f.angle), i.penumbraCos = Math.cos(f.angle * (1 - f.penumbra)), i.decay = 0 === f.distance ? 0 : f.decay, (i.shadow = f.castShadow) && (m = f.shadow, i.shadowBias = m.bias, i.shadowRadius = m.radius, i.shadowMapSize = m.mapSize), x.spotShadowMap[l] = _, x.spotShadowMatrix[l] = f.shadow.matrix, x.spot[l] = i, l++) : f.isRectAreaLight ? ((i = y.get(f)).color.copy(m).multiplyScalar(g), i.position.setFromMatrixPosition(f.matrixWorld), i.position.applyMatrix4(u), T.identity(), w.copy(f.matrixWorld), w.premultiply(u), T.extractRotation(w), i.halfWidth.set(.5 * f.width, 0, 0), i.halfHeight.set(0, .5 * f.height, 0), i.halfWidth.applyMatrix4(T), i.halfHeight.applyMatrix4(T), x.rectArea[h] = i, h++) : f.isPointLight ? ((i = y.get(f)).position.setFromMatrixPosition(f.matrixWorld), i.position.applyMatrix4(u), i.color.copy(f.color).multiplyScalar(f.intensity), i.distance = f.distance, i.decay = 0 === f.distance ? 0 : f.decay, (i.shadow = f.castShadow) && (m = f.shadow, i.shadowBias = m.bias, i.shadowRadius = m.radius, i.shadowMapSize = m.mapSize, i.shadowCameraNear = m.camera.near, i.shadowCameraFar = m.camera.far), x.pointShadowMap[o] = _, x.pointShadowMatrix[o] = f.shadow.matrix, x.point[o] = i, o++) : f.isHemisphereLight && ((i = y.get(f)).direction.setFromMatrixPosition(f.matrixWorld), i.direction.transformDirection(u), i.direction.normalize(), i.skyColor.copy(f.color).multiplyScalar(g), i.groundColor.copy(f.groundColor).multiplyScalar(g), x.hemi[c] = i, c++)
                    }
                    x.ambient[0] = n, x.ambient[1] = r, x.ambient[2] = s, x.directional.length = a, x.spot.length = l, x.rectArea.length = h, x.point.length = o, x.hemi.length = c, x.hash = a + "," + o + "," + l + "," + h + "," + c + "," + e.length
                },
                state: x
            }
        }

        function jt(r, s) {
            var a = {};
            return {
                update: function(t) {
                    var e = s.frame,
                        i = t.geometry,
                        n = r.get(t, i);
                    return a[n.id] !== e && (i.isGeometry && n.updateFromObject(t), r.update(n), a[n.id] = e), n
                },
                dispose: function() {
                    a = {}
                }
            }
        }

        function Wt(t, e, i) {
            var n = t.createShader(e);
            return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), function(t) {
                t = t.split("\n");
                for (var e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
                return t.join("\n")
            }(i)), n
        }

        function Xt(t) {
            switch (t) {
                case 3e3:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw Error("unsupported encoding: " + t)
            }
        }

        function qt(t, e) {
            return "vec4 " + t + "( vec4 value ) { return " + (e = Xt(e))[0] + "ToLinear" + e[1] + "; }"
        }

        function Yt(t) {
            return "" !== t
        }

        function Zt(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        }

        function Jt(t) {
            return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(t, e) {
                if (void 0 === (t = _s[e])) throw Error("Can not resolve #include <" + e + ">");
                return Jt(t)
            })
        }

        function Qt(t) {
            return t.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, i, n) {
                for (t = "", e = parseInt(e); e < parseInt(i); e++) t += n.replace(/\[ i \]/g, "[ " + e + " ]");
                return t
            })
        }

        function Kt(t, e, i, n, r, s) {
            var a = t.context,
                o = n.defines,
                l = r.vertexShader,
                h = r.fragmentShader,
                c = "SHADOWMAP_TYPE_BASIC";
            1 === s.shadowMapType ? c = "SHADOWMAP_TYPE_PCF" : 2 === s.shadowMapType && (c = "SHADOWMAP_TYPE_PCF_SOFT");
            var u = "ENVMAP_TYPE_CUBE",
                d = "ENVMAP_MODE_REFLECTION",
                p = "ENVMAP_BLENDING_MULTIPLY";
            if (s.envMap) {
                switch (n.envMap.mapping) {
                    case 301:
                    case 302:
                        u = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        u = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case 303:
                    case 304:
                        u = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case 305:
                        u = "ENVMAP_TYPE_SPHERE"
                }
                switch (n.envMap.mapping) {
                    case 302:
                    case 304:
                        d = "ENVMAP_MODE_REFRACTION"
                }
                switch (n.combine) {
                    case 0:
                        p = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        p = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        p = "ENVMAP_BLENDING_ADD"
                }
            }
            var f, m, g, v, _, y = 0 < t.gammaFactor ? t.gammaFactor : 1,
                m = (f = n.extensions, m = s, g = e, [(f = f || {}).derivatives || m.envMapCubeUV || m.bumpMap || m.normalMap || m.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (f.fragDepth || m.logarithmicDepthBuffer) && g.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", f.drawBuffers && g.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (f.shaderTextureLOD || m.envMap) && g.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Yt).join("\n")),
                g = function(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        !1 !== n && i.push("#define " + e + " " + n)
                    }
                    return i.join("\n")
                }(o),
                x = a.createProgram();
            return n.isRawShaderMaterial ? (0 < (o = [g].filter(Yt).join("\n")).length && (o += "\n"), 0 < (e = [m, g].filter(Yt).join("\n")).length && (e += "\n")) : (o = ["precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, g, s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + s.maxBones, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + d : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.displacementMap && s.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexColors ? "#define USE_COLOR" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.skinning ? "#define USE_SKINNING" : "", s.useVertexTexture ? "#define BONE_TEXTURE" : "", s.morphTargets ? "#define USE_MORPHTARGETS" : "", s.morphNormals && !1 === s.flatShading ? "#define USE_MORPHNORMALS" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + s.numClippingPlanes, s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + c : "", s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Yt).join("\n"), e = [m, "precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, g, s.alphaTest ? "#define ALPHATEST " + s.alphaTest : "", "#define GAMMA_FACTOR " + y, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + u : "", s.envMap ? "#define " + d : "", s.envMap ? "#define " + p : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexColors ? "#define USE_COLOR" : "", s.gradientMap ? "#define USE_GRADIENTMAP" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + s.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (s.numClippingPlanes - s.numClipIntersection), s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + c : "", s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", s.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", s.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== s.toneMapping ? "#define TONE_MAPPING" : "", 0 !== s.toneMapping ? _s.tonemapping_pars_fragment : "", 0 !== s.toneMapping ? function(t, e) {
                switch (e) {
                    case 1:
                        e = "Linear";
                        break;
                    case 2:
                        e = "Reinhard";
                        break;
                    case 3:
                        e = "Uncharted2";
                        break;
                    case 4:
                        e = "OptimizedCineon";
                        break;
                    default:
                        throw Error("unsupported toneMapping: " + e)
                }
                return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
            }("toneMapping", s.toneMapping) : "", s.dithering ? "#define DITHERING" : "", s.outputEncoding || s.mapEncoding || s.envMapEncoding || s.emissiveMapEncoding ? _s.encodings_pars_fragment : "", s.mapEncoding ? qt("mapTexelToLinear", s.mapEncoding) : "", s.envMapEncoding ? qt("envMapTexelToLinear", s.envMapEncoding) : "", s.emissiveMapEncoding ? qt("emissiveMapTexelToLinear", s.emissiveMapEncoding) : "", s.outputEncoding ? (g = "linearToOutputTexel", y = s.outputEncoding, "vec4 " + g + "( vec4 value ) { return LinearTo" + (y = Xt(y))[0] + y[1] + "; }") : "", s.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Yt).join("\n")), l = Zt(l = Jt(l), s), h = Zt(h = Jt(h), s), n.isShaderMaterial || (l = Qt(l), h = Qt(h)), h = e + h, l = Wt(a, a.VERTEX_SHADER, o + l), h = Wt(a, a.FRAGMENT_SHADER, h), a.attachShader(x, l), a.attachShader(x, h), void 0 !== n.index0AttributeName ? a.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === s.morphTargets && a.bindAttribLocation(x, 0, "position"), a.linkProgram(x), s = a.getProgramInfoLog(x).trim(), r = a.getShaderInfoLog(l).trim(), c = a.getShaderInfoLog(h).trim(), !(d = u = !0) === a.getProgramParameter(x, a.LINK_STATUS) ? (u = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(x, a.VALIDATE_STATUS), "gl.getProgramInfoLog", s, r, c)) : "" !== s ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", s) : "" !== r && "" !== c || (d = !1), d && (this.diagnostics = {
                runnable: u,
                material: n,
                programLog: s,
                vertexShader: {
                    log: r,
                    prefix: o
                },
                fragmentShader: {
                    log: c,
                    prefix: e
                }
            }), a.deleteShader(l), a.deleteShader(h), this.getUniforms = function() {
                return void 0 === v && (v = new Ct(a, x, t)), v
            }, this.getAttributes = function() {
                if (void 0 === _) {
                    for (var t = {}, e = a.getProgramParameter(x, a.ACTIVE_ATTRIBUTES), i = 0; i < e; i++) {
                        var n = a.getActiveAttrib(x, i).name;
                        t[n] = a.getAttribLocation(x, n)
                    }
                    _ = t
                }
                return _
            }, this.destroy = function() {
                a.deleteProgram(x), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                },
                attributes: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.id = Co++, this.code = i, this.usedTimes = 1, this.program = x, this.vertexShader = l, this.fragmentShader = h, this
        }

        function $t(u, l, d) {
            function p(t, e) {
                var i;
                return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = 3e3, 3e3 === i && e && (i = 3007), i
            }
            var h = [],
                f = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow"
                },
                r = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
            this.getParameters = function(t, e, i, n, r, s, a) {
                var o, l, h = f[t.type];
                l = a.isSkinnedMesh ? (l = a.skeleton.bones, d.floatVertexTextures ? 1024 : (o = Math.min(Math.floor((d.maxVertexUniforms - 20) / 4), l.length)) < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " + o + "."), 0) : o) : 0, o = d.precision, null === t.precision || (o = d.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", o, "instead.");
                var c = u.getRenderTarget();
                return {
                    shaderID: h,
                    precision: o,
                    supportsVertexTextures: d.vertexTextures,
                    outputEncoding: p(c ? c.texture : null, u.gammaOutput),
                    map: !!t.map,
                    mapEncoding: p(t.map, u.gammaInput),
                    envMap: !!t.envMap,
                    envMapMode: t.envMap && t.envMap.mapping,
                    envMapEncoding: p(t.envMap, u.gammaInput),
                    envMapCubeUV: !!t.envMap && (306 === t.envMap.mapping || 307 === t.envMap.mapping),
                    lightMap: !!t.lightMap,
                    aoMap: !!t.aoMap,
                    emissiveMap: !!t.emissiveMap,
                    emissiveMapEncoding: p(t.emissiveMap, u.gammaInput),
                    bumpMap: !!t.bumpMap,
                    normalMap: !!t.normalMap,
                    displacementMap: !!t.displacementMap,
                    roughnessMap: !!t.roughnessMap,
                    metalnessMap: !!t.metalnessMap,
                    specularMap: !!t.specularMap,
                    alphaMap: !!t.alphaMap,
                    gradientMap: !!t.gradientMap,
                    combine: t.combine,
                    vertexColors: t.vertexColors,
                    fog: !!n,
                    useFog: t.fog,
                    fogExp: n && n.isFogExp2,
                    flatShading: t.flatShading,
                    sizeAttenuation: t.sizeAttenuation,
                    logarithmicDepthBuffer: d.logarithmicDepthBuffer,
                    skinning: t.skinning && 0 < l,
                    maxBones: l,
                    useVertexTexture: d.floatVertexTextures,
                    morphTargets: t.morphTargets,
                    morphNormals: t.morphNormals,
                    maxMorphTargets: u.maxMorphTargets,
                    maxMorphNormals: u.maxMorphNormals,
                    numDirLights: e.directional.length,
                    numPointLights: e.point.length,
                    numSpotLights: e.spot.length,
                    numRectAreaLights: e.rectArea.length,
                    numHemiLights: e.hemi.length,
                    numClippingPlanes: r,
                    numClipIntersection: s,
                    dithering: t.dithering,
                    shadowMapEnabled: u.shadowMap.enabled && a.receiveShadow && 0 < i.length,
                    shadowMapType: u.shadowMap.type,
                    toneMapping: u.toneMapping,
                    physicallyCorrectLights: u.physicallyCorrectLights,
                    premultipliedAlpha: t.premultipliedAlpha,
                    alphaTest: t.alphaTest,
                    doubleSided: 2 === t.side,
                    flipSided: 1 === t.side,
                    depthPacking: void 0 !== t.depthPacking && t.depthPacking
                }
            }, this.getProgramCode = function(t, e) {
                var i = [];
                if (e.shaderID ? i.push(e.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines)
                    for (var n in t.defines) i.push(n), i.push(t.defines[n]);
                for (n = 0; n < r.length; n++) i.push(e[r[n]]);
                return i.push(t.onBeforeCompile.toString()), i.push(u.gammaOutput), i.join()
            }, this.acquireProgram = function(t, e, i, n) {
                for (var r, s = 0, a = h.length; s < a; s++) {
                    var o = h[s];
                    if (o.code === n) {
                        ++(r = o).usedTimes;
                        break
                    }
                }
                return void 0 === r && (r = new Kt(u, l, n, t, e, i), h.push(r)), r
            }, this.releaseProgram = function(t) {
                var e;
                0 == --t.usedTimes && (e = h.indexOf(t), h[e] = h[h.length - 1], h.pop(), t.destroy())
            }, this.programs = h
        }

        function te(p, n, f, m, g, v, _, h) {
            function y(t, e) {
                if (t.width > e || t.height > e) {
                    e /= Math.max(t.width, t.height);
                    var i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return i.width = Math.floor(t.width * e), i.height = Math.floor(t.height * e), i.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t), i
                }
                return t
            }

            function x(t) {
                return es.isPowerOfTwo(t.width) && es.isPowerOfTwo(t.height)
            }

            function b(t, e) {
                return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
            }

            function r(t) {
                return 1003 === t || 1004 === t || 1005 === t ? p.NEAREST : p.LINEAR
            }

            function w(t) {
                (t = t.target).removeEventListener("dispose", w);
                t: {
                    var e = m.get(t);
                    if (t.image && e.__image__webglTextureCube) p.deleteTexture(e.__image__webglTextureCube);
                    else {
                        if (void 0 === e.__webglInit) break t;
                        p.deleteTexture(e.__webglTexture)
                    }
                    m.remove(t)
                }
                t.isVideoTexture && delete d[t.id], _.textures--
            }

            function a(t) {
                (t = t.target).removeEventListener("dispose", a);
                var e = m.get(t),
                    i = m.get(t.texture);
                if (t) {
                    if (void 0 !== i.__webglTexture && p.deleteTexture(i.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                        for (i = 0; i < 6; i++) p.deleteFramebuffer(e.__webglFramebuffer[i]), e.__webglDepthbuffer && p.deleteRenderbuffer(e.__webglDepthbuffer[i]);
                    else p.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && p.deleteRenderbuffer(e.__webglDepthbuffer);
                    m.remove(t.texture), m.remove(t)
                }
                _.textures--
            }

            function o(t, e) {
                var i, n, r = m.get(t);
                if (t.isVideoTexture && (i = t.id, n = h.frame, d[i] !== n && (d[i] = n, t.update())), 0 < t.version && r.__version !== t.version)
                    if (void 0 === (i = t.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t);
                    else {
                        if (!1 !== i.complete) {
                            void 0 === r.__webglInit && (r.__webglInit = !0, t.addEventListener("dispose", w), r.__webglTexture = p.createTexture(), _.textures++), f.activeTexture(p.TEXTURE0 + e), f.bindTexture(p.TEXTURE_2D, r.__webglTexture), p.pixelStorei(p.UNPACK_FLIP_Y_WEBGL, t.flipY), p.pixelStorei(p.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), p.pixelStorei(p.UNPACK_ALIGNMENT, t.unpackAlignment);
                            var s = y(t.image, g.maxTextureSize);
                            (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter) && !1 === x(s) && (s = (e = s) instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap ? ((i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = es.floorPowerOfTwo(e.width), i.height = es.floorPowerOfTwo(e.height), i.getContext("2d").drawImage(e, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + i.width + "x" + i.height, e), i) : e), e = x(s), i = v.convert(t.format), n = v.convert(t.type), T(p.TEXTURE_2D, t, e);
                            var a = t.mipmaps;
                            if (t.isDepthTexture) {
                                if (a = p.DEPTH_COMPONENT, 1015 === t.type) {
                                    if (!u) throw Error("Float Depth Texture only supported in WebGL2.0");
                                    a = p.DEPTH_COMPONENT32F
                                } else u && (a = p.DEPTH_COMPONENT16);
                                1026 === t.format && a === p.DEPTH_COMPONENT && 1012 !== t.type && 1014 !== t.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = 1012, n = v.convert(t.type)), 1027 === t.format && (a = p.DEPTH_STENCIL, 1020 !== t.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = 1020, n = v.convert(t.type))), f.texImage2D(p.TEXTURE_2D, 0, a, s.width, s.height, 0, i, n, null)
                            } else if (t.isDataTexture)
                                if (0 < a.length && e) {
                                    for (var o = 0, l = a.length; o < l; o++) s = a[o], f.texImage2D(p.TEXTURE_2D, o, i, s.width, s.height, 0, i, n, s.data);
                                    t.generateMipmaps = !1
                                } else f.texImage2D(p.TEXTURE_2D, 0, i, s.width, s.height, 0, i, n, s.data);
                            else if (t.isCompressedTexture)
                                for (o = 0, l = a.length; o < l; o++) s = a[o], 1023 !== t.format && 1022 !== t.format ? -1 < f.getCompressedTextureFormats().indexOf(i) ? f.compressedTexImage2D(p.TEXTURE_2D, o, i, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : f.texImage2D(p.TEXTURE_2D, o, i, s.width, s.height, 0, i, n, s.data);
                            else if (0 < a.length && e) {
                                for (o = 0, l = a.length; o < l; o++) s = a[o], f.texImage2D(p.TEXTURE_2D, o, i, i, n, s);
                                t.generateMipmaps = !1
                            } else f.texImage2D(p.TEXTURE_2D, 0, i, i, n, s);
                            return b(t, e) && p.generateMipmap(p.TEXTURE_2D), r.__version = t.version, void(t.onUpdate && t.onUpdate(t))
                        }
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t)
                    }
                f.activeTexture(p.TEXTURE0 + e), f.bindTexture(p.TEXTURE_2D, r.__webglTexture)
            }

            function T(t, e, i) {
                i ? (p.texParameteri(t, p.TEXTURE_WRAP_S, v.convert(e.wrapS)), p.texParameteri(t, p.TEXTURE_WRAP_T, v.convert(e.wrapT)), p.texParameteri(t, p.TEXTURE_MAG_FILTER, v.convert(e.magFilter)), p.texParameteri(t, p.TEXTURE_MIN_FILTER, v.convert(e.minFilter))) : (p.texParameteri(t, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(t, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), 1001 === e.wrapS && 1001 === e.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", e), p.texParameteri(t, p.TEXTURE_MAG_FILTER, r(e.magFilter)), p.texParameteri(t, p.TEXTURE_MIN_FILTER, r(e.minFilter)), 1003 !== e.minFilter && 1006 !== e.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", e)), !(i = n.get("EXT_texture_filter_anisotropic")) || 1015 === e.type && null === n.get("OES_texture_float_linear") || 1016 === e.type && null === n.get("OES_texture_half_float_linear") || !(1 < e.anisotropy || m.get(e).__currentAnisotropy) || (p.texParameterf(t, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, g.getMaxAnisotropy())), m.get(e).__currentAnisotropy = e.anisotropy)
            }

            function l(t, e, i, n) {
                var r = v.convert(e.texture.format),
                    s = v.convert(e.texture.type);
                f.texImage2D(n, 0, r, e.width, e.height, 0, r, s, null), p.bindFramebuffer(p.FRAMEBUFFER, t), p.framebufferTexture2D(p.FRAMEBUFFER, i, n, m.get(e.texture).__webglTexture, 0), p.bindFramebuffer(p.FRAMEBUFFER, null)
            }

            function c(t, e) {
                p.bindRenderbuffer(p.RENDERBUFFER, t), e.depthBuffer && !e.stencilBuffer ? (p.renderbufferStorage(p.RENDERBUFFER, p.DEPTH_COMPONENT16, e.width, e.height), p.framebufferRenderbuffer(p.FRAMEBUFFER, p.DEPTH_ATTACHMENT, p.RENDERBUFFER, t)) : e.depthBuffer && e.stencilBuffer ? (p.renderbufferStorage(p.RENDERBUFFER, p.DEPTH_STENCIL, e.width, e.height), p.framebufferRenderbuffer(p.FRAMEBUFFER, p.DEPTH_STENCIL_ATTACHMENT, p.RENDERBUFFER, t)) : p.renderbufferStorage(p.RENDERBUFFER, p.RGBA4, e.width, e.height), p.bindRenderbuffer(p.RENDERBUFFER, null)
            }
            var u = "undefined" != typeof WebGL2RenderingContext && p instanceof WebGL2RenderingContext,
                d = {};
            this.setTexture2D = o, this.setTextureCube = function(t, e) {
                var i = m.get(t);
                if (6 === t.image.length)
                    if (0 < t.version && i.__version !== t.version) {
                        i.__image__webglTextureCube || (t.addEventListener("dispose", w), i.__image__webglTextureCube = p.createTexture(), _.textures++), f.activeTexture(p.TEXTURE0 + e), f.bindTexture(p.TEXTURE_CUBE_MAP, i.__image__webglTextureCube), p.pixelStorei(p.UNPACK_FLIP_Y_WEBGL, t.flipY), e = t && t.isCompressedTexture;
                        for (var n = t.image[0] && t.image[0].isDataTexture, r = [], s = 0; s < 6; s++) r[s] = e || n ? n ? t.image[s].image : t.image[s] : y(t.image[s], g.maxCubemapSize);
                        var a = x(r[0]),
                            o = v.convert(t.format),
                            l = v.convert(t.type);
                        for (T(p.TEXTURE_CUBE_MAP, t, a), s = 0; s < 6; s++)
                            if (e)
                                for (var h, c = r[s].mipmaps, u = 0, d = c.length; u < d; u++) h = c[u], 1023 !== t.format && 1022 !== t.format ? -1 < f.getCompressedTextureFormats().indexOf(o) ? f.compressedTexImage2D(p.TEXTURE_CUBE_MAP_POSITIVE_X + s, u, o, h.width, h.height, 0, h.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : f.texImage2D(p.TEXTURE_CUBE_MAP_POSITIVE_X + s, u, o, h.width, h.height, 0, o, l, h.data);
                            else n ? f.texImage2D(p.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, o, r[s].width, r[s].height, 0, o, l, r[s].data) : f.texImage2D(p.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, o, o, l, r[s]);
                        b(t, a) && p.generateMipmap(p.TEXTURE_CUBE_MAP), i.__version = t.version, t.onUpdate && t.onUpdate(t)
                    } else f.activeTexture(p.TEXTURE0 + e), f.bindTexture(p.TEXTURE_CUBE_MAP, i.__image__webglTextureCube)
            }, this.setTextureCubeDynamic = function(t, e) {
                f.activeTexture(p.TEXTURE0 + e), f.bindTexture(p.TEXTURE_CUBE_MAP, m.get(t).__webglTexture)
            }, this.setupRenderTarget = function(t) {
                var e = m.get(t),
                    i = m.get(t.texture);
                t.addEventListener("dispose", a), i.__webglTexture = p.createTexture(), _.textures++;
                var n = !0 === t.isWebGLRenderTargetCube,
                    r = x(t);
                if (n) {
                    e.__webglFramebuffer = [];
                    for (var s = 0; s < 6; s++) e.__webglFramebuffer[s] = p.createFramebuffer()
                } else e.__webglFramebuffer = p.createFramebuffer();
                if (n) {
                    for (f.bindTexture(p.TEXTURE_CUBE_MAP, i.__webglTexture), T(p.TEXTURE_CUBE_MAP, t.texture, r), s = 0; s < 6; s++) l(e.__webglFramebuffer[s], t, p.COLOR_ATTACHMENT0, p.TEXTURE_CUBE_MAP_POSITIVE_X + s);
                    b(t.texture, r) && p.generateMipmap(p.TEXTURE_CUBE_MAP), f.bindTexture(p.TEXTURE_CUBE_MAP, null)
                } else f.bindTexture(p.TEXTURE_2D, i.__webglTexture), T(p.TEXTURE_2D, t.texture, r), l(e.__webglFramebuffer, t, p.COLOR_ATTACHMENT0, p.TEXTURE_2D), b(t.texture, r) && p.generateMipmap(p.TEXTURE_2D), f.bindTexture(p.TEXTURE_2D, null);
                if (t.depthBuffer) {
                    if (e = m.get(t), i = !0 === t.isWebGLRenderTargetCube, t.depthTexture) {
                        if (i) throw Error("target.depthTexture not supported in Cube render targets");
                        if (t && t.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                        if (p.bindFramebuffer(p.FRAMEBUFFER, e.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        if (m.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), o(t.depthTexture, 0), e = m.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) p.framebufferTexture2D(p.FRAMEBUFFER, p.DEPTH_ATTACHMENT, p.TEXTURE_2D, e, 0);
                        else {
                            if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
                            p.framebufferTexture2D(p.FRAMEBUFFER, p.DEPTH_STENCIL_ATTACHMENT, p.TEXTURE_2D, e, 0)
                        }
                    } else if (i)
                        for (e.__webglDepthbuffer = [], i = 0; i < 6; i++) p.bindFramebuffer(p.FRAMEBUFFER, e.__webglFramebuffer[i]), e.__webglDepthbuffer[i] = p.createRenderbuffer(), c(e.__webglDepthbuffer[i], t);
                    else p.bindFramebuffer(p.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = p.createRenderbuffer(), c(e.__webglDepthbuffer, t);
                    p.bindFramebuffer(p.FRAMEBUFFER, null)
                }
            }, this.updateRenderTargetMipmap = function(t) {
                var e = t.texture;
                b(e, x(t)) && (t = t.isWebGLRenderTargetCube ? p.TEXTURE_CUBE_MAP : p.TEXTURE_2D, e = m.get(e).__webglTexture, f.bindTexture(t, e), p.generateMipmap(t), f.bindTexture(t, null))
            }
        }

        function ee() {
            var i = {};
            return {
                get: function(t) {
                    t = t.uuid;
                    var e = i[t];
                    return void 0 === e && (e = {}, i[t] = e), e
                },
                remove: function(t) {
                    delete i[t.uuid]
                },
                dispose: function() {
                    i = {}
                }
            }
        }

        function ie(c, i, l) {
            function t(t, e, i) {
                var n = new Uint8Array(4),
                    r = c.createTexture();
                for (c.bindTexture(t, r), c.texParameteri(t, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(t, c.TEXTURE_MAG_FILTER, c.NEAREST), t = 0; t < i; t++) c.texImage2D(e + t, 0, c.RGBA, 1, 1, 0, c.RGBA, c.UNSIGNED_BYTE, n);
                return r
            }

            function u(t) {
                !0 !== _[t] && (c.enable(t), _[t] = !0)
            }

            function d(t) {
                !1 !== _[t] && (c.disable(t), _[t] = !1)
            }

            function n(t, e, i, n, r, s, a, o) {
                if ((0 !== t ? u : d)(c.BLEND), 5 !== t) {
                    if (t !== b || o !== P) switch (t) {
                        case 2:
                            o ? (c.blendEquationSeparate(c.FUNC_ADD, c.FUNC_ADD), c.blendFuncSeparate(c.ONE, c.ONE, c.ONE, c.ONE)) : (c.blendEquation(c.FUNC_ADD), c.blendFunc(c.SRC_ALPHA, c.ONE));
                            break;
                        case 3:
                            o ? (c.blendEquationSeparate(c.FUNC_ADD, c.FUNC_ADD), c.blendFuncSeparate(c.ZERO, c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ONE_MINUS_SRC_ALPHA)) : (c.blendEquation(c.FUNC_ADD), c.blendFunc(c.ZERO, c.ONE_MINUS_SRC_COLOR));
                            break;
                        case 4:
                            o ? (c.blendEquationSeparate(c.FUNC_ADD, c.FUNC_ADD), c.blendFuncSeparate(c.ZERO, c.SRC_COLOR, c.ZERO, c.SRC_ALPHA)) : (c.blendEquation(c.FUNC_ADD), c.blendFunc(c.ZERO, c.SRC_COLOR));
                            break;
                        default:
                            o ? (c.blendEquationSeparate(c.FUNC_ADD, c.FUNC_ADD), c.blendFuncSeparate(c.ONE, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA)) : (c.blendEquationSeparate(c.FUNC_ADD, c.FUNC_ADD), c.blendFuncSeparate(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA))
                    }
                    A = S = E = M = T = w = null
                } else r = r || e, s = s || i, a = a || n, e === w && r === E || (c.blendEquationSeparate(l.convert(e), l.convert(r)), w = e, E = r), i === T && n === M && s === S && a === A || (c.blendFuncSeparate(l.convert(i), l.convert(n), l.convert(s), l.convert(a)), T = i, M = n, S = s, A = a);
                b = t, P = o
            }

            function r(t) {
                C !== t && (t ? c.frontFace(c.CW) : c.frontFace(c.CCW), C = t)
            }

            function e(t) {
                0 !== t ? (u(c.CULL_FACE), t !== R && (1 === t ? c.cullFace(c.BACK) : 2 === t ? c.cullFace(c.FRONT) : c.cullFace(c.FRONT_AND_BACK))) : d(c.CULL_FACE), R = t
            }

            function s(t, e, i) {
                t ? (u(c.POLYGON_OFFSET_FILL), O === e && D === i || (c.polygonOffset(e, i), O = e, D = i)) : d(c.POLYGON_OFFSET_FILL)
            }

            function a(t) {
                void 0 === t && (t = c.TEXTURE0 + k - 1), N !== t && (c.activeTexture(t), N = t)
            }
            var o = new function() {
                    var e = !1,
                        s = new At,
                        i = null,
                        a = new At(0, 0, 0, 0);
                    return {
                        setMask: function(t) {
                            i === t || e || (c.colorMask(t, t, t, t), i = t)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(t, e, i, n, r) {
                            !0 === r && (t *= n, e *= n, i *= n), s.set(t, e, i, n), !1 === a.equals(s) && (c.clearColor(t, e, i, n), a.copy(s))
                        },
                        reset: function() {
                            e = !1, i = null, a.set(-1, 0, 0, 0)
                        }
                    }
                },
                h = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null;
                    return {
                        setTest: function(t) {
                            (t ? u : d)(c.DEPTH_TEST)
                        },
                        setMask: function(t) {
                            i === t || e || (c.depthMask(t), i = t)
                        },
                        setFunc: function(t) {
                            if (n !== t) {
                                if (t) switch (t) {
                                    case 0:
                                        c.depthFunc(c.NEVER);
                                        break;
                                    case 1:
                                        c.depthFunc(c.ALWAYS);
                                        break;
                                    case 2:
                                        c.depthFunc(c.LESS);
                                        break;
                                    case 3:
                                        c.depthFunc(c.LEQUAL);
                                        break;
                                    case 4:
                                        c.depthFunc(c.EQUAL);
                                        break;
                                    case 5:
                                        c.depthFunc(c.GEQUAL);
                                        break;
                                    case 6:
                                        c.depthFunc(c.GREATER);
                                        break;
                                    case 7:
                                        c.depthFunc(c.NOTEQUAL);
                                        break;
                                    default:
                                        c.depthFunc(c.LEQUAL)
                                } else c.depthFunc(c.LEQUAL);
                                n = t
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(t) {
                            r !== t && (c.clearDepth(t), r = t)
                        },
                        reset: function() {
                            e = !1, r = n = i = null
                        }
                    }
                },
                p = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null,
                        s = null,
                        a = null,
                        o = null,
                        l = null,
                        h = null;
                    return {
                        setTest: function(t) {
                            (t ? u : d)(c.STENCIL_TEST)
                        },
                        setMask: function(t) {
                            i === t || e || (c.stencilMask(t), i = t)
                        },
                        setFunc: function(t, e, i) {
                            n === t && r === e && s === i || (c.stencilFunc(t, e, i), n = t, r = e, s = i)
                        },
                        setOp: function(t, e, i) {
                            a === t && o === e && l === i || (c.stencilOp(t, e, i), a = t, o = e, l = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(t) {
                            h !== t && (c.clearStencil(t), h = t)
                        },
                        reset: function() {
                            e = !1, h = l = o = a = s = r = n = i = null
                        }
                    }
                },
                f = c.getParameter(c.MAX_VERTEX_ATTRIBS),
                m = new Uint8Array(f),
                g = new Uint8Array(f),
                v = new Uint8Array(f),
                _ = {},
                y = null,
                x = null,
                b = null,
                w = null,
                T = null,
                M = null,
                E = null,
                S = null,
                A = null,
                P = !1,
                C = null,
                R = null,
                L = null,
                O = null,
                D = null,
                k = c.getParameter(c.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                f = parseFloat(/^WebGL\ ([0-9])/.exec(c.getParameter(c.VERSION))[1]),
                I = 1 <= parseFloat(f),
                N = null,
                z = {},
                B = new At,
                U = new At,
                F = {};
            return F[c.TEXTURE_2D] = t(c.TEXTURE_2D, c.TEXTURE_2D, 1), F[c.TEXTURE_CUBE_MAP] = t(c.TEXTURE_CUBE_MAP, c.TEXTURE_CUBE_MAP_POSITIVE_X, 6), o.setClear(0, 0, 0, 1), h.setClear(1), p.setClear(0), u(c.DEPTH_TEST), h.setFunc(3), r(!1), e(1), u(c.CULL_FACE), u(c.BLEND), n(1), {
                buffers: {
                    color: o,
                    depth: h,
                    stencil: p
                },
                initAttributes: function() {
                    for (var t = 0, e = m.length; t < e; t++) m[t] = 0
                },
                enableAttribute: function(t) {
                    m[t] = 1, 0 === g[t] && (c.enableVertexAttribArray(t), g[t] = 1), 0 !== v[t] && (i.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(t, 0), v[t] = 0)
                },
                enableAttributeAndDivisor: function(t, e) {
                    m[t] = 1, 0 === g[t] && (c.enableVertexAttribArray(t), g[t] = 1), v[t] !== e && (i.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(t, e), v[t] = e)
                },
                disableUnusedAttributes: function() {
                    for (var t = 0, e = g.length; t !== e; ++t) g[t] !== m[t] && (c.disableVertexAttribArray(t), g[t] = 0)
                },
                enable: u,
                disable: d,
                getCompressedTextureFormats: function() {
                    if (null === y && (y = [], i.get("WEBGL_compressed_texture_pvrtc") || i.get("WEBGL_compressed_texture_s3tc") || i.get("WEBGL_compressed_texture_etc1") || i.get("WEBGL_compressed_texture_astc")))
                        for (var t = c.getParameter(c.COMPRESSED_TEXTURE_FORMATS), e = 0; e < t.length; e++) y.push(t[e]);
                    return y
                },
                useProgram: function(t) {
                    return x !== t && (c.useProgram(t), x = t, !0)
                },
                setBlending: n,
                setMaterial: function(t, e) {
                    (2 === t.side ? d : u)(c.CULL_FACE);
                    var i = 1 === t.side;
                    e && (i = !i), r(i), !0 === t.transparent ? n(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : n(0), h.setFunc(t.depthFunc), h.setTest(t.depthTest), h.setMask(t.depthWrite), o.setMask(t.colorWrite), s(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                },
                setFlipSided: r,
                setCullFace: e,
                setLineWidth: function(t) {
                    t !== L && (I && c.lineWidth(t), L = t)
                },
                setPolygonOffset: s,
                setScissorTest: function(t) {
                    (t ? u : d)(c.SCISSOR_TEST)
                },
                activeTexture: a,
                bindTexture: function(t, e) {
                    null === N && a();
                    var i = z[N];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, z[N] = i), i.type === t && i.texture === e || (c.bindTexture(t, e || F[t]), i.type = t, i.texture = e)
                },
                compressedTexImage2D: function() {
                    try {
                        c.compressedTexImage2D.apply(c, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        c.texImage2D.apply(c, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(t) {
                    !1 === B.equals(t) && (c.scissor(t.x, t.y, t.z, t.w), B.copy(t))
                },
                viewport: function(t) {
                    !1 === U.equals(t) && (c.viewport(t.x, t.y, t.z, t.w), U.copy(t))
                },
                reset: function() {
                    for (var t = 0; t < g.length; t++) 1 === g[t] && (c.disableVertexAttribArray(t), g[t] = 0);
                    _ = {}, N = y = null, z = {}, R = C = b = x = null, o.reset(), h.reset(), p.reset()
                }
            }
        }

        function ne(e, i, t) {
            function n(t) {
                if ("highp" === t) {
                    if (0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision) return "highp";
                    t = "mediump"
                }
                return "mediump" === t && 0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
            }
            var r, s = void 0 !== t.precision ? t.precision : "highp";
            (a = n(s)) !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a), t = !0 === t.logarithmicDepthBuffer;
            var a = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                o = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                l = e.getParameter(e.MAX_TEXTURE_SIZE),
                h = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                c = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                u = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                d = e.getParameter(e.MAX_VARYING_VECTORS),
                p = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                f = 0 < o,
                m = !!i.get("OES_texture_float");
            return {
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    var t = i.get("EXT_texture_filter_anisotropic");
                    return r = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: n,
                precision: s,
                logarithmicDepthBuffer: t,
                maxTextures: a,
                maxVertexTextures: o,
                maxTextureSize: l,
                maxCubemapSize: h,
                maxAttributes: c,
                maxVertexUniforms: u,
                maxVaryings: d,
                maxFragmentUniforms: p,
                vertexTextures: f,
                floatFragmentTextures: m,
                floatVertexTextures: f && m
            }
        }

        function re(t, e, i, n) {
            Z.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function se(t) {
            re.call(this), this.cameras = t || []
        }

        function ae(i) {
            function t() {
                var t, e;
                null !== r && r.isPresenting ? (t = (e = r.getEyeParameters("left")).renderWidth, e = e.renderHeight, u = i.getPixelRatio(), c = i.getSize(), i.setDrawingBufferSize(2 * t, e, 1)) : n.enabled && i.setDrawingBufferSize(c.width, c.height, u)
            }
            var n = this,
                r = null,
                s = null,
                a = null;
            "undefined" != typeof window && "VRFrameData" in window && (s = new window.VRFrameData);
            var o = new Et,
                l = new re;
            l.bounds = new At(0, 0, .5, 1), l.layers.enable(1);
            var h = new re;
            h.bounds = new At(.5, 0, .5, 1), h.layers.enable(2);
            var c, u, d = new se([l, h]);
            d.layers.enable(1), d.layers.enable(2), "undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", t, !1), this.enabled = !1, this.getDevice = function() {
                return r
            }, this.setDevice = function(t) {
                void 0 !== t && (r = t)
            }, this.setPoseTarget = function(t) {
                void 0 !== t && (a = t)
            }, this.getCamera = function(t) {
                if (null === r) return t;
                r.depthNear = t.near, r.depthFar = t.far, r.getFrameData(s);
                var e = s.pose,
                    i = null !== a ? a : t;
                return null !== e.position ? i.position.fromArray(e.position) : i.position.set(0, 0, 0), null !== e.orientation && i.quaternion.fromArray(e.orientation), i.updateMatrixWorld(), !1 === r.isPresenting ? t : (l.near = t.near, h.near = t.near, l.far = t.far, h.far = t.far, d.matrixWorld.copy(t.matrixWorld), d.matrixWorldInverse.copy(t.matrixWorldInverse), l.matrixWorldInverse.fromArray(s.leftViewMatrix), h.matrixWorldInverse.fromArray(s.rightViewMatrix), null !== (t = i.parent) && (o.getInverse(t.matrixWorld), l.matrixWorldInverse.multiply(o), h.matrixWorldInverse.multiply(o)), l.matrixWorld.getInverse(l.matrixWorldInverse), h.matrixWorld.getInverse(h.matrixWorldInverse), l.projectionMatrix.fromArray(s.leftProjectionMatrix), h.projectionMatrix.fromArray(s.rightProjectionMatrix), d.projectionMatrix.copy(l.projectionMatrix), (t = r.getLayers()).length && (null !== (t = t[0]).leftBounds && 4 === t.leftBounds.length && l.bounds.fromArray(t.leftBounds), null !== t.rightBounds && 4 === t.rightBounds.length && h.bounds.fromArray(t.rightBounds)), d)
            }, this.submitFrame = function() {
                r && r.isPresenting && r.submitFrame()
            }, this.dispose = function() {
                "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", t)
            }
        }

        function oe(i) {
            var n = {};
            return {
                get: function(t) {
                    if (void 0 !== n[t]) return n[t];
                    switch (t) {
                        case "WEBGL_depth_texture":
                            var e = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            e = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            e = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            e = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            e = i.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            e = i.getExtension(t)
                    }
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), n[t] = e
                }
            }
        }

        function le() {
            function l() {
                m.value !== c && (m.value = c, m.needsUpdate = 0 < u), a.numPlanes = u, a.numIntersection = 0
            }

            function h(t, e, i, n) {
                var r = null !== t ? t.length : 0,
                    s = null;
                if (0 !== r) {
                    if (s = m.value, !0 !== n || null === s)
                        for (n = i + 4 * r, e = e.matrixWorldInverse, f.getNormalMatrix(e), (null === s || s.length < n) && (s = new Float32Array(n)), n = 0; n !== r; ++n, i += 4) o.copy(t[n]).applyMatrix4(e, f), o.normal.toArray(s, i), s[i + 3] = o.constant;
                    m.value = s, m.needsUpdate = !0
                }
                return a.numPlanes = r, s
            }
            var a = this,
                c = null,
                u = 0,
                d = !1,
                p = !1,
                o = new j,
                f = new g,
                m = {
                    value: null,
                    needsUpdate: !1
                };
            this.uniform = m, this.numIntersection = this.numPlanes = 0, this.init = function(t, e, i) {
                var n = 0 !== t.length || e || 0 !== u || d;
                return d = e, c = h(t, i, 0), u = t.length, n
            }, this.beginShadows = function() {
                p = !0, h(null)
            }, this.endShadows = function() {
                p = !1, l()
            }, this.setState = function(t, e, i, n, r, s) {
                if (!d || null === t || 0 === t.length || p && !i) p ? h(null) : l();
                else {
                    var a = 4 * (i = p ? 0 : u),
                        o = r.clippingState || null;
                    for (m.value = o, o = h(t, n, a, s), t = 0; t !== a; ++t) o[t] = c[t];
                    r.clippingState = o, this.numIntersection = e ? this.numPlanes : 0, this.numPlanes += i
                }
            }
        }

        function he(i, n) {
            return {
                convert: function(t) {
                    if (1e3 === t) return i.REPEAT;
                    if (1001 === t) return i.CLAMP_TO_EDGE;
                    if (1002 === t) return i.MIRRORED_REPEAT;
                    if (1003 === t) return i.NEAREST;
                    if (1004 === t) return i.NEAREST_MIPMAP_NEAREST;
                    if (1005 === t) return i.NEAREST_MIPMAP_LINEAR;
                    if (1006 === t) return i.LINEAR;
                    if (1007 === t) return i.LINEAR_MIPMAP_NEAREST;
                    if (1008 === t) return i.LINEAR_MIPMAP_LINEAR;
                    if (1009 === t) return i.UNSIGNED_BYTE;
                    if (1017 === t) return i.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === t) return i.UNSIGNED_SHORT_5_5_5_1;
                    if (1019 === t) return i.UNSIGNED_SHORT_5_6_5;
                    if (1010 === t) return i.BYTE;
                    if (1011 === t) return i.SHORT;
                    if (1012 === t) return i.UNSIGNED_SHORT;
                    if (1013 === t) return i.INT;
                    if (1014 === t) return i.UNSIGNED_INT;
                    if (1015 === t) return i.FLOAT;
                    if (1016 === t) {
                        var e = n.get("OES_texture_half_float");
                        if (null !== e) return e.HALF_FLOAT_OES
                    }
                    if (1021 === t) return i.ALPHA;
                    if (1022 === t) return i.RGB;
                    if (1023 === t) return i.RGBA;
                    if (1024 === t) return i.LUMINANCE;
                    if (1025 === t) return i.LUMINANCE_ALPHA;
                    if (1026 === t) return i.DEPTH_COMPONENT;
                    if (1027 === t) return i.DEPTH_STENCIL;
                    if (100 === t) return i.FUNC_ADD;
                    if (101 === t) return i.FUNC_SUBTRACT;
                    if (102 === t) return i.FUNC_REVERSE_SUBTRACT;
                    if (200 === t) return i.ZERO;
                    if (201 === t) return i.ONE;
                    if (202 === t) return i.SRC_COLOR;
                    if (203 === t) return i.ONE_MINUS_SRC_COLOR;
                    if (204 === t) return i.SRC_ALPHA;
                    if (205 === t) return i.ONE_MINUS_SRC_ALPHA;
                    if (206 === t) return i.DST_ALPHA;
                    if (207 === t) return i.ONE_MINUS_DST_ALPHA;
                    if (208 === t) return i.DST_COLOR;
                    if (209 === t) return i.ONE_MINUS_DST_COLOR;
                    if (210 === t) return i.SRC_ALPHA_SATURATE;
                    if ((33776 === t || 33777 === t || 33778 === t || 33779 === t) && (e = n.get("WEBGL_compressed_texture_s3tc"), null !== e)) {
                        if (33776 === t) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === t) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === t) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === t) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((35840 === t || 35841 === t || 35842 === t || 35843 === t) && (e = n.get("WEBGL_compressed_texture_pvrtc"), null !== e)) {
                        if (35840 === t) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t && null !== (e = n.get("WEBGL_compressed_texture_etc1"))) return e.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) && (e = n.get("WEBGL_compressed_texture_astc"), null !== e)) return t;
                    if ((103 === t || 104 === t) && (e = n.get("EXT_blend_minmax"), null !== e)) {
                        if (103 === t) return e.MIN_EXT;
                        if (104 === t) return e.MAX_EXT
                    }
                    return 1020 === t && null !== (e = n.get("WEBGL_depth_texture")) ? e.UNSIGNED_INT_24_8_WEBGL : 0
                }
            }
        }

        function ce(t) {
            function e() {
                (A = new oe(vt)).get("WEBGL_depth_texture"), A.get("OES_texture_float"), A.get("OES_texture_float_linear"), A.get("OES_texture_half_float"), A.get("OES_texture_half_float_linear"), A.get("OES_standard_derivatives"), A.get("OES_element_index_uint"), A.get("ANGLE_instanced_arrays"), j = new he(vt, A), P = new ne(vt, A, t), (C = new ie(vt, A, j)).scissor(tt.copy(ot).multiplyScalar(st)), C.viewport($.copy(at).multiplyScalar(st)), R = new ee, L = new te(vt, A, C, R, P, j, mt, gt), O = new kt(vt), D = new Ht(vt, O, mt), k = new jt(D, gt), U = new Bt(vt), N = new $t(W, A, P), I = new Vt, z = new Nt, B = new It(W, C, D, _), F = new Ft(vt, A, gt), H = new Ut(vt, A, gt), G = new Rt(0, vt, C, L, P), V = new Lt(W, vt, C, L, P), W.info.programs = N.programs, W.context = vt, W.capabilities = P, W.extensions = A, W.properties = R, W.renderLists = z, W.state = C
            }

            function i(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), X = !0
            }

            function n() {
                console.log("THREE.WebGLRenderer: Context Restored."), X = !1, e()
            }

            function o(t) {
                (t = t.target).removeEventListener("dispose", o), l(t), R.remove(t)
            }

            function l(t) {
                var e = R.get(t).program;
                (t.program = void 0) !== e && N.releaseProgram(e)
            }

            function r(t) {
                null !== Mt && Mt(t), ((t = _t.getDevice()) && t.isPresenting ? t : window).requestAnimationFrame(r)
            }

            function a(t, e, i, n) {
                for (var r = 0, s = t.length; r < s; r++) {
                    var a = (h = t[r]).object,
                        o = h.geometry,
                        l = void 0 === n ? h.material : n,
                        h = h.group;
                    if (i.isArrayCamera)
                        for (var c = (K = i).cameras, u = 0, d = c.length; u < d; u++) {
                            var p, f = c[u];
                            a.layers.test(f.layers) && (p = f.bounds, C.viewport($.set(p.x * nt, p.y * rt, p.z * nt, p.w * rt).multiplyScalar(st)), m(a, e, f, o, l, h))
                        } else K = null, m(a, e, i, o, l, h)
                }
            }

            function m(t, e, i, n, r, s) {
                var a, o, l;
                t.onBeforeRender(W, e, i, n, r, s), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject ? (a = t.isMesh && t.matrixWorld.determinant() < 0, C.setMaterial(r, a), a = T(i, e.fog, r, t), J = "", o = a, l = r, t.render(function(t) {
                    W.renderBufferImmediate(t, o, l)
                })) : W.renderBufferDirect(i, e.fog, n, r, t, s), t.onAfterRender(W, e, i, n, r, s)
            }

            function p(t, e, i) {
                var n = R.get(t);
                i = N.getParameters(t, I.state, w, e, ct.numPlanes, ct.numIntersection, i);
                var r = N.getProgramCode(t, i),
                    s = n.program,
                    a = !0;
                if (void 0 === s) t.addEventListener("dispose", o);
                else if (s.code !== r) l(t);
                else {
                    if (void 0 !== i.shaderID) return;
                    a = !1
                }
                if (a && (i.shaderID ? (s = ys[i.shaderID], n.shader = {
                        name: t.type,
                        uniforms: vs.clone(s.uniforms),
                        vertexShader: s.vertexShader,
                        fragmentShader: s.fragmentShader
                    }) : n.shader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    }, t.onBeforeCompile(n.shader), s = N.acquireProgram(t, n.shader, i, r), n.program = s, t.program = s), i = s.getAttributes(), t.morphTargets)
                    for (r = t.numSupportedMorphTargets = 0; r < W.maxMorphTargets; r++) 0 <= i["morphTarget" + r] && t.numSupportedMorphTargets++;
                if (t.morphNormals)
                    for (r = t.numSupportedMorphNormals = 0; r < W.maxMorphNormals; r++) 0 <= i["morphNormal" + r] && t.numSupportedMorphNormals++;
                i = n.shader.uniforms, (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = ct.numPlanes, n.numIntersection = ct.numIntersection, i.clippingPlanes = ct.uniform), n.fog = e, n.lightsHash = I.state.hash, t.lights && (i.ambientLightColor.value = I.state.ambient, i.directionalLights.value = I.state.directional, i.spotLights.value = I.state.spot, i.rectAreaLights.value = I.state.rectArea, i.pointLights.value = I.state.point, i.hemisphereLights.value = I.state.hemi, i.directionalShadowMap.value = I.state.directionalShadowMap, i.directionalShadowMatrix.value = I.state.directionalShadowMatrix, i.spotShadowMap.value = I.state.spotShadowMap, i.spotShadowMatrix.value = I.state.spotShadowMatrix, i.pointShadowMap.value = I.state.pointShadowMap, i.pointShadowMatrix.value = I.state.pointShadowMatrix), t = n.program.getUniforms(), t = Ct.seqWithValue(t.seq, i), n.uniformsList = t
            }

            function T(t, e, i, n) {
                it = 0;
                var r = R.get(i);
                ut && (dt || t !== Q) && ct.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, t === Q && i.id === Z), !1 !== i.needsUpdate || (void 0 === r.program || i.fog && r.fog !== e || i.lights && r.lightsHash !== I.state.hash || void 0 !== r.numClippingPlanes && (r.numClippingPlanes !== ct.numPlanes || r.numIntersection !== ct.numIntersection)) && (i.needsUpdate = !0), i.needsUpdate && (p(i, e, n), i.needsUpdate = !1);
                var s, a, o = !1,
                    l = !1,
                    h = !1,
                    c = r.program,
                    u = c.getUniforms(),
                    d = r.shader.uniforms;
                return C.useProgram(c.program) && (h = l = o = !0), i.id !== Z && (Z = i.id, l = !0), !o && t === Q || (u.setValue(vt, "projectionMatrix", t.projectionMatrix), P.logarithmicDepthBuffer && u.setValue(vt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), Q !== (K || t) && (Q = K || t, h = l = !0), !(i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) || void 0 !== (o = u.map.cameraPosition) && o.setValue(vt, ft.setFromMatrixPosition(t.matrixWorld)), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && u.setValue(vt, "viewMatrix", t.matrixWorldInverse)), i.skinning && (u.setOptional(vt, n, "bindMatrix"), u.setOptional(vt, n, "bindMatrixInverse"), t = n.skeleton) && (o = t.bones, P.floatVertexTextures ? (void 0 === t.boneTexture && (o = Math.sqrt(4 * o.length), o = es.ceilPowerOfTwo(o), o = Math.max(o, 4), (s = new Float32Array(o * o * 4)).set(t.boneMatrices), a = new Pt(s, o, o, 1023, 1015), t.boneMatrices = s, t.boneTexture = a, t.boneTextureSize = o), u.setValue(vt, "boneTexture", t.boneTexture), u.setValue(vt, "boneTextureSize", t.boneTextureSize)) : u.setOptional(vt, t, "boneMatrices")), l && (u.setValue(vt, "toneMappingExposure", W.toneMappingExposure), u.setValue(vt, "toneMappingWhitePoint", W.toneMappingWhitePoint), i.lights && (l = h, d.ambientLightColor.needsUpdate = l, d.directionalLights.needsUpdate = l, d.pointLights.needsUpdate = l, d.spotLights.needsUpdate = l, d.rectAreaLights.needsUpdate = l, d.hemisphereLights.needsUpdate = l), e && i.fog && (d.fogColor.value = e.color, e.isFog ? (d.fogNear.value = e.near, d.fogFar.value = e.far) : e.isFogExp2 && (d.fogDensity.value = e.density)), i.isMeshBasicMaterial ? f(d, i) : i.isMeshLambertMaterial ? (f(d, i), i.emissiveMap && (d.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (f(d, i), i.isMeshToonMaterial ? (g(d, i), i.gradientMap && (d.gradientMap.value = i.gradientMap)) : g(d, i)) : i.isMeshStandardMaterial ? (f(d, i), i.isMeshPhysicalMaterial && (d.clearCoat.value = i.clearCoat, d.clearCoatRoughness.value = i.clearCoatRoughness), d.roughness.value = i.roughness, d.metalness.value = i.metalness, i.roughnessMap && (d.roughnessMap.value = i.roughnessMap), i.metalnessMap && (d.metalnessMap.value = i.metalnessMap), i.emissiveMap && (d.emissiveMap.value = i.emissiveMap), i.bumpMap && (d.bumpMap.value = i.bumpMap, d.bumpScale.value = i.bumpScale), i.normalMap && (d.normalMap.value = i.normalMap, d.normalScale.value.copy(i.normalScale)), i.displacementMap && (d.displacementMap.value = i.displacementMap, d.displacementScale.value = i.displacementScale, d.displacementBias.value = i.displacementBias), i.envMap && (d.envMapIntensity.value = i.envMapIntensity)) : i.isMeshDepthMaterial ? (f(d, i), i.displacementMap && (d.displacementMap.value = i.displacementMap, d.displacementScale.value = i.displacementScale, d.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (f(d, i), i.displacementMap && (d.displacementMap.value = i.displacementMap, d.displacementScale.value = i.displacementScale, d.displacementBias.value = i.displacementBias), d.referencePosition.value.copy(i.referencePosition), d.nearDistance.value = i.nearDistance, d.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (f(d, i), i.bumpMap && (d.bumpMap.value = i.bumpMap, d.bumpScale.value = i.bumpScale), i.normalMap && (d.normalMap.value = i.normalMap, d.normalScale.value.copy(i.normalScale)), i.displacementMap && (d.displacementMap.value = i.displacementMap, d.displacementScale.value = i.displacementScale, d.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (d.diffuse.value = i.color, d.opacity.value = i.opacity, i.isLineDashedMaterial && (d.dashSize.value = i.dashSize, d.totalSize.value = i.dashSize + i.gapSize, d.scale.value = i.scale)) : i.isPointsMaterial ? (d.diffuse.value = i.color, d.opacity.value = i.opacity, d.size.value = i.size * st, d.scale.value = .5 * rt, d.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && (e = i.map.offset, l = i.map.repeat, h = i.map.center, i.map.matrix.setUvTransform(e.x, e.y, l.x, l.y, i.map.rotation, h.x, h.y)), d.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (d.color.value = i.color, d.opacity.value = i.opacity), void 0 !== d.ltc_1 && (d.ltc_1.value = gs.LTC_1), void 0 !== d.ltc_2 && (d.ltc_2.value = gs.LTC_2), Ct.upload(vt, r.uniformsList, d, W)), u.setValue(vt, "modelViewMatrix", n.modelViewMatrix), u.setValue(vt, "normalMatrix", n.normalMatrix), u.setValue(vt, "modelMatrix", n.matrixWorld), c
            }

            function f(t, e) {
                var i, n, r;
                t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && (e = i.offset, n = i.repeat, r = i.center, i.matrix.setUvTransform(e.x, e.y, n.x, n.y, i.rotation, r.x, r.y)), t.uvTransform.value.copy(i.matrix))
            }

            function g(t, e) {
                t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }
            console.log("THREE.WebGLRenderer", "90dev");
            var s = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                h = void 0 !== t.context ? t.context : null,
                c = void 0 !== t.alpha && t.alpha,
                u = void 0 === t.depth || t.depth,
                d = void 0 === t.stencil || t.stencil,
                v = void 0 !== t.antialias && t.antialias,
                _ = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                y = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                x = void 0 !== t.powerPreference ? t.powerPreference : "default",
                b = [],
                w = [],
                M = null,
                E = [],
                S = [];
            this.domElement = s, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var A, P, C, R, L, O, D, k, I, N, z, B, U, F, H, G, V, j, W = this,
                X = !1,
                q = null,
                Y = null,
                Z = -1,
                J = "",
                Q = null,
                K = null,
                $ = new At,
                tt = new At,
                et = null,
                it = 0,
                nt = s.width,
                rt = s.height,
                st = 1,
                at = new At(0, 0, nt, rt),
                ot = new At(0, 0, nt, rt),
                lt = !1,
                ht = new Ot,
                ct = new le,
                ut = !1,
                dt = !1,
                pt = new Et,
                ft = new St,
                mt = {
                    geometries: 0,
                    textures: 0
                },
                gt = {
                    frame: 0,
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                };
            this.info = {
                render: gt,
                memory: mt,
                programs: null,
                autoReset: !0,
                reset: function() {
                    gt.frame++, gt.calls = 0, gt.vertices = 0, gt.faces = 0, gt.points = 0
                }
            };
            try {
                c = {
                    alpha: c,
                    depth: u,
                    stencil: d,
                    antialias: v,
                    premultipliedAlpha: _,
                    preserveDrawingBuffer: y,
                    powerPreference: x
                }, s.addEventListener("webglcontextlost", i, !1), s.addEventListener("webglcontextrestored", n, !1);
                var vt = h || s.getContext("webgl", c) || s.getContext("experimental-webgl", c);
                if (null === vt) {
                    if (null !== s.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                    throw Error("Error creating WebGL context.")
                }
                void 0 === vt.getShaderPrecisionFormat && (vt.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                console.error("THREE.WebGLRenderer: " + t.message)
            }
            e();
            var _t = new ae(W);
            this.vr = _t;
            var yt = new Dt(W, k, P.maxTextureSize);
            this.shadowMap = yt, this.getContext = function() {
                return vt
            }, this.getContextAttributes = function() {
                return vt.getContextAttributes()
            }, this.forceContextLoss = function() {
                var t = A.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function() {
                var t = A.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function() {
                return st
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (st = t, this.setSize(nt, rt, !1))
            }, this.getSize = function() {
                return {
                    width: nt,
                    height: rt
                }
            }, this.setSize = function(t, e, i) {
                var n = _t.getDevice();
                n && n.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (nt = t, rt = e, s.width = t * st, s.height = e * st, !1 !== i && (s.style.width = t + "px", s.style.height = e + "px"), this.setViewport(0, 0, t, e))
            }, this.getDrawingBufferSize = function() {
                return {
                    width: nt * st,
                    height: rt * st
                }
            }, this.setDrawingBufferSize = function(t, e, i) {
                nt = t, rt = e, st = i, s.width = t * i, s.height = e * i, this.setViewport(0, 0, t, e)
            }, this.setViewport = function(t, e, i, n) {
                at.set(t, rt - e - n, i, n), C.viewport($.copy(at).multiplyScalar(st))
            }, this.setScissor = function(t, e, i, n) {
                ot.set(t, rt - e - n, i, n), C.scissor(tt.copy(ot).multiplyScalar(st))
            }, this.setScissorTest = function(t) {
                C.setScissorTest(lt = t)
            }, this.getClearColor = function() {
                return B.getClearColor()
            }, this.setClearColor = function() {
                B.setClearColor.apply(B, arguments)
            }, this.getClearAlpha = function() {
                return B.getClearAlpha()
            }, this.setClearAlpha = function() {
                B.setClearAlpha.apply(B, arguments)
            }, this.clear = function(t, e, i) {
                var n = 0;
                void 0 !== t && !t || (n |= vt.COLOR_BUFFER_BIT), void 0 !== e && !e || (n |= vt.DEPTH_BUFFER_BIT), void 0 !== i && !i || (n |= vt.STENCIL_BUFFER_BIT), vt.clear(n)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.clearTarget = function(t, e, i, n) {
                this.setRenderTarget(t), this.clear(e, i, n)
            }, this.dispose = function() {
                s.removeEventListener("webglcontextlost", i, !1), s.removeEventListener("webglcontextrestored", n, !1), z.dispose(), R.dispose(), k.dispose(), _t.dispose()
            }, this.renderBufferImmediate = function(t, e, i) {
                C.initAttributes();
                var n = R.get(t);
                if (t.hasPositions && !n.position && (n.position = vt.createBuffer()), t.hasNormals && !n.normal && (n.normal = vt.createBuffer()), t.hasUvs && !n.uv && (n.uv = vt.createBuffer()), t.hasColors && !n.color && (n.color = vt.createBuffer()), e = e.getAttributes(), t.hasPositions && (vt.bindBuffer(vt.ARRAY_BUFFER, n.position), vt.bufferData(vt.ARRAY_BUFFER, t.positionArray, vt.DYNAMIC_DRAW), C.enableAttribute(e.position), vt.vertexAttribPointer(e.position, 3, vt.FLOAT, !1, 0, 0)), t.hasNormals) {
                    if (vt.bindBuffer(vt.ARRAY_BUFFER, n.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && !0 === i.flatShading)
                        for (var r = 0, s = 3 * t.count; r < s; r += 9) {
                            var a = t.normalArray,
                                o = (a[r + 0] + a[r + 3] + a[r + 6]) / 3,
                                l = (a[r + 1] + a[r + 4] + a[r + 7]) / 3,
                                h = (a[r + 2] + a[r + 5] + a[r + 8]) / 3;
                            a[r + 0] = o, a[r + 1] = l, a[r + 2] = h, a[r + 3] = o, a[r + 4] = l, a[r + 5] = h, a[r + 6] = o, a[r + 7] = l, a[r + 8] = h
                        }
                    vt.bufferData(vt.ARRAY_BUFFER, t.normalArray, vt.DYNAMIC_DRAW), C.enableAttribute(e.normal), vt.vertexAttribPointer(e.normal, 3, vt.FLOAT, !1, 0, 0)
                }
                t.hasUvs && i.map && (vt.bindBuffer(vt.ARRAY_BUFFER, n.uv), vt.bufferData(vt.ARRAY_BUFFER, t.uvArray, vt.DYNAMIC_DRAW), C.enableAttribute(e.uv), vt.vertexAttribPointer(e.uv, 2, vt.FLOAT, !1, 0, 0)), t.hasColors && 0 !== i.vertexColors && (vt.bindBuffer(vt.ARRAY_BUFFER, n.color), vt.bufferData(vt.ARRAY_BUFFER, t.colorArray, vt.DYNAMIC_DRAW), C.enableAttribute(e.color), vt.vertexAttribPointer(e.color, 3, vt.FLOAT, !1, 0, 0)), C.disableUnusedAttributes(), vt.drawArrays(vt.TRIANGLES, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function(t, e, i, n, r, s) {
                var a = r.isMesh && r.matrixWorld.determinant() < 0;
                C.setMaterial(n, a);
                var o = T(t, e, n, r),
                    l = !1;
                (t = i.id + "_" + o.id + "_" + (!0 === n.wireframe)) !== J && (J = t, l = !0), r.morphTargetInfluences && (U.update(r, i, n, o), l = !0);
                var h, a = i.index,
                    c = i.attributes.position;
                if (e = 1, !0 === n.wireframe && (a = D.getWireframeAttribute(i), e = 2), t = F, null !== a && (h = O.get(a), (t = H).setIndex(h)), l) {
                    if (l = void 0, i && i.isInstancedBufferGeometry && null === A.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    else {
                        void 0 === l && (l = 0), C.initAttributes();
                        var u = i.attributes,
                            o = o.getAttributes(),
                            d = n.defaultAttributeValues;
                        for (w in o) {
                            var p = o[w];
                            if (0 <= p)
                                if (void 0 !== (_ = u[w])) {
                                    var f, m, g, v, _, y = _.normalized,
                                        x = _.itemSize,
                                        b = O.get(_);
                                    void 0 !== b && (f = b.buffer, m = b.type, b = b.bytesPerElement, _.isInterleavedBufferAttribute ? (v = (g = _.data).stride, _ = _.offset, g && g.isInstancedInterleavedBuffer ? (C.enableAttributeAndDivisor(p, g.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = g.meshPerAttribute * g.count)) : C.enableAttribute(p), vt.bindBuffer(vt.ARRAY_BUFFER, f), vt.vertexAttribPointer(p, x, m, y, v * b, (l * v + _) * b)) : (_.isInstancedBufferAttribute ? (C.enableAttributeAndDivisor(p, _.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = _.meshPerAttribute * _.count)) : C.enableAttribute(p), vt.bindBuffer(vt.ARRAY_BUFFER, f), vt.vertexAttribPointer(p, x, m, y, 0, l * x * b)))
                                } else if (void 0 !== d && void 0 !== (y = d[w])) switch (y.length) {
                                case 2:
                                    vt.vertexAttrib2fv(p, y);
                                    break;
                                case 3:
                                    vt.vertexAttrib3fv(p, y);
                                    break;
                                case 4:
                                    vt.vertexAttrib4fv(p, y);
                                    break;
                                default:
                                    vt.vertexAttrib1fv(p, y)
                            }
                        }
                        C.disableUnusedAttributes()
                    }
                    null !== a && vt.bindBuffer(vt.ELEMENT_ARRAY_BUFFER, h.buffer)
                }
                h = 0, null !== a ? h = a.count : void 0 !== c && (h = c.count), a = i.drawRange.start * e, c = null !== s ? s.start * e : 0;
                var w = Math.max(a, c);
                if (0 !== (s = Math.max(0, Math.min(h, a + i.drawRange.count * e, c + (null !== s ? s.count * e : 1 / 0)) - 1 - w + 1))) {
                    if (r.isMesh)
                        if (!0 === n.wireframe) C.setLineWidth(n.wireframeLinewidth * (null === q ? st : 1)), t.setMode(vt.LINES);
                        else switch (r.drawMode) {
                            case 0:
                                t.setMode(vt.TRIANGLES);
                                break;
                            case 1:
                                t.setMode(vt.TRIANGLE_STRIP);
                                break;
                            case 2:
                                t.setMode(vt.TRIANGLE_FAN)
                        } else r.isLine ? (void 0 === (n = n.linewidth) && (n = 1), C.setLineWidth(n * (null === q ? st : 1)), r.isLineSegments ? t.setMode(vt.LINES) : r.isLineLoop ? t.setMode(vt.LINE_LOOP) : t.setMode(vt.LINE_STRIP)) : r.isPoints && t.setMode(vt.POINTS);
                    i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && t.renderInstances(i, w, s) : t.render(w, s)
                }
            };
            var xt, bt, wt, Tt = !(this.compile = function(i, t) {
                    b.length = 0, w.length = 0, i.traverse(function(t) {
                        t.isLight && (b.push(t), t.castShadow && w.push(t))
                    }), I.setup(b, w, t), i.traverse(function(t) {
                        if (t.material)
                            if (Array.isArray(t.material))
                                for (var e = 0; e < t.material.length; e++) p(t.material[e], i.fog, t);
                            else p(t.material, i.fog, t)
                    })
                }),
                Mt = null;
            this.animate = function(t) {
                Mt = t, Tt || (((t = _t.getDevice()) && t.isPresenting ? t : window).requestAnimationFrame(r), Tt = !0)
            }, this.render = function(t, e, i, n) {
                var r, s;
                e && e.isCamera ? X || (J = "", Z = -1, !(Q = null) === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), _t.enabled && (e = _t.getCamera(e)), t.onBeforeRender(W, t, e, i), pt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), ht.setFromMatrix(pt), b.length = 0, w.length = 0, E.length = 0, S.length = 0, dt = this.localClippingEnabled, ut = ct.init(this.clippingPlanes, dt, e), (M = z.get(t, e)).init(), function t(e, i, n) {
                    if (!1 !== e.visible) {
                        if (e.layers.test(i.layers))
                            if (e.isLight) b.push(e), e.castShadow && w.push(e);
                            else if (e.isSprite) e.frustumCulled && !ht.intersectsSprite(e) || E.push(e);
                        else if (e.isLensFlare) S.push(e);
                        else if (e.isImmediateRenderObject) n && ft.setFromMatrixPosition(e.matrixWorld).applyMatrix4(pt), M.push(e, null, e.material, ft.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || ht.intersectsObject(e))) {
                            n && ft.setFromMatrixPosition(e.matrixWorld).applyMatrix4(pt);
                            var r = k.update(e),
                                s = e.material;
                            if (Array.isArray(s))
                                for (var a = r.groups, o = 0, l = a.length; o < l; o++) {
                                    var h = a[o],
                                        c = s[h.materialIndex];
                                    c && c.visible && M.push(e, r, c, ft.z, h)
                                } else s.visible && M.push(e, r, s, ft.z, null)
                        }
                        for (o = 0, l = (e = e.children).length; o < l; o++) t(e[o], i, n)
                    }
                }(t, e, W.sortObjects), !0 === W.sortObjects && M.sort(), ut && ct.beginShadows(), yt.render(w, t, e), I.setup(b, w, e), ut && ct.endShadows(), this.info.autoReset && this.info.reset(), void 0 === i && (i = null), this.setRenderTarget(i), B.render(M, t, e, n), n = M.opaque, r = M.transparent, t.overrideMaterial ? (s = t.overrideMaterial, n.length && a(n, t, e, s), r.length && a(r, t, e, s)) : (n.length && a(n, t, e), r.length && a(r, t, e)), V.render(E, t, e), G.render(S, t, e, $), i && L.updateRenderTargetMipmap(i), C.buffers.depth.setTest(!0), C.buffers.depth.setMask(!0), C.buffers.color.setMask(!0), C.setPolygonOffset(!1), t.onAfterRender(W, t, e, i), _t.enabled && _t.submitFrame()) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
            }, this.setFaceCulling = function(t, e) {
                C.setCullFace(t), C.setFlipSided(0 === e)
            }, this.allocTextureUnit = function() {
                var t = it;
                return t >= P.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + P.maxTextures), it += 1, t
            }, this.setTexture2D = (xt = !1, function(t, e) {
                t && t.isWebGLRenderTarget && (xt || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), xt = !0), t = t.texture), L.setTexture2D(t, e)
            }), this.setTexture = (bt = !1, function(t, e) {
                bt || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), bt = !0), L.setTexture2D(t, e)
            }), this.setTextureCube = (wt = !1, function(t, e) {
                t && t.isWebGLRenderTargetCube && (wt || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), wt = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? L.setTextureCube(t, e) : L.setTextureCubeDynamic(t, e)
            }), this.getRenderTarget = function() {
                return q
            }, this.setRenderTarget = function(t) {
                (q = t) && void 0 === R.get(t).__webglFramebuffer && L.setupRenderTarget(t);
                var e = null,
                    i = !1;
                et = t ? (e = R.get(t).__webglFramebuffer, t.isWebGLRenderTargetCube && (e = e[t.activeCubeFace], i = !0), $.copy(t.viewport), tt.copy(t.scissor), t.scissorTest) : ($.copy(at).multiplyScalar(st), tt.copy(ot).multiplyScalar(st), lt), Y !== e && (vt.bindFramebuffer(vt.FRAMEBUFFER, e), Y = e), C.viewport($), C.scissor(tt), C.setScissorTest(et), i && (i = R.get(t.texture), vt.framebufferTexture2D(vt.FRAMEBUFFER, vt.COLOR_ATTACHMENT0, vt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, i.__webglTexture, t.activeMipMapLevel))
            }, this.readRenderTargetPixels = function(t, e, i, n, r, s) {
                if (t && t.isWebGLRenderTarget) {
                    var a = R.get(t).__webglFramebuffer;
                    if (a) {
                        var o = !1;
                        a !== Y && (vt.bindFramebuffer(vt.FRAMEBUFFER, a), o = !0);
                        try {
                            var l = t.texture,
                                h = l.format,
                                l = l.type;
                            1023 !== h && j.convert(h) !== vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === l || j.convert(l) === vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === l && (A.get("OES_texture_float") || A.get("WEBGL_color_buffer_float")) || 1016 === l && A.get("EXT_color_buffer_half_float") ? vt.checkFramebufferStatus(vt.FRAMEBUFFER) === vt.FRAMEBUFFER_COMPLETE ? 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && vt.readPixels(e, i, n, r, j.convert(h), j.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                        } finally {
                            o && vt.bindFramebuffer(vt.FRAMEBUFFER, Y)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            }, this.copyFramebufferToTexture = function(t, e, i, n) {
                var r = i.image.width,
                    s = i.image.height,
                    a = j.convert(i.format);
                this.setTexture2D(i, 0), vt.copyTexImage2D(vt.TEXTURE_2D, n || 0, a, t, e, r, s, 0)
            }
        }

        function ue(t, e) {
            this.name = "", this.color = new N(t), this.density = void 0 !== e ? e : 25e-5
        }

        function de(t, e, i) {
            this.name = "", this.color = new N(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
        }

        function pe() {
            Y.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
        }

        function fe(t, e, i, n, r) {
            Y.call(this), this.lensFlares = [], this.positionScreen = new St, (this.customUpdateCallback = void 0) !== t && this.add(t, e, i, n, r)
        }

        function me(t) {
            B.call(this), this.type = "SpriteMaterial", this.color = new N(16777215), this.map = null, this.rotation = 0, this.lights = this.fog = !1, this.setValues(t)
        }

        function ge(t) {
            Y.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new me
        }

        function ve() {
            Y.call(this), this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            })
        }

        function _e(t, e) {
            if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
            else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
            else
                for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Et)
        }

        function ye() {
            Y.call(this), this.type = "Bone"
        }

        function xe(t, e) {
            bt.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Et, this.bindMatrixInverse = new Et, t = new _e(t = this.initBones()), this.bind(t, this.matrixWorld), this.normalizeSkinWeights()
        }

        function be(t) {
            B.call(this), this.type = "LineBasicMaterial", this.color = new N(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t)
        }

        function we(t, e, i) {
            if (1 === i) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Te(t, e);
            Y.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new ut, this.material = void 0 !== e ? e : new be({
                color: 16777215 * Math.random()
            })
        }

        function Te(t, e) {
            we.call(this, t, e), this.type = "LineSegments"
        }

        function Me(t, e) {
            we.call(this, t, e), this.type = "LineLoop"
        }

        function Ee(t) {
            B.call(this), this.type = "PointsMaterial", this.color = new N(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
        }

        function Se(t, e) {
            Y.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new ut, this.material = void 0 !== e ? e : new Ee({
                color: 16777215 * Math.random()
            })
        }

        function Ae() {
            Y.call(this), this.type = "Group"
        }

        function Pe(t, e, i, n, r, s, a, o, l) {
            d.call(this, t, e, i, n, r, s, a, o, l), this.generateMipmaps = !1
        }

        function Ce(t, e, i, n, r, s, a, o, l, h, c, u) {
            d.call(this, null, s, a, o, l, h, n, r, c, u), this.image = {
                width: e,
                height: i
            }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1
        }

        function Re(t, e, i, n, r, s, a, o, l, h) {
            if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), d.call(this, null, n, r, s, a, o, h, i, l), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== a ? a : 1003, this.minFilter = void 0 !== o ? o : 1003, this.generateMipmaps = this.flipY = !1
        }

        function Le(t) {
            ut.call(this), this.type = "WireframeGeometry";
            var e, i = [],
                n = [0, 0],
                r = {},
                s = ["a", "b", "c"];
            if (t && t.isGeometry) {
                for (var a = t.faces, o = 0, l = a.length; o < l; o++)
                    for (var h = a[o], c = 0; c < 3; c++) {
                        var u = h[s[c]],
                            d = h[s[(c + 1) % 3]];
                        n[0] = Math.min(u, d), n[1] = Math.max(u, d), void 0 === r[u = n[0] + "," + n[1]] && (r[u] = {
                            index1: n[0],
                            index2: n[1]
                        })
                    }
                for (u in r) o = r[u], s = t.vertices[o.index1], i.push(s.x, s.y, s.z), s = t.vertices[o.index2], i.push(s.x, s.y, s.z)
            } else if (t && t.isBufferGeometry) {
                s = new St;
                if (null !== t.index) {
                    a = t.attributes.position, h = t.index;
                    var p = t.groups;
                    for (0 === p.length && (p = [{
                            start: 0,
                            count: h.count,
                            materialIndex: 0
                        }]), t = 0, e = p.length; t < e; ++t)
                        for (c = (o = p[t]).start, l = o.count, l = (o = c) + l; o < l; o += 3)
                            for (c = 0; c < 3; c++) u = h.getX(o + c), d = h.getX(o + (c + 1) % 3), n[0] = Math.min(u, d), n[1] = Math.max(u, d), void 0 === r[u = n[0] + "," + n[1]] && (r[u] = {
                                index1: n[0],
                                index2: n[1]
                            });
                    for (u in r) o = r[u], s.fromBufferAttribute(a, o.index1), i.push(s.x, s.y, s.z), s.fromBufferAttribute(a, o.index2), i.push(s.x, s.y, s.z)
                } else
                    for (o = 0, l = (a = t.attributes.position).count / 3; o < l; o++)
                        for (c = 0; c < 3; c++) r = 3 * o + c, s.fromBufferAttribute(a, r), i.push(s.x, s.y, s.z), r = 3 * o + (c + 1) % 3, s.fromBufferAttribute(a, r), i.push(s.x, s.y, s.z)
            }
            this.addAttribute("position", new ot(i, 3))
        }

        function Oe(t, e, i) {
            K.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            }, this.fromBufferGeometry(new De(t, e, i)), this.mergeVertices()
        }

        function De(t, e, i) {
            ut.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            };
            for (var n = [], r = [], s = [], a = [], o = new St, l = new St, h = new St, c = new St, u = new St, d = e + 1, p = 0; p <= i; p++)
                for (var f = p / i, m = 0; m <= e; m++) {
                    var g = m / e,
                        l = t(g, f, l);
                    r.push(l.x, l.y, l.z), 0 <= g - 1e-5 ? (h = t(g - 1e-5, f, h), c.subVectors(l, h)) : (h = t(1e-5 + g, f, h), c.subVectors(h, l)), 0 <= f - 1e-5 ? (h = t(g, f - 1e-5, h), u.subVectors(l, h)) : (h = t(g, 1e-5 + f, h), u.subVectors(h, l)), o.crossVectors(c, u).normalize(), s.push(o.x, o.y, o.z), a.push(g, f)
                }
            for (p = 0; p < i; p++)
                for (m = 0; m < e; m++) t = p * d + m + 1, o = (p + 1) * d + m + 1, l = (p + 1) * d + m, n.push(p * d + m, t, l), n.push(t, o, l);
            this.setIndex(n), this.addAttribute("position", new ot(r, 3)), this.addAttribute("normal", new ot(s, 3)), this.addAttribute("uv", new ot(a, 2))
        }

        function ke(t, e, i, n) {
            K.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: n
            }, this.fromBufferGeometry(new Ie(t, e, i, n)), this.mergeVertices()
        }

        function Ie(i, m, t, e) {
            function g(t) {
                u.push(t.x, t.y, t.z)
            }

            function v(t, e) {
                t *= 3, e.x = i[t + 0], e.y = i[t + 1], e.z = i[t + 2]
            }

            function c(t, e, i, n) {
                n < 0 && 1 === t.x && (d[e] = t.x - 1), 0 === i.x && 0 === i.z && (d[e] = n / 2 / Math.PI + .5)
            }
            ut.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: i,
                indices: m,
                radius: t,
                detail: e
            }, t = t || 1;
            var u = [],
                d = [];
            ! function(t) {
                for (var e = new St, i = new St, n = new St, r = 0; r < m.length; r += 3) {
                    v(m[r + 0], e), v(m[r + 1], i), v(m[r + 2], n);
                    for (var s = e, a = i, o = n, l = Math.pow(2, t), h = [], c = 0; c <= l; c++) {
                        h[c] = [];
                        for (var u = s.clone().lerp(o, c / l), d = a.clone().lerp(o, c / l), p = l - c, f = 0; f <= p; f++) h[c][f] = 0 === f && c === l ? u : u.clone().lerp(d, f / p)
                    }
                    for (c = 0; c < l; c++)
                        for (f = 0; f < 2 * (l - c) - 1; f++) s = Math.floor(f / 2), 0 == f % 2 ? (g(h[c][s + 1]), g(h[c + 1][s]), g(h[c][s])) : (g(h[c][s + 1]), g(h[c + 1][s + 1]), g(h[c + 1][s]))
                }
            }(e = e || 0),
            function(t) {
                for (var e = new St, i = 0; i < u.length; i += 3) e.x = u[i + 0], e.y = u[i + 1], e.z = u[i + 2], e.normalize().multiplyScalar(t), u[i + 0] = e.x, u[i + 1] = e.y, u[i + 2] = e.z
            }(t),
            function() {
                for (var t = new St, e = 0; e < u.length; e += 3) t.x = u[e + 0], t.y = u[e + 1], t.z = u[e + 2], d.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5));
                for (var t = new St, e = new St, i = new St, n = new St, r = new X, s = new X, a = new X, o = 0, l = 0; o < u.length; o += 9, l += 6) {
                    t.set(u[o + 0], u[o + 1], u[o + 2]), e.set(u[o + 3], u[o + 4], u[o + 5]), i.set(u[o + 6], u[o + 7], u[o + 8]), r.set(d[l + 0], d[l + 1]), s.set(d[l + 2], d[l + 3]), a.set(d[l + 4], d[l + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                    var h = Math.atan2(n.z, -n.x);
                    c(r, l + 0, t, h), c(s, l + 2, e, h), c(a, l + 4, i, h)
                }
                for (t = 0; t < d.length; t += 6) e = d[t + 0], i = d[t + 2], n = d[t + 4], r = Math.min(e, i, n), .9 < Math.max(e, i, n) && r < .1 && (e < .2 && (d[t + 0] += 1), i < .2 && (d[t + 2] += 1), n < .2 && (d[t + 4] += 1))
            }(), this.addAttribute("position", new ot(u, 3)), this.addAttribute("normal", new ot(u.slice(), 3)), this.addAttribute("uv", new ot(d, 2)), 0 === e ? this.computeVertexNormals() : this.normalizeNormals()
        }

        function Ne(t, e) {
            K.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new ze(t, e)), this.mergeVertices()
        }

        function ze(t, e) {
            Ie.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Be(t, e) {
            K.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ue(t, e)), this.mergeVertices()
        }

        function Ue(t, e) {
            Ie.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Fe(t, e) {
            K.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new He(t, e)), this.mergeVertices()
        }

        function He(t, e) {
            var i = (1 + Math.sqrt(5)) / 2;
            Ie.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Ge(t, e) {
            K.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ve(t, e)), this.mergeVertices()
        }

        function Ve(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                n = 1 / i;
            Ie.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function je(t, e, i, n, r, s) {
            K.call(this), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: n,
                closed: r
            }, void 0 !== s && console.warn("THREE.TubeGeometry: taper has been removed."), t = new We(t, e, i, n, r), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices()
        }

        function We(r, s, a, o, t) {
            function e(t) {
                d = r.getPointAt(t / s, d);
                var e = l.normals[t];
                for (t = l.binormals[t], h = 0; h <= o; h++) {
                    var i = h / o * Math.PI * 2,
                        n = Math.sin(i),
                        i = -Math.cos(i);
                    u.x = i * e.x + n * t.x, u.y = i * e.y + n * t.y, u.z = i * e.z + n * t.z, u.normalize(), f.push(u.x, u.y, u.z), c.x = d.x + a * u.x, c.y = d.y + a * u.y, c.z = d.z + a * u.z, p.push(c.x, c.y, c.z)
                }
            }
            ut.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: r,
                tubularSegments: s,
                radius: a,
                radialSegments: o,
                closed: t
            }, s = s || 64, a = a || 1, o = o || 8, t = t || !1;
            var l = r.computeFrenetFrames(s, t);
            this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
            for (var h, c = new St, u = new St, i = new X, d = new St, p = [], f = [], n = [], m = [], g = 0; g < s; g++) e(g);
            for (e(!1 === t ? s : 0), g = 0; g <= s; g++)
                for (h = 0; h <= o; h++) i.x = g / s, i.y = h / o, n.push(i.x, i.y);
            ! function() {
                for (h = 1; h <= s; h++)
                    for (g = 1; g <= o; g++) {
                        var t = (o + 1) * h + (g - 1),
                            e = (o + 1) * h + g,
                            i = (o + 1) * (h - 1) + g;
                        m.push((o + 1) * (h - 1) + (g - 1), t, i), m.push(t, e, i)
                    }
            }(), this.setIndex(m), this.addAttribute("position", new ot(p, 3)), this.addAttribute("normal", new ot(f, 3)), this.addAttribute("uv", new ot(n, 2))
        }

        function Xe(t, e, i, n, r, s, a) {
            K.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: s
            }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new qe(t, e, i, n, r, s)), this.mergeVertices()
        }

        function qe(t, e, i, n, r, s) {
            function a(t, e, i, n, r) {
                var s = Math.sin(t);
                e = i / e * t, i = Math.cos(e), r.x = n * (2 + i) * .5 * Math.cos(t), r.y = n * (2 + i) * s * .5, r.z = n * Math.sin(e) * .5
            }
            ut.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: s
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, s = s || 3;
            for (var o = [], l = [], h = [], c = [], u = new St, d = new St, p = new St, f = new St, m = new St, g = new St, v = new St, _ = 0; _ <= i; ++_) {
                var y = _ / i * r * Math.PI * 2;
                for (a(y, r, s, t, p), a(y + .01, r, s, t, f), g.subVectors(f, p), v.addVectors(f, p), m.crossVectors(g, v), v.crossVectors(m, g), m.normalize(), v.normalize(), y = 0; y <= n; ++y) {
                    var x = y / n * Math.PI * 2,
                        b = -e * Math.cos(x),
                        x = e * Math.sin(x);
                    u.x = p.x + (b * v.x + x * m.x), u.y = p.y + (b * v.y + x * m.y), u.z = p.z + (b * v.z + x * m.z), l.push(u.x, u.y, u.z), d.subVectors(u, p).normalize(), h.push(d.x, d.y, d.z), c.push(_ / i), c.push(y / n)
                }
            }
            for (y = 1; y <= i; y++)
                for (_ = 1; _ <= n; _++) t = (n + 1) * y + (_ - 1), e = (n + 1) * y + _, r = (n + 1) * (y - 1) + _, o.push((n + 1) * (y - 1) + (_ - 1), t, r), o.push(t, e, r);
            this.setIndex(o), this.addAttribute("position", new ot(l, 3)), this.addAttribute("normal", new ot(h, 3)), this.addAttribute("uv", new ot(c, 2))
        }

        function Ye(t, e, i, n, r) {
            K.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, this.fromBufferGeometry(new Ze(t, e, i, n, r)), this.mergeVertices()
        }

        function Ze(t, e, i, n, r) {
            ut.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
            for (var s, a = [], o = [], l = [], h = [], c = new St, u = new St, d = new St, p = 0; p <= i; p++)
                for (s = 0; s <= n; s++) {
                    var f = s / n * r,
                        m = p / i * Math.PI * 2;
                    u.x = (t + e * Math.cos(m)) * Math.cos(f), u.y = (t + e * Math.cos(m)) * Math.sin(f), u.z = e * Math.sin(m), o.push(u.x, u.y, u.z), c.x = t * Math.cos(f), c.y = t * Math.sin(f), d.subVectors(u, c).normalize(), l.push(d.x, d.y, d.z), h.push(s / n), h.push(p / i)
                }
            for (p = 1; p <= i; p++)
                for (s = 1; s <= n; s++) t = (n + 1) * (p - 1) + s - 1, e = (n + 1) * (p - 1) + s, r = (n + 1) * p + s, a.push((n + 1) * p + s - 1, t, r), a.push(t, e, r);
            this.setIndex(a), this.addAttribute("position", new ot(o, 3)), this.addAttribute("normal", new ot(l, 3)), this.addAttribute("uv", new ot(h, 2))
        }

        function Je(t, e, i, n, r) {
            for (var s, a = 0, o = e, l = i - n; o < i; o += n) a += (t[l] - t[o]) * (t[o + 1] + t[l + 1]), l = o;
            if (r === 0 < a)
                for (r = e; r < i; r += n) s = ai(r, t[r], t[r + 1], s);
            else
                for (r = i - n; e <= r; r -= n) s = ai(r, t[r], t[r + 1], s);
            return s && ii(s, s.next) && (oi(s), s = s.next), s
        }

        function Qe(t, e) {
            if (!t) return t;
            e = e || t;
            do {
                var i = !1;
                if (t.steiner || !ii(t, t.next) && 0 !== ei(t.prev, t, t.next)) t = t.next;
                else {
                    if (oi(t), (t = e = t.prev) === t.next) break;
                    i = !0
                }
            } while (i || t !== e);
            return e
        }

        function Ke(t, e) {
            return t.x - e.x
        }

        function $e(t, e, i, n, r) {
            return 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1) | (1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function ti(t, e, i, n, r, s, a, o) {
            return 0 <= (r - a) * (e - o) - (t - a) * (s - o) && 0 <= (t - a) * (n - o) - (i - a) * (e - o) && 0 <= (i - a) * (s - o) - (r - a) * (n - o)
        }

        function ei(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }

        function ii(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function ni(t, e, i, n) {
            return ii(t, e) && ii(i, n) || ii(t, n) && ii(i, e) || 0 < ei(t, e, i) != 0 < ei(t, e, n) && 0 < ei(i, n, t) != 0 < ei(i, n, e)
        }

        function ri(t, e) {
            return ei(t.prev, t, t.next) < 0 ? 0 <= ei(t, e, t.next) && 0 <= ei(t, t.prev, e) : ei(t, e, t.prev) < 0 || ei(t, t.next, e) < 0
        }

        function si(t, e) {
            var i = new li(t.i, t.x, t.y),
                n = new li(e.i, e.x, e.y),
                r = t.next,
                s = e.prev;
            return (t.next = e).prev = t, (i.next = r).prev = i, (n.next = i).prev = n, (s.next = n).prev = s, n
        }

        function ai(t, e, i, n) {
            return t = new li(t, e, i), n ? (t.next = n.next, (t.prev = n).next.prev = t, n.next = t) : (t.prev = t).next = t, t
        }

        function oi(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function li(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
        }

        function hi(t) {
            var e = t.length;
            2 < e && t[e - 1].equals(t[0]) && t.pop()
        }

        function ci(t, e) {
            for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
        }

        function ui(t, e) {
            K.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: t,
                options: e
            }, this.fromBufferGeometry(new di(t, e)), this.mergeVertices()
        }

        function di(t, e) {
            void 0 !== t && (ut.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeVertexNormals())
        }

        function pi(t, e) {
            K.call(this), this.type = "TextGeometry", this.parameters = {
                text: t,
                parameters: e
            }, this.fromBufferGeometry(new fi(t, e)), this.mergeVertices()
        }

        function fi(t, e) {
            var i = (e = e || {}).font;
            if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new K;
            t = i.generateShapes(t, e.size, e.curveSegments), e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), di.call(this, t, e), this.type = "TextBufferGeometry"
        }

        function mi(t, e, i, n, r, s, a) {
            K.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: s,
                thetaLength: a
            }, this.fromBufferGeometry(new gi(t, e, i, n, r, s, a)), this.mergeVertices()
        }

        function gi(t, e, i, n, r, s, a) {
            ut.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: s,
                thetaLength: a
            }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
            for (var o = (s = void 0 !== s ? s : 0) + (a = void 0 !== a ? a : Math.PI), l = 0, h = [], c = new St, u = new St, d = [], p = [], f = [], m = [], g = 0; g <= i; g++) {
                for (var v = [], _ = g / i, y = 0; y <= e; y++) {
                    var x = y / e;
                    c.x = -t * Math.cos(n + x * r) * Math.sin(s + _ * a), c.y = t * Math.cos(s + _ * a), c.z = t * Math.sin(n + x * r) * Math.sin(s + _ * a), p.push(c.x, c.y, c.z), u.set(c.x, c.y, c.z).normalize(), f.push(u.x, u.y, u.z), m.push(x, 1 - _), v.push(l++)
                }
                h.push(v)
            }
            for (g = 0; g < i; g++)
                for (y = 0; y < e; y++) t = h[g][y + 1], n = h[g][y], r = h[g + 1][y], a = h[g + 1][y + 1], (0 !== g || 0 < s) && d.push(t, n, a), (g !== i - 1 || o < Math.PI) && d.push(n, r, a);
            this.setIndex(d), this.addAttribute("position", new ot(p, 3)), this.addAttribute("normal", new ot(f, 3)), this.addAttribute("uv", new ot(m, 2))
        }

        function vi(t, e, i, n, r, s) {
            K.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: n,
                thetaStart: r,
                thetaLength: s
            }, this.fromBufferGeometry(new _i(t, e, i, n, r, s)), this.mergeVertices()
        }

        function _i(t, e, i, n, r, s) {
            ut.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: n,
                thetaStart: r,
                thetaLength: s
            }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, s = void 0 !== s ? s : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
            for (var a, o = [], l = [], h = [], c = [], u = t, d = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1), p = new St, f = new X, m = 0; m <= n; m++) {
                for (a = 0; a <= i; a++) t = r + a / i * s, p.x = u * Math.cos(t), p.y = u * Math.sin(t), l.push(p.x, p.y, p.z), h.push(0, 0, 1), f.x = (p.x / e + 1) / 2, f.y = (p.y / e + 1) / 2, c.push(f.x, f.y);
                u += d
            }
            for (m = 0; m < n; m++)
                for (e = m * (i + 1), a = 0; a < i; a++) r = (t = a + e) + i + 1, s = t + i + 2, u = t + 1, o.push(t, r, u), o.push(r, s, u);
            this.setIndex(o), this.addAttribute("position", new ot(l, 3)), this.addAttribute("normal", new ot(h, 3)), this.addAttribute("uv", new ot(c, 2))
        }

        function yi(t, e, i, n) {
            K.call(this), this.type = "LatheGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: n
            }, this.fromBufferGeometry(new xi(t, e, i, n)), this.mergeVertices()
        }

        function xi(t, e, i, n) {
            ut.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: n
            }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = es.clamp(n, 0, 2 * Math.PI);
            for (var r = [], s = [], a = [], o = 1 / e, l = new St, h = new X, c = 0; c <= e; c++)
                for (var u = i + c * o * n, d = Math.sin(u), p = Math.cos(u), u = 0; u <= t.length - 1; u++) l.x = t[u].x * d, l.y = t[u].y, l.z = t[u].x * p, s.push(l.x, l.y, l.z), h.x = c / e, h.y = u / (t.length - 1), a.push(h.x, h.y);
            for (c = 0; c < e; c++)
                for (u = 0; u < t.length - 1; u++) o = (i = u + c * t.length) + t.length, l = i + t.length + 1, h = i + 1, r.push(i, o, h), r.push(o, l, h);
            if (this.setIndex(r), this.addAttribute("position", new ot(s, 3)), this.addAttribute("uv", new ot(a, 2)), this.computeVertexNormals(), n === 2 * Math.PI)
                for (n = this.attributes.normal.array, r = new St, s = new St, a = new St, i = e * t.length * 3, u = c = 0; c < t.length; c++, u += 3) r.x = n[u + 0], r.y = n[u + 1], r.z = n[u + 2], s.x = n[i + u + 0], s.y = n[i + u + 1], s.z = n[i + u + 2], a.addVectors(r, s).normalize(), n[u + 0] = n[i + u + 0] = a.x, n[u + 1] = n[i + u + 1] = a.y, n[u + 2] = n[i + u + 2] = a.z
        }

        function bi(t, e) {
            K.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                shapes: t,
                curveSegments: e
            }, this.fromBufferGeometry(new wi(t, e)), this.mergeVertices()
        }

        function wi(t, o) {
            function e(t) {
                var e, i = h.length / 3,
                    n = (t = t.extractPoints(o)).shape,
                    r = t.holes;
                if (!1 === Lo.isClockWise(n))
                    for (n = n.reverse(), t = 0, e = r.length; t < e; t++) {
                        var s = r[t];
                        !0 === Lo.isClockWise(s) && (r[t] = s.reverse())
                    }
                var a = Lo.triangulateShape(n, r);
                for (t = 0, e = r.length; t < e; t++) s = r[t], n = n.concat(s);
                for (t = 0, e = n.length; t < e; t++) s = n[t], h.push(s.x, s.y, 0), c.push(0, 0, 1), u.push(s.x, s.y);
                for (t = 0, e = a.length; t < e; t++) n = a[t], l.push(n[0] + i, n[1] + i, n[2] + i), d += 3
            }
            ut.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: t,
                curveSegments: o
            }, o = o || 12;
            var l = [],
                h = [],
                c = [],
                u = [],
                i = 0,
                d = 0;
            if (!1 === Array.isArray(t)) e(t);
            else
                for (var n = 0; n < t.length; n++) e(t[n]), this.addGroup(i, d, n), i += d, d = 0;
            this.setIndex(l), this.addAttribute("position", new ot(h, 3)), this.addAttribute("normal", new ot(c, 3)), this.addAttribute("uv", new ot(u, 2))
        }

        function Ti(t, e) {
            if (e.shapes = [], Array.isArray(t))
                for (var i = 0, n = t.length; i < n; i++) e.shapes.push(t[i].uuid);
            else e.shapes.push(t.uuid);
            return e
        }

        function Mi(t, e) {
            ut.call(this), this.type = "EdgesGeometry", this.parameters = {
                thresholdAngle: e
            };
            var i = [];
            e = Math.cos(es.DEG2RAD * (void 0 !== e ? e : 1));
            var n, r = [0, 0],
                s = {},
                a = ["a", "b", "c"];
            t.isBufferGeometry ? (n = new K).fromBufferGeometry(t) : n = t.clone(), n.mergeVertices(), n.computeFaceNormals(), t = n.vertices;
            for (var o = 0, l = (n = n.faces).length; o < l; o++)
                for (var h = n[o], c = 0; c < 3; c++) {
                    var u = h[a[c]],
                        d = h[a[(c + 1) % 3]];
                    r[0] = Math.min(u, d), r[1] = Math.max(u, d), void 0 === s[u = r[0] + "," + r[1]] ? s[u] = {
                        index1: r[0],
                        index2: r[1],
                        face1: o,
                        face2: void 0
                    } : s[u].face2 = o
                }
            for (u in s)(void 0 === (r = s[u]).face2 || n[r.face1].normal.dot(n[r.face2].normal) <= e) && (a = t[r.index1], i.push(a.x, a.y, a.z), a = t[r.index2], i.push(a.x, a.y, a.z));
            this.addAttribute("position", new ot(i, 3))
        }

        function Ei(t, e, i, n, r, s, a, o) {
            K.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: n,
                heightSegments: r,
                openEnded: s,
                thetaStart: a,
                thetaLength: o
            }, this.fromBufferGeometry(new Si(t, e, i, n, r, s, a, o)), this.mergeVertices()
        }

        function Si(d, p, f, m, g, t, v, _) {
            function e(t) {
                for (var e = new X, i = new St, n = 0, r = !0 === t ? d : p, s = !0 === t ? 1 : -1, a = M, o = 1; o <= m; o++) b.push(0, S * s, 0), w.push(0, s, 0), T.push(.5, .5), M++;
                var l = M;
                for (o = 0; o <= m; o++) {
                    var h = o / m * _ + v,
                        c = Math.cos(h),
                        h = Math.sin(h);
                    i.x = r * h, i.y = S * s, i.z = r * c, b.push(i.x, i.y, i.z), w.push(0, s, 0), e.x = .5 * c + .5, e.y = .5 * h * s + .5, T.push(e.x, e.y), M++
                }
                for (o = 0; o < m; o++) e = a + o, i = l + o, !0 === t ? x.push(i, i + 1, e) : x.push(i + 1, i, e), n += 3;
                y.addGroup(A, n, !0 === t ? 1 : 2), A += n
            }
            ut.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: d,
                radiusBottom: p,
                height: f,
                radialSegments: m,
                heightSegments: g,
                openEnded: t,
                thetaStart: v,
                thetaLength: _
            };
            var y = this;
            d = void 0 !== d ? d : 1, p = void 0 !== p ? p : 1, f = f || 1, m = Math.floor(m) || 8, g = Math.floor(g) || 1, t = void 0 !== t && t, v = void 0 !== v ? v : 0, _ = void 0 !== _ ? _ : 2 * Math.PI;
            var x = [],
                b = [],
                w = [],
                T = [],
                M = 0,
                E = [],
                S = f / 2,
                A = 0;
            ! function() {
                for (var t = new St, e = new St, i = 0, n = (p - d) / f, r = 0; r <= g; r++) {
                    for (var s = [], a = r / g, o = a * (p - d) + d, l = 0; l <= m; l++) {
                        var h = l / m,
                            c = h * _ + v,
                            u = Math.sin(c),
                            c = Math.cos(c);
                        e.x = o * u, e.y = -a * f + S, e.z = o * c, b.push(e.x, e.y, e.z), t.set(u, n, c).normalize(), w.push(t.x, t.y, t.z), T.push(h, 1 - a), s.push(M++)
                    }
                    E.push(s)
                }
                for (l = 0; l < m; l++)
                    for (r = 0; r < g; r++) t = E[r + 1][l], e = E[r + 1][l + 1], n = E[r][l + 1], x.push(E[r][l], t, n), x.push(t, e, n), i += 6;
                y.addGroup(A, i, 0), A += i
            }(), !1 === t && (0 < d && e(!0), 0 < p && e(!1)), this.setIndex(x), this.addAttribute("position", new ot(b, 3)), this.addAttribute("normal", new ot(w, 3)), this.addAttribute("uv", new ot(T, 2))
        }

        function Ai(t, e, i, n, r, s, a) {
            Ei.call(this, 0, t, e, i, n, r, s, a), this.type = "ConeGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: s,
                thetaLength: a
            }
        }

        function Pi(t, e, i, n, r, s, a) {
            Si.call(this, 0, t, e, i, n, r, s, a), this.type = "ConeBufferGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: s,
                thetaLength: a
            }
        }

        function Ci(t, e, i, n) {
            K.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: n
            }, this.fromBufferGeometry(new Ri(t, e, i, n)), this.mergeVertices()
        }

        function Ri(t, e, i, n) {
            ut.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: n
            }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
            var r = [],
                s = [],
                a = [],
                o = [],
                l = new St,
                h = new X;
            s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
            for (var c = 0, u = 3; c <= e; c++, u += 3) {
                var d = i + c / e * n;
                l.x = t * Math.cos(d), l.y = t * Math.sin(d), s.push(l.x, l.y, l.z), a.push(0, 0, 1), h.x = (s[u] / t + 1) / 2, h.y = (s[u + 1] / t + 1) / 2, o.push(h.x, h.y)
            }
            for (u = 1; u <= e; u++) r.push(u, u + 1, 0);
            this.setIndex(r), this.addAttribute("position", new ot(s, 3)), this.addAttribute("normal", new ot(a, 3)), this.addAttribute("uv", new ot(o, 2))
        }

        function Li(t) {
            B.call(this), this.type = "ShadowMaterial", this.color = new N(0), this.opacity = 1, this.transparent = this.lights = !0, this.setValues(t)
        }

        function Oi(t) {
            vt.call(this, t), this.type = "RawShaderMaterial"
        }

        function Di(t) {
            B.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new N(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new N(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function ki(t) {
            Di.call(this), this.defines = {
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t)
        }

        function Ii(t) {
            B.call(this), this.type = "MeshPhongMaterial", this.color = new N(16777215), this.specular = new N(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new N(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function Ni(t) {
            Ii.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
        }

        function zi(t) {
            B.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t)
        }

        function Bi(t) {
            B.call(this), this.type = "MeshLambertMaterial", this.color = new N(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new N(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function Ui(t) {
            be.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
        }

        function Fi(t, e, i) {
            var n = this,
                r = !1,
                s = 0,
                a = 0,
                o = void 0;
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                a++, !1 === r && void 0 !== n.onStart && n.onStart(t, s, a), r = !0
            }, this.itemEnd = function(t) {
                s++, void 0 !== n.onProgress && n.onProgress(t, s, a), s === a && (r = !1, void 0 !== n.onLoad) && n.onLoad()
            }, this.itemError = function(t) {
                void 0 !== n.onError && n.onError(t)
            }, this.resolveURL = function(t) {
                return o ? o(t) : t
            }, this.setURLModifier = function(t) {
                return o = t, this
            }
        }

        function Hi(t) {
            this.manager = void 0 !== t ? t : Io
        }

        function Gi(t) {
            this.manager = void 0 !== t ? t : Io, this._parser = null
        }

        function Vi(t) {
            this.manager = void 0 !== t ? t : Io, this._parser = null
        }

        function ji(t) {
            this.manager = void 0 !== t ? t : Io
        }

        function Wi(t) {
            this.manager = void 0 !== t ? t : Io
        }

        function Xi(t) {
            this.manager = void 0 !== t ? t : Io
        }

        function qi() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function Yi(t, e, i, n, r, s, a, o) {
            qi.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = s || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = o || 0
        }

        function Zi(t, e, i, n, r, s) {
            Yi.call(this, t, e, i, i, n, r, s), this.type = "ArcCurve"
        }

        function Ji() {
            var o = 0,
                l = 0,
                h = 0,
                c = 0;
            return {
                initCatmullRom: function(t, e, i, n, r) {
                    h = -3 * (o = e) + 3 * i - 2 * (l = t = r * (i - t)) - (n = r * (n - e)), c = 2 * e - 2 * i + t + n
                },
                initNonuniformCatmullRom: function(t, e, i, n, r, s, a) {
                    h = -3 * (o = e) + 3 * i - 2 * (l = t = ((e - t) / r - (i - t) / (r + s) + (i - e) / s) * s) - (n = ((i - e) / s - (n - e) / (s + a) + (n - i) / a) * s), c = 2 * e - 2 * i + t + n
                },
                calc: function(t) {
                    var e = t * t;
                    return o + l * t + h * e + c * e * t
                }
            }
        }

        function Qi(t, e, i, n) {
            qi.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
        }

        function Ki(t, e, i, n, r) {
            var s = t * t;
            return (2 * i - 2 * n + (e = .5 * (n - e)) + (r = .5 * (r - i))) * t * s + (-3 * i + 3 * n - 2 * e - r) * s + e * t + i
        }

        function $i(t, e, i, n) {
            var r = 1 - t;
            return r * r * e + 2 * (1 - t) * t * i + t * t * n
        }

        function tn(t, e, i, n, r) {
            var s = 1 - t,
                a = 1 - t;
            return s * s * s * e + 3 * a * a * t * i + 3 * (1 - t) * t * t * n + t * t * t * r
        }

        function en(t, e, i, n) {
            qi.call(this), this.type = "CubicBezierCurve", this.v0 = t || new X, this.v1 = e || new X, this.v2 = i || new X, this.v3 = n || new X
        }

        function nn(t, e, i, n) {
            qi.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new St, this.v1 = e || new St, this.v2 = i || new St, this.v3 = n || new St
        }

        function rn(t, e) {
            qi.call(this), this.type = "LineCurve", this.v1 = t || new X, this.v2 = e || new X
        }

        function sn(t, e) {
            qi.call(this), this.type = "LineCurve3", this.v1 = t || new St, this.v2 = e || new St
        }

        function an(t, e, i) {
            qi.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new X, this.v1 = e || new X, this.v2 = i || new X
        }

        function on(t, e, i) {
            qi.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new St, this.v1 = e || new St, this.v2 = i || new St
        }

        function ln(t) {
            qi.call(this), this.type = "SplineCurve", this.points = t || []
        }

        function hn() {
            qi.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function cn(t) {
            hn.call(this), this.type = "Path", this.currentPoint = new X, t && this.setFromPoints(t)
        }

        function un(t) {
            cn.call(this, t), this.uuid = es.generateUUID(), this.type = "Shape", this.holes = []
        }

        function dn(t, e) {
            Y.call(this), this.type = "Light", this.color = new N(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function pn(t, e, i) {
            dn.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Y.DefaultUp), this.updateMatrix(), this.groundColor = new N(e)
        }

        function fn(t) {
            this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new X(512, 512), this.map = null, this.matrix = new Et
        }

        function mn() {
            fn.call(this, new re(50, 1, .5, 500))
        }

        function gn(t, e, i, n, r, s) {
            dn.call(this, t, e), this.type = "SpotLight", this.position.copy(Y.DefaultUp), this.updateMatrix(), this.target = new Y, Object.defineProperty(this, "power", {
                get: function() {
                    return this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== s ? s : 1, this.shadow = new mn
        }

        function vn(t, e, i, n) {
            dn.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function() {
                    return 4 * this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new fn(new re(90, 1, .5, 500))
        }

        function _n() {
            fn.call(this, new J(-5, 5, 5, -5, .5, 500))
        }

        function yn(t, e) {
            dn.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Y.DefaultUp), this.updateMatrix(), this.target = new Y, this.shadow = new _n
        }

        function xn(t, e) {
            dn.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function bn(t, e, i, n) {
            dn.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
        }

        function wn(t, e, i, n) {
            On.call(this, t, e, i, n)
        }

        function Tn(t, e, i) {
            On.call(this, t, e, i)
        }

        function Mn(t, e, i, n) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
        }

        function En(t, e, i, n) {
            Mn.call(this, t, e, i, n)
        }

        function Sn(t, e, i, n) {
            On.call(this, t, e, i, n)
        }

        function An(t, e, i, n) {
            On.call(this, t, e, i, n)
        }

        function Pn(t, e, i, n) {
            On.call(this, t, e, i, n)
        }

        function Cn(t, e, i, n) {
            Mn.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
        }

        function Rn(t, e, i, n) {
            Mn.call(this, t, e, i, n)
        }

        function Ln(t, e, i, n) {
            Mn.call(this, t, e, i, n)
        }

        function On(t, e, i, n) {
            if (void 0 === t) throw Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = Go.convertArray(e, this.TimeBufferType), this.values = Go.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize()
        }

        function Dn(t, e, i, n) {
            On.call(this, t, e, i, n)
        }

        function kn(t, e, i) {
            this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = es.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
        }

        function In(t) {
            this.manager = void 0 !== t ? t : Io, this.textures = {}
        }

        function Nn(t) {
            this.manager = void 0 !== t ? t : Io
        }

        function zn() {
            this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
        }

        function Bn(t) {
            "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : Io, this.withCredentials = !1
        }

        function Un(t) {
            this.manager = void 0 !== t ? t : Io, this.texturePath = ""
        }

        function Fn(t) {
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : Io, this.options = void 0
        }

        function Hn() {
            this.type = "ShapePath", this.subPaths = [], this.currentPath = null
        }

        function Gn(t) {
            this.type = "Font", this.data = t
        }

        function Vn(t) {
            this.manager = void 0 !== t ? t : Io
        }

        function jn(t) {
            this.manager = void 0 !== t ? t : Io
        }

        function Wn() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new re, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new re, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
        }

        function Xn(t, e, i) {
            Y.call(this), this.type = "CubeCamera";
            var r = new re(90, 1, t, e);
            r.up.set(0, -1, 0), r.lookAt(new St(1, 0, 0)), this.add(r);
            var s = new re(90, 1, t, e);
            s.up.set(0, -1, 0), s.lookAt(new St(-1, 0, 0)), this.add(s);
            var a = new re(90, 1, t, e);
            a.up.set(0, 0, 1), a.lookAt(new St(0, 1, 0)), this.add(a);
            var o = new re(90, 1, t, e);
            o.up.set(0, 0, -1), o.lookAt(new St(0, -1, 0)), this.add(o);
            var l = new re(90, 1, t, e);
            l.up.set(0, -1, 0), l.lookAt(new St(0, 0, 1)), this.add(l);
            var h = new re(90, 1, t, e);
            h.up.set(0, -1, 0), h.lookAt(new St(0, 0, -1)), this.add(h), this.renderTarget = new n(i, i, {
                format: 1022,
                magFilter: 1006,
                minFilter: 1006
            }), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                null === this.parent && this.updateMatrixWorld();
                var i = this.renderTarget,
                    n = i.texture.generateMipmaps;
                i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, r, i), i.activeCubeFace = 1, t.render(e, s, i), i.activeCubeFace = 2, t.render(e, a, i), i.activeCubeFace = 3, t.render(e, o, i), i.activeCubeFace = 4, t.render(e, l, i), i.texture.generateMipmaps = n, i.activeCubeFace = 5, t.render(e, h, i), t.setRenderTarget(null)
            }, this.clear = function(t, e, i, n) {
                for (var r = this.renderTarget, s = 0; s < 6; s++) r.activeCubeFace = s, t.setRenderTarget(r), t.clear(e, i, n);
                t.setRenderTarget(null)
            }
        }

        function qn() {
            Y.call(this), this.type = "AudioListener", this.context = Yl.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
        }

        function Yn(t) {
            Y.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function Zn(t) {
            Yn.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
        }

        function Jn(t, e) {
            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
        }

        function Qn(t, e, i) {
            switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
                case "quaternion":
                    e = this._slerp;
                    break;
                case "string":
                case "bool":
                    t = Array, e = this._select;
                    break;
                default:
                    e = this._lerp
            }
            this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0
        }

        function Kn(t, e, i) {
            i = i || $n.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i)
        }

        function $n(t, e, i) {
            this.path = e, this.parsedPath = i || $n.parseTrackName(e), this.node = $n.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function tr() {
            this.uuid = es.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var t = {};
            this._indicesByUUID = t;
            for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var n = this;
            this.stats = {
                objects: {
                    get total() {
                        return n._objects.length
                    },
                    get inUse() {
                        return this.total - n.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return n._bindings.length
                }
            }
        }

        function er(t, e, i) {
            this._mixer = t, this._clip = e, this._localRoot = i || null, e = (t = e.tracks).length, i = Array(e);
            for (var n = {
                    endingStart: 2400,
                    endingEnd: 2400
                }, r = 0; r !== e; ++r) {
                var s = t[r].createInterpolant(null);
                (i[r] = s).settings = n
            }
            this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
        }

        function ir(t) {
            this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
        }

        function nr(t, e) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t
        }

        function rr() {
            ut.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function sr(t, e, i, n) {
            this.uuid = es.generateUUID(), this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
        }

        function ar(t, e) {
            this.uuid = es.generateUUID(), this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function() {}, this.version = 0
        }

        function or(t, e, i) {
            ar.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function lr(t, e, i) {
            $.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function hr(t, e, i, n) {
            this.ray = new _t(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function cr(t, e) {
            return t.distance - e.distance
        }

        function ur(t, e, i, n) {
            if (!1 !== t.visible && (t.raycast(e, i), !0 === n)) {
                n = 0;
                for (var r = (t = t.children).length; n < r; n++) ur(t[n], e, i, !0)
            }
        }

        function dr(t) {
            this.autoStart = void 0 === t || t, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
        }

        function pr(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
        }

        function fr(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
        }

        function mr(t) {
            Y.call(this), this.material = t, this.render = function() {}
        }

        function gr(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new ut, e = new ot(6 * e, 3), i.addAttribute("position", e), Te.call(this, i, new be({
                color: t,
                linewidth: n
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function vr(t, e) {
            Y.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new ut, e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
            for (var i = 0, n = 1; i < 32; i++, n++) {
                var r = i / 32 * Math.PI * 2,
                    s = n / 32 * Math.PI * 2;
                e.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
            }
            t.addAttribute("position", new ot(e, 3)), e = new be({
                fog: !1
            }), this.cone = new Te(t, e), this.add(this.cone), this.update()
        }

        function _r(t) {
            for (var e = function t(e) {
                    var i = [];
                    e && e.isBone && i.push(e);
                    for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
                    return i
                }(t), i = new ut, n = [], r = [], s = new N(0, 0, 1), a = new N(0, 1, 0), o = 0; o < e.length; o++) {
                var l = e[o];
                l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
            }
            i.addAttribute("position", new ot(n, 3)), i.addAttribute("color", new ot(r, 3)), n = new be({
                vertexColors: 2,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            }), Te.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
        }

        function yr(t, e, i) {
            this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new gi(e, 4, 2), e = new gt({
                wireframe: !0,
                fog: !1
            }), bt.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function xr(t, e) {
            Y.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new be({
                fog: !1
            }), (e = new ut).addAttribute("position", new $(new Float32Array(15), 3)), this.line = new we(e, t), this.add(this.line), this.update()
        }

        function br(t, e, i) {
            Y.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, (t = new Ue(e)).rotateY(.5 * Math.PI), this.material = new gt({
                wireframe: !0,
                fog: !1
            }), void 0 === this.color && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new $(e, 3)), this.add(new bt(t, this.material)), this.update()
        }

        function wr(t, e, i, n) {
            t = t || 10, e = e || 10, i = new N(void 0 !== i ? i : 4473924), n = new N(void 0 !== n ? n : 8947848);
            var r = e / 2,
                s = t / e,
                a = t / 2;
            t = [];
            for (var o = [], l = 0, h = 0, c = -a; l <= e; l++, c += s) {
                t.push(-a, 0, c, a, 0, c), t.push(c, 0, -a, c, 0, a);
                var u = l === r ? i : n;
                u.toArray(o, h), h += 3, u.toArray(o, h), h += 3, u.toArray(o, h), h += 3, u.toArray(o, h), h += 3
            }(e = new ut).addAttribute("position", new ot(t, 3)), e.addAttribute("color", new ot(o, 3)), i = new be({
                vertexColors: 2
            }), Te.call(this, e, i)
        }

        function Tr(t, e, i, n, r, s) {
            t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new N(void 0 !== r ? r : 4473924), s = new N(void 0 !== s ? s : 8947848);
            for (var a = [], o = [], l = 0; l <= e; l++) {
                var h = l / e * 2 * Math.PI,
                    c = Math.sin(h) * t,
                    h = Math.cos(h) * t;
                a.push(0, 0, 0), a.push(c, 0, h);
                var u = 1 & l ? r : s;
                o.push(u.r, u.g, u.b), o.push(u.r, u.g, u.b)
            }
            for (l = 0; l <= i; l++) {
                u = 1 & l ? r : s;
                var d = t - t / i * l;
                for (e = 0; e < n; e++) h = e / n * 2 * Math.PI, c = Math.sin(h) * d, h = Math.cos(h) * d, a.push(c, 0, h), o.push(u.r, u.g, u.b), h = (e + 1) / n * 2 * Math.PI, c = Math.sin(h) * d, h = Math.cos(h) * d, a.push(c, 0, h), o.push(u.r, u.g, u.b)
            }(t = new ut).addAttribute("position", new ot(a, 3)), t.addAttribute("color", new ot(o, 3)), a = new be({
                vertexColors: 2
            }), Te.call(this, t, a)
        }

        function Mr(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new ut, e = new ot(6 * e, 3), i.addAttribute("position", e), Te.call(this, i, new be({
                color: t,
                linewidth: n
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Er(t, e, i) {
            Y.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1), (t = new ut).addAttribute("position", new ot([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)), e = new be({
                fog: !1
            }), this.lightPlane = new we(t, e), this.add(this.lightPlane), (t = new ut).addAttribute("position", new ot([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new we(t, e), this.add(this.targetLine), this.update()
        }

        function Sr(t) {
            function e(t, e, i) {
                n(t, i), n(e, i)
            }

            function n(t, e) {
                s.push(0, 0, 0), a.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(s.length / 3 - 1)
            }
            var i = new ut,
                r = new be({
                    color: 16777215,
                    vertexColors: 1
                }),
                s = [],
                a = [],
                o = {},
                l = new N(16755200),
                h = new N(16711680),
                c = new N(43775),
                u = new N(16777215),
                d = new N(3355443);
            e("n1", "n2", l), e("n2", "n4", l), e("n4", "n3", l), e("n3", "n1", l), e("f1", "f2", l), e("f2", "f4", l), e("f4", "f3", l), e("f3", "f1", l), e("n1", "f1", l), e("n2", "f2", l), e("n3", "f3", l), e("n4", "f4", l), e("p", "n1", h), e("p", "n2", h), e("p", "n3", h), e("p", "n4", h), e("u1", "u2", c), e("u2", "u3", c), e("u3", "u1", c), e("c", "t", u), e("p", "c", d), e("cn1", "cn2", d), e("cn3", "cn4", d), e("cf1", "cf2", d), e("cf3", "cf4", d), i.addAttribute("position", new ot(s, 3)), i.addAttribute("color", new ot(a, 3)), Te.call(this, i, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
        }

        function Ar(t, e) {
            this.object = t, void 0 === e && (e = 16776960), t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var i = new Float32Array(24),
                n = new ut;
            n.setIndex(new $(t, 1)), n.addAttribute("position", new $(i, 3)), Te.call(this, n, new be({
                color: e
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Pr(t, e) {
            this.type = "Box3Helper", this.box = t, t = void 0 !== e ? e : 16776960, e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var i = new ut;
            i.setIndex(new $(e, 1)), i.addAttribute("position", new ot([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Te.call(this, i, new be({
                color: t
            })), this.geometry.computeBoundingSphere()
        }

        function Cr(t, e, i) {
            this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e, t = void 0 !== i ? i : 16776960, (e = new ut).addAttribute("position", new ot([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), e.computeBoundingSphere(), we.call(this, e, new be({
                color: t
            })), (e = new ut).addAttribute("position", new ot([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), e.computeBoundingSphere(), this.add(new bt(e, new gt({
                color: t,
                opacity: .2,
                transparent: !0,
                depthWrite: !1
            })))
        }

        function Rr(t, e, i, n, r, s) {
            Y.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === s && (s = .2 * r), void 0 === Vl && ((Vl = new ut).addAttribute("position", new ot([0, 0, 0, 0, 1, 0], 3)), (jl = new Si(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new we(Vl, new be({
                color: n
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new bt(jl, new gt({
                color: n
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, s)
        }

        function Lr(t) {
            var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
            (t = new ut).addAttribute("position", new ot(e, 3)), t.addAttribute("color", new ot([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), e = new be({
                vertexColors: 2
            }), Te.call(this, t, e)
        }

        function Or(t) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, t), this.type = "catmullrom", this.closed = !0
        }

        function Dr(t) {
            console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, t), this.type = "catmullrom"
        }

        function kr(t) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, t), this.type = "catmullrom"
        }
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), void 0 === Math.sign && (Math.sign = function(t) {
            return t < 0 ? -1 : 0 < t ? 1 : +t
        }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && (Object.assign = function(t) {
            if (null == t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (null != n)
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }), Object.assign(e.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var i = this._listeners;
                void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners) return !1;
                var i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                void 0 !== this._listeners && (void 0 !== (t = this._listeners[t]) && (-1 !== (e = t.indexOf(e)) && t.splice(e, 1)))
            },
            dispatchEvent: function(t) {
                if (void 0 !== this._listeners && void 0 !== (e = this._listeners[t.type])) {
                    t.target = this;
                    for (var e, i = 0, n = (e = e.slice(0)).length; i < n; i++) e[i].call(this, t)
                }
            }
        });
        var Ir, Nr, zr, Br, Ur, Fr, Hr, Gr, Vr, jr, Wr, Xr, qr, Yr, Zr, Jr, Qr, Kr, $r, ts, es = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                for (var r = [], t = 0; t < 256; t++) r[t] = (t < 16 ? "0" : "") + t.toString(16).toUpperCase();
                return function() {
                    var t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0;
                    return r[255 & t] + r[t >> 8 & 255] + r[t >> 16 & 255] + r[t >> 24 & 255] + "-" + r[255 & e] + r[e >> 8 & 255] + "-" + r[e >> 16 & 15 | 64] + r[e >> 24 & 255] + "-" + r[63 & i | 128] + r[i >> 8 & 255] + "-" + r[i >> 16 & 255] + r[i >> 24 & 255] + r[255 & n] + r[n >> 8 & 255] + r[n >> 16 & 255] + r[n >> 24 & 255]
                }
            }(),
            clamp: function(t, e, i) {
                return Math.max(e, Math.min(i, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, i, n, r) {
                return n + (t - e) * (r - n) / (i - e)
            },
            lerp: function(t, e, i) {
                return (1 - i) * t + i * e
            },
            smoothstep: function(t, e, i) {
                return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * es.DEG2RAD
            },
            radToDeg: function(t) {
                return t * es.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            }
        };
        Object.defineProperties(X.prototype, {
            width: {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            },
            height: {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }
        }), Object.assign(X.prototype, {
            isVector2: !0,
            set: function(t, e) {
                return this.x = t, this.y = e, this
            },
            setScalar: function(t) {
                return this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            },
            multiply: function(t) {
                return this.x *= t.x, this.y *= t.y, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            applyMatrix3: function(t) {
                var e = this.x,
                    i = this.y;
                return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            },
            clampScalar: (Ir = new X, Nr = new X, function(t, e) {
                return Ir.set(t, t), Nr.set(e, e), this.clamp(Ir, Nr)
            }),
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            angle: function() {
                var t = Math.atan2(this.y, this.x);
                return t < 0 && (t += 2 * Math.PI), t
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x;
                return e * e + (t = this.y - t.y) * t
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            },
            rotateAround: function(t, e) {
                var i = Math.cos(e);
                e = Math.sin(e);
                var n = this.x - t.x,
                    r = this.y - t.y;
                return this.x = n * i - r * e + t.x, this.y = n * e + r * i + t.y, this
            }
        }), Object.assign(Et.prototype, {
            isMatrix4: !0,
            set: function(t, e, i, n, r, s, a, o, l, h, c, u, d, p, f, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new Et).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements;
                return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this
            },
            copyPosition: function(t) {
                var e = this.elements;
                return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this
            },
            extractBasis: function(t, e, i) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function(t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: (Vr = new St, function(t) {
                var e = this.elements,
                    i = t.elements,
                    n = 1 / Vr.setFromMatrixColumn(t, 0).length(),
                    r = 1 / Vr.setFromMatrixColumn(t, 1).length();
                return t = 1 / Vr.setFromMatrixColumn(t, 2).length(), e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[8] = i[8] * t, e[9] = i[9] * t, e[10] = i[10] * t, this
            }),
            makeRotationFromEuler: function(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e, i, n, r = this.elements,
                    s = t.x,
                    a = t.y,
                    o = t.z,
                    l = Math.cos(s),
                    s = Math.sin(s),
                    h = Math.cos(a),
                    a = Math.sin(a),
                    c = Math.cos(o),
                    o = Math.sin(o);
                return "XYZ" === t.order ? (e = l * c, i = l * o, n = s * c, t = s * o, r[0] = h * c, r[4] = -h * o, r[8] = a, r[1] = i + n * a, r[5] = e - t * a, r[9] = -s * h, r[2] = t - e * a, r[6] = n + i * a, r[10] = l * h) : "YXZ" === t.order ? (e = h * c, i = h * o, n = a * c, t = a * o, r[0] = e + t * s, r[4] = n * s - i, r[8] = l * a, r[1] = l * o, r[5] = l * c, r[9] = -s, r[2] = i * s - n, r[6] = t + e * s, r[10] = l * h) : "ZXY" === t.order ? (e = h * c, i = h * o, n = a * c, t = a * o, r[0] = e - t * s, r[4] = -l * o, r[8] = n + i * s, r[1] = i + n * s, r[5] = l * c, r[9] = t - e * s, r[2] = -l * a, r[6] = s, r[10] = l * h) : "ZYX" === t.order ? (e = l * c, i = l * o, n = s * c, t = s * o, r[0] = h * c, r[4] = n * a - i, r[8] = e * a + t, r[1] = h * o, r[5] = t * a + e, r[9] = i * a - n, r[2] = -a, r[6] = s * h, r[10] = l * h) : "YZX" === t.order ? (e = l * h, i = l * a, n = s * h, t = s * a, r[0] = h * c, r[4] = t - e * o, r[8] = n * o + i, r[1] = o, r[5] = l * c, r[9] = -s * c, r[2] = -a * c, r[6] = i * o + n, r[10] = e - t * o) : "XZY" === t.order && (e = l * h, i = l * a, n = s * h, t = s * a, r[0] = h * c, r[4] = -o, r[8] = a * c, r[1] = e * o + t, r[5] = l * c, r[9] = i * o - n, r[2] = n * o - i, r[6] = s * c, r[10] = t * o + e), r[3] = 0, r[7] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, this
            },
            makeRotationFromQuaternion: function(t) {
                var e = this.elements,
                    i = t._x,
                    n = t._y,
                    r = t._z,
                    s = t._w,
                    a = r + r;
                t = i * (h = i + i);
                var o = i * (c = n + n),
                    i = i * a,
                    l = n * c,
                    n = n * a,
                    r = r * a,
                    h = s * h,
                    c = s * c,
                    s = s * a;
                return e[0] = 1 - (l + r), e[4] = o - s, e[8] = i + c, e[1] = o + s, e[5] = 1 - (t + r), e[9] = n - h, e[2] = i - c, e[6] = n + h, e[10] = 1 - (t + l), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            lookAt: (Fr = new St, Hr = new St, Gr = new St, function(t, e, i) {
                var n = this.elements;
                return Gr.subVectors(t, e), 0 === Gr.lengthSq() && (Gr.z = 1), Gr.normalize(), Fr.crossVectors(i, Gr), 0 === Fr.lengthSq() && (1 === Math.abs(i.z) ? Gr.x += 1e-4 : Gr.z += 1e-4, Gr.normalize(), Fr.crossVectors(i, Gr)), Fr.normalize(), Hr.crossVectors(Gr, Fr), n[0] = Fr.x, n[4] = Hr.x, n[8] = Gr.x, n[1] = Fr.y, n[5] = Hr.y, n[9] = Gr.y, n[2] = Fr.z, n[6] = Hr.z, n[10] = Gr.z, this
            }),
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements;
                e = this.elements, t = i[0];
                var r = i[4],
                    s = i[8],
                    a = i[12],
                    o = i[1],
                    l = i[5],
                    h = i[9],
                    c = i[13],
                    u = i[2],
                    d = i[6],
                    p = i[10],
                    f = i[14],
                    m = i[3],
                    g = i[7],
                    v = i[11],
                    i = i[15],
                    _ = n[0],
                    y = n[4],
                    x = n[8],
                    b = n[12],
                    w = n[1],
                    T = n[5],
                    M = n[9],
                    E = n[13],
                    S = n[2],
                    A = n[6],
                    P = n[10],
                    C = n[14],
                    R = n[3],
                    L = n[7],
                    O = n[11],
                    n = n[15];
                return e[0] = t * _ + r * w + s * S + a * R, e[4] = t * y + r * T + s * A + a * L, e[8] = t * x + r * M + s * P + a * O, e[12] = t * b + r * E + s * C + a * n, e[1] = o * _ + l * w + h * S + c * R, e[5] = o * y + l * T + h * A + c * L, e[9] = o * x + l * M + h * P + c * O, e[13] = o * b + l * E + h * C + c * n, e[2] = u * _ + d * w + p * S + f * R, e[6] = u * y + d * T + p * A + f * L, e[10] = u * x + d * M + p * P + f * O, e[14] = u * b + d * E + p * C + f * n, e[3] = m * _ + g * w + v * S + i * R, e[7] = m * y + g * T + v * A + i * L, e[11] = m * x + g * M + v * P + i * O, e[15] = m * b + g * E + v * C + i * n, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            },
            applyToBufferAttribute: (Ur = new St, function(t) {
                for (var e = 0, i = t.count; e < i; e++) Ur.x = t.getX(e), Ur.y = t.getY(e), Ur.z = t.getZ(e), Ur.applyMatrix4(this), t.setXYZ(e, Ur.x, Ur.y, Ur.z);
                return t
            }),
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[4],
                    n = t[8],
                    r = t[12],
                    s = t[1],
                    a = t[5],
                    o = t[9],
                    l = t[13],
                    h = t[2],
                    c = t[6],
                    u = t[10],
                    d = t[14];
                return t[3] * (+r * o * c - n * l * c - r * a * u + i * l * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - n * s * d + n * l * h - r * o * h) + t[11] * (+e * l * c - e * a * d - r * s * c + i * s * d + r * a * h - i * l * h) + t[15] * (-n * a * h - e * o * c + e * a * u + n * s * c - i * s * u + i * o * h)
            },
            transpose: function() {
                var t = this.elements,
                    e = t[1];
                return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            },
            setPosition: function(t) {
                var e = this.elements;
                return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
            },
            getInverse: function(t, e) {
                var i = this.elements,
                    n = t.elements;
                t = n[0];
                var r = n[1],
                    s = n[2],
                    a = n[3],
                    o = n[4],
                    l = n[5],
                    h = n[6],
                    c = n[7],
                    u = n[8],
                    d = n[9],
                    p = n[10],
                    f = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    _ = d * v * c - g * p * c + g * h * f - l * v * f - d * h * (n = n[15]) + l * p * n,
                    y = m * p * c - u * v * c - m * h * f + o * v * f + u * h * n - o * p * n,
                    x = u * g * c - m * d * c + m * l * f - o * g * f - u * l * n + o * d * n,
                    b = m * d * h - u * g * h - m * l * p + o * g * p + u * l * v - o * d * v,
                    w = t * _ + r * y + s * x + a * b;
                if (0 != w) return e = 1 / w, i[0] = _ * e, i[1] = (g * p * a - d * v * a - g * s * f + r * v * f + d * s * n - r * p * n) * e, i[2] = (l * v * a - g * h * a + g * s * c - r * v * c - l * s * n + r * h * n) * e, i[3] = (d * h * a - l * p * a - d * s * c + r * p * c + l * s * f - r * h * f) * e, i[4] = y * e, i[5] = (u * v * a - m * p * a + m * s * f - t * v * f - u * s * n + t * p * n) * e, i[6] = (m * h * a - o * v * a - m * s * c + t * v * c + o * s * n - t * h * n) * e, i[7] = (o * p * a - u * h * a + u * s * c - t * p * c - o * s * f + t * h * f) * e, i[8] = x * e, i[9] = (m * d * a - u * g * a - m * r * f + t * g * f + u * r * n - t * d * n) * e, i[10] = (o * g * a - m * l * a + m * r * c - t * g * c - o * r * n + t * l * n) * e, i[11] = (u * l * a - o * d * a - u * r * c + t * d * c + o * r * f - t * l * f) * e, i[12] = b * e, i[13] = (u * g * s - m * d * s + m * r * p - t * g * p - u * r * v + t * d * v) * e, i[14] = (m * l * s - o * g * s - m * r * h + t * g * h + o * r * v - t * l * v) * e, i[15] = (o * d * s - u * l * s + u * r * h - t * d * h - o * r * p + t * l * p) * e, this;
                if (!0 === e) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            },
            scale: function(t) {
                var e = this.elements,
                    i = t.x,
                    n = t.y;
                return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this
            },
            getMaxScaleOnAxis: function() {
                var t = this.elements;
                return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
            },
            makeTranslation: function(t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
            },
            makeRotationX: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function(t, e) {
                var i = Math.cos(e);
                e = Math.sin(e);
                var n = 1 - i,
                    r = t.x,
                    s = t.y;
                t = t.z;
                var a = n * r,
                    o = n * s;
                return this.set(a * r + i, a * s - e * t, a * t + e * s, 0, a * s + e * t, o * s + i, o * t - e * r, 0, a * t - e * s, o * t + e * r, n * t * t + i, 0, 0, 0, 0, 1), this
            },
            makeScale: function(t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
            },
            makeShear: function(t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
            },
            compose: function(t, e, i) {
                return this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this
            },
            decompose: (zr = new St, Br = new Et, function(t, e, i) {
                var n = this.elements,
                    r = zr.set(n[0], n[1], n[2]).length(),
                    s = zr.set(n[4], n[5], n[6]).length(),
                    a = zr.set(n[8], n[9], n[10]).length();
                this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Br.copy(this), t = 1 / r;
                var n = 1 / s,
                    o = 1 / a;
                return Br.elements[0] *= t, Br.elements[1] *= t, Br.elements[2] *= t, Br.elements[4] *= n, Br.elements[5] *= n, Br.elements[6] *= n, Br.elements[8] *= o, Br.elements[9] *= o, Br.elements[10] *= o, e.setFromRotationMatrix(Br), i.x = r, i.y = s, i.z = a, this
            }),
            makePerspective: function(t, e, i, n, r, s) {
                void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var a = this.elements;
                return a[0] = 2 * r / (e - t), a[4] = 0, a[8] = (e + t) / (e - t), a[12] = 0, a[1] = 0, a[5] = 2 * r / (i - n), a[9] = (i + n) / (i - n), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(s + r) / (s - r), a[14] = -2 * s * r / (s - r), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            },
            makeOrthographic: function(t, e, i, n, r, s) {
                var a = this.elements,
                    o = 1 / (e - t),
                    l = 1 / (i - n),
                    h = 1 / (s - r);
                return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -(e + t) * o, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -(i + n) * l, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -(s + r) * h, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            },
            equals: function(t) {
                var e = this.elements;
                t = t.elements;
                for (var i = 0; i < 16; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
            }
        }), Object.assign(o, {
            slerp: function(t, e, i, n) {
                return i.copy(t).slerp(e, n)
            },
            slerpFlat: function(t, e, i, n, r, s, a) {
                var o = i[n + 0],
                    l = i[n + 1],
                    h = i[n + 2];
                i = i[n + 3], n = r[s + 0];
                var c, u, d, p = r[s + 1],
                    f = r[s + 2];
                i === (r = r[s + 3]) && o === n && l === p && h === f || (s = 1 - a, u = 0 <= (c = o * n + l * p + h * f + i * r) ? 1 : -1, (d = 1 - c * c) > Number.EPSILON && (d = Math.sqrt(d), c = Math.atan2(d, c * u), s = Math.sin(s * c) / d, a = Math.sin(a * c) / d), o = o * s + n * (u *= a), l = l * s + p * u, h = h * s + f * u, i = i * s + r * u, s === 1 - a && (o *= a = 1 / Math.sqrt(o * o + l * l + h * h + i * i), l *= a, h *= a, i *= a)), t[e] = o, t[e + 1] = l, t[e + 2] = h, t[e + 3] = i
            }
        }), Object.defineProperties(o.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            w: {
                get: function() {
                    return this._w
                },
                set: function(t) {
                    this._w = t, this.onChangeCallback()
                }
            }
        }), Object.assign(o.prototype, {
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
            },
            setFromEuler: function(t, e) {
                if (!t || !t.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var i = t._x,
                    n = t._y,
                    r = t._z;
                t = t.order;
                var s = Math.cos,
                    a = Math.sin,
                    o = s(i / 2),
                    l = s(n / 2),
                    s = s(r / 2),
                    i = a(i / 2),
                    n = a(n / 2),
                    r = a(r / 2);
                return "XYZ" === t ? (this._x = i * l * s + o * n * r, this._y = o * n * s - i * l * r, this._z = o * l * r + i * n * s, this._w = o * l * s - i * n * r) : "YXZ" === t ? (this._x = i * l * s + o * n * r, this._y = o * n * s - i * l * r, this._z = o * l * r - i * n * s, this._w = o * l * s + i * n * r) : "ZXY" === t ? (this._x = i * l * s - o * n * r, this._y = o * n * s + i * l * r, this._z = o * l * r + i * n * s, this._w = o * l * s - i * n * r) : "ZYX" === t ? (this._x = i * l * s - o * n * r, this._y = o * n * s + i * l * r, this._z = o * l * r - i * n * s, this._w = o * l * s + i * n * r) : "YZX" === t ? (this._x = i * l * s + o * n * r, this._y = o * n * s + i * l * r, this._z = o * l * r - i * n * s, this._w = o * l * s - i * n * r) : "XZY" === t && (this._x = i * l * s - o * n * r, this._y = o * n * s - i * l * r, this._z = o * l * r + i * n * s, this._w = o * l * s + i * n * r), !1 !== e && this.onChangeCallback(), this
            },
            setFromAxisAngle: function(t, e) {
                e /= 2;
                var i = Math.sin(e);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(t) {
                var e = t.elements,
                    i = e[0];
                t = e[4];
                var n = e[8],
                    r = e[1],
                    s = e[5],
                    a = e[9],
                    o = e[2],
                    l = e[6],
                    h = i + s + (e = e[10]);
                return 0 < h ? (i = .5 / Math.sqrt(h + 1), this._w = .25 / i, this._x = (l - a) * i, this._y = (n - o) * i, this._z = (r - t) * i) : s < i && e < i ? (i = 2 * Math.sqrt(1 + i - s - e), this._w = (l - a) / i, this._x = .25 * i, this._y = (t + r) / i, this._z = (n + o) / i) : e < s ? (i = 2 * Math.sqrt(1 + s - i - e), this._w = (n - o) / i, this._x = (t + r) / i, this._y = .25 * i, this._z = (a + l) / i) : (i = 2 * Math.sqrt(1 + e - i - s), this._w = (r - t) / i, this._x = (n + o) / i, this._y = (a + l) / i, this._z = .25 * i), this.onChangeCallback(), this
            },
            setFromUnitVectors: (Wr = new St, function(t, e) {
                return void 0 === Wr && (Wr = new St), (jr = t.dot(e) + 1) < 1e-6 ? (jr = 0, Math.abs(t.x) > Math.abs(t.z) ? Wr.set(-t.y, t.x, 0) : Wr.set(0, -t.z, t.y)) : Wr.crossVectors(t, e), this._x = Wr.x, this._y = Wr.y, this._z = Wr.z, this._w = jr, this.normalize()
            }),
            inverse: function() {
                return this.conjugate().normalize()
            },
            conjugate: function() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
            },
            dot: function(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function() {
                var t = this.length();
                return 0 === t ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            },
            premultiply: function(t) {
                return this.multiplyQuaternions(t, this)
            },
            multiplyQuaternions: function(t, e) {
                var i = t._x,
                    n = t._y,
                    r = t._z;
                t = t._w;
                var s = e._x,
                    a = e._y,
                    o = e._z;
                return e = e._w, this._x = i * e + t * s + n * o - r * a, this._y = n * e + t * a + r * s - i * o, this._z = r * e + t * o + i * a - n * s, this._w = t * e - i * s - n * a - r * o, this.onChangeCallback(), this
            },
            slerp: function(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var i = this._x,
                    n = this._y,
                    r = this._z,
                    s = this._w;
                if ((o = s * t._w + i * t._x + n * t._y + r * t._z) < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), 1 <= o) return this._w = s, this._x = i, this._y = n, this._z = r, this;
                if (t = Math.sqrt(1 - o * o), Math.abs(t) < .001) return this._w = .5 * (s + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z), this;
                var a = Math.atan2(t, o),
                    o = Math.sin((1 - e) * a) / t;
                return e = Math.sin(e * a) / t, this._w = s * o + this._w * e, this._x = i * o + this._x * e, this._y = n * o + this._y * e, this._z = r * o + this._z * e, this.onChangeCallback(), this
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            },
            onChange: function(t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function() {}
        }), Object.assign(St.prototype, {
            isVector3: !0,
            set: function(t, e, i) {
                return this.x = t, this.y = e, this.z = i, this
            },
            setScalar: function(t) {
                return this.z = this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            },
            multiplyVectors: function(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            },
            applyEuler: ($r = new o, function(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion($r.setFromEuler(t))
            }),
            applyAxisAngle: (Kr = new o, function(t, e) {
                return this.applyQuaternion(Kr.setFromAxisAngle(t, e))
            }),
            applyMatrix3: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z;
                return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = 1 / ((t = t.elements)[3] * e + t[7] * i + t[11] * n + t[15]);
                return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * r, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * r, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * r, this
            },
            applyQuaternion: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.x,
                    s = t.y,
                    a = t.z,
                    o = (t = t.w) * e + s * n - a * i,
                    l = t * i + a * e - r * n,
                    h = t * n + r * i - s * e,
                    e = -r * e - s * i - a * n;
                return this.x = o * t + e * -r + l * -a - h * -s, this.y = l * t + e * -s + h * -r - o * -a, this.z = h * t + e * -a + o * -s - l * -r, this
            },
            project: (Qr = new Et, function(t) {
                return Qr.multiplyMatrices(t.projectionMatrix, Qr.getInverse(t.matrixWorld)), this.applyMatrix4(Qr)
            }),
            unproject: (Jr = new Et, function(t) {
                return Jr.multiplyMatrices(t.matrixWorld, Jr.getInverse(t.projectionMatrix)), this.applyMatrix4(Jr)
            }),
            transformDirection: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z;
                return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize()
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            },
            clampScalar: (Yr = new St, Zr = new St, function(t, e) {
                return Yr.set(t, t, t), Zr.set(e, e, e), this.clamp(Yr, Zr)
            }),
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            cross: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            },
            crossVectors: function(t, e) {
                var i = t.x,
                    n = t.y;
                t = t.z;
                var r = e.x,
                    s = e.y;
                return e = e.z, this.x = n * e - t * s, this.y = t * r - i * e, this.z = i * s - n * r, this
            },
            projectOnVector: function(t) {
                var e = t.dot(this) / t.lengthSq();
                return this.copy(t).multiplyScalar(e)
            },
            projectOnPlane: (qr = new St, function(t) {
                return qr.copy(this).projectOnVector(t), this.sub(qr)
            }),
            reflect: (Xr = new St, function(t) {
                return this.sub(Xr.copy(t).multiplyScalar(2 * this.dot(t)))
            }),
            angleTo: function(t) {
                return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(es.clamp(t, -1, 1))
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x,
                    i = this.y - t.y;
                return e * e + i * i + (t = this.z - t.z) * t
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            },
            setFromSpherical: function(t) {
                var e = Math.sin(t.phi) * t.radius;
                return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
            },
            setFromCylindrical: function(t) {
                return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
            },
            setFromMatrixPosition: function(t) {
                return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this
            },
            setFromMatrixScale: function(t) {
                var e = this.setFromMatrixColumn(t, 0).length(),
                    i = this.setFromMatrixColumn(t, 1).length();
                return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this
            },
            setFromMatrixColumn: function(t, e) {
                return this.fromArray(t.elements, 4 * e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
        }), Object.assign(g.prototype, {
            isMatrix3: !0,
            set: function(t, e, i, n, r, s, a, o, l) {
                var h = this.elements;
                return h[0] = t, h[1] = n, h[2] = a, h[3] = e, h[4] = r, h[5] = o, h[6] = i, h[7] = s, h[8] = l, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements;
                return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this
            },
            setFromMatrix4: function(t) {
                return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            },
            applyToBufferAttribute: (ts = new St, function(t) {
                for (var e = 0, i = t.count; e < i; e++) ts.x = t.getX(e), ts.y = t.getY(e), ts.z = t.getZ(e), ts.applyMatrix3(this), t.setXYZ(e, ts.x, ts.y, ts.z);
                return t
            }),
            multiply: function(t) {
                return this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements;
                e = this.elements, t = i[0];
                var r = i[3],
                    s = i[6],
                    a = i[1],
                    o = i[4],
                    l = i[7],
                    h = i[2],
                    c = i[5],
                    i = i[8],
                    u = n[0],
                    d = n[3],
                    p = n[6],
                    f = n[1],
                    m = n[4],
                    g = n[7],
                    v = n[2],
                    _ = n[5],
                    n = n[8];
                return e[0] = t * u + r * f + s * v, e[3] = t * d + r * m + s * _, e[6] = t * p + r * g + s * n, e[1] = a * u + o * f + l * v, e[4] = a * d + o * m + l * _, e[7] = a * p + o * g + l * n, e[2] = h * u + c * f + i * v, e[5] = h * d + c * m + i * _, e[8] = h * p + c * g + i * n, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            },
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[1],
                    n = t[2],
                    r = t[3],
                    s = t[4],
                    a = t[5],
                    o = t[6],
                    l = t[7];
                return e * s * (t = t[8]) - e * a * l - i * r * t + i * a * o + n * r * l - n * s * o
            },
            getInverse: function(t, e) {
                t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                var i = t.elements;
                t = this.elements;
                var n = i[0],
                    r = i[1],
                    s = i[2],
                    a = i[3],
                    o = i[4],
                    l = i[5],
                    h = i[6],
                    c = i[7],
                    u = (i = i[8]) * o - l * c,
                    d = l * h - i * a,
                    p = c * a - o * h,
                    f = n * u + r * d + s * p;
                if (0 != f) return e = 1 / f, t[0] = u * e, t[1] = (s * c - i * r) * e, t[2] = (l * r - s * o) * e, t[3] = d * e, t[4] = (i * n - s * h) * e, t[5] = (s * a - l * n) * e, t[6] = p * e, t[7] = (r * h - c * n) * e, t[8] = (o * n - r * a) * e, this;
                if (!0 === e) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            },
            transpose: function() {
                var t = this.elements,
                    e = t[1];
                return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            },
            getNormalMatrix: function(t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            },
            transposeIntoArray: function(t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            },
            setUvTransform: function(t, e, i, n, r, s, a) {
                var o = Math.cos(r);
                r = Math.sin(r), this.set(i * o, i * r, -i * (o * s + r * a) + s + t, -n * r, n * o, -n * (-r * s + o * a) + a + e, 0, 0, 1)
            },
            scale: function(t, e) {
                var i = this.elements;
                return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
            },
            rotate: function(t) {
                var e = Math.cos(t);
                t = Math.sin(t);
                var i = this.elements,
                    n = i[0],
                    r = i[3],
                    s = i[6],
                    a = i[1],
                    o = i[4],
                    l = i[7];
                return i[0] = e * n + t * a, i[3] = e * r + t * o, i[6] = e * s + t * l, i[1] = -t * n + e * a, i[4] = -t * r + e * o, i[7] = -t * s + e * l, this
            },
            translate: function(t, e) {
                var i = this.elements;
                return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
            },
            equals: function(t) {
                var e = this.elements;
                t = t.elements;
                for (var i = 0; i < 9; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
            }
        });
        var is, ns, rs = 0;
        d.DEFAULT_IMAGE = void 0, d.DEFAULT_MAPPING = 300, d.prototype = Object.assign(Object.create(e.prototype), {
            constructor: d,
            isTexture: !0,
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var i, n, r, s, a, o, l = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY
                };
                return void 0 !== this.image && (void 0 === (i = this.image).uuid && (i.uuid = es.generateUUID()), e || void 0 !== t.images[i.uuid] || (n = t.images, r = i.uuid, s = i.uuid, i instanceof HTMLCanvasElement ? a = i : ((a = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = i.width, a.height = i.height, o = a.getContext("2d"), i instanceof ImageData ? o.putImageData(i, 0, 0) : o.drawImage(i, 0, 0, i.width, i.height)), a = 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png"), n[r] = {
                    uuid: s,
                    url: a
                }), l.image = i.uuid), e || (t.textures[this.uuid] = l), l
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(t) {
                if (300 === this.mapping) {
                    if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) {
                        case 1e3:
                            t.x -= Math.floor(t.x);
                            break;
                        case 1001:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case 1002:
                            t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || 1 < t.y) switch (this.wrapT) {
                        case 1e3:
                            t.y -= Math.floor(t.y);
                            break;
                        case 1001:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case 1002:
                            t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y)
                    }
                    this.flipY && (t.y = 1 - t.y)
                }
            }
        }), Object.defineProperty(d.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(At.prototype, {
            isVector4: !0,
            set: function(t, e, i, n) {
                return this.x = t, this.y = e, this.z = i, this.w = n, this
            },
            setScalar: function(t) {
                return this.w = this.z = this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setW: function(t) {
                return this.w = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = this.w;
                return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * r, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * r, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * r, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * r, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function(t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            },
            setAxisAngleFromRotationMatrix: function(t) {
                var e = (t = t.elements)[0],
                    i = t[4],
                    n = t[8],
                    r = t[1],
                    s = t[5],
                    a = t[9],
                    o = t[2],
                    l = t[6],
                    h = t[10];
                return Math.abs(i - r) < .01 && Math.abs(n - o) < .01 && Math.abs(a - l) < .01 ? Math.abs(i + r) < .1 && Math.abs(n + o) < .1 && Math.abs(a + l) < .1 && Math.abs(e + s + h - 3) < .1 ? this.set(1, 0, 0, 0) : (t = Math.PI, h = (h + 1) / 2, i = (i + r) / 4, n = (n + o) / 4, a = (a + l) / 4, (s = (s + 1) / 2) < (e = (e + 1) / 2) && h < e ? i = e < .01 ? (l = 0, o = .707106781) : (o = i / (l = Math.sqrt(e)), n / l) : h < s ? i = s < .01 ? (o = 0, l = .707106781) : (l = i / (o = Math.sqrt(s)), a / o) : h < .01 ? (o = l = .707106781, i = 0) : (l = n / (i = Math.sqrt(h)), o = a / i), this.set(l, o, i, t)) : (t = Math.sqrt((l - a) * (l - a) + (n - o) * (n - o) + (r - i) * (r - i)), Math.abs(t) < .001 && (t = 1), this.x = (l - a) / t, this.y = (n - o) / t, this.z = (r - i) / t, this.w = Math.acos((e + s + h - 1) / 2)), this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            },
            clampScalar: function(t, e) {
                return void 0 === is && (is = new At, ns = new At), is.set(t, t, t, t), ns.set(e, e, e, e), this.clamp(is, ns)
            },
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
        }), S.prototype = Object.assign(Object.create(e.prototype), {
            constructor: S,
            isWebGLRenderTarget: !0,
            setSize: function(t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), ((n.prototype = Object.create(S.prototype)).constructor = n).prototype.isWebGLRenderTargetCube = !0, ((Pt.prototype = Object.create(d.prototype)).constructor = Pt).prototype.isDataTexture = !0, ((l.prototype = Object.create(d.prototype)).constructor = l).prototype.isCubeTexture = !0, Object.defineProperty(l.prototype, "images", {
            get: function() {
                return this.image
            },
            set: function(t) {
                this.image = t
            }
        });
        var ss = new d,
            as = new l,
            os = [],
            ls = [],
            hs = new Float32Array(16),
            cs = new Float32Array(9);
        I.prototype.setValue = function(t, e) {
            for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
                var s = i[n];
                s.setValue(t, e[s.id])
            }
        };
        var us = /([\w\d_]+)(\])?(\[|\.)?/g;
        Ct.prototype.setValue = function(t, e, i) {
            void 0 !== (e = this.map[e]) && e.setValue(t, i, this.renderer)
        }, Ct.prototype.setOptional = function(t, e, i) {
            void 0 !== (e = e[i]) && this.setValue(t, i, e)
        }, Ct.upload = function(t, e, i, n) {
            for (var r = 0, s = e.length; r !== s; ++r) {
                var a = e[r],
                    o = i[a.id];
                !1 !== o.needsUpdate && a.setValue(t, o.value, n)
            }
        }, Ct.seqWithValue = function(t, e) {
            for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                var s = t[n];
                s.id in e && i.push(s)
            }
            return i
        };
        var ds = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };

        function ps(t, e, i) {
            return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
        }
        Object.assign(N.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            },
            setScalar: function(t) {
                return this.b = this.g = this.r = t, this
            },
            setHex: function(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            },
            setRGB: function(t, e, i) {
                return this.r = t, this.g = e, this.b = i, this
            },
            setHSL: function(t, e, i) {
                return t = es.euclideanModulo(t, 1), e = es.clamp(e, 0, 1), i = es.clamp(i, 0, 1), 0 === e ? this.r = this.g = this.b = i : (i = 2 * i - (e = i <= .5 ? i * (1 + e) : i + e - i * e), this.r = ps(i, e, t + 1 / 3), this.g = ps(i, e, t), this.b = ps(i, e, t - 1 / 3)), this
            },
            setStyle: function(e) {
                function t(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                var i;
                if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                    var n = i[2];
                    switch (i[1]) {
                        case "rgb":
                        case "rgba":
                            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                            if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                                var n = parseFloat(i[1]) / 360,
                                    r = parseInt(i[2], 10) / 100,
                                    s = parseInt(i[3], 10) / 100;
                                return t(i[5]), this.setHSL(n, r, s)
                            }
                    }
                } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                    if (3 === (n = (i = i[1]).length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                    if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
                }
                return e && 0 < e.length && (void 0 !== (i = ds[e]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + e)), this
            },
            clone: function() {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            },
            copyGammaToLinear: function(t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            copyLinearToGamma: function(t, e) {
                return void 0 === e && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            convertGammaToLinear: function() {
                var t = this.r,
                    e = this.g,
                    i = this.b;
                return this.r = t * t, this.g = e * e, this.b = i * i, this
            },
            convertLinearToGamma: function() {
                return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
            },
            getHex: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function(t) {
                t = t || {
                    h: 0,
                    s: 0,
                    l: 0
                };
                var e, i = this.r,
                    n = this.g,
                    r = this.b,
                    s = Math.max(i, n, r),
                    a = ((l = Math.min(i, n, r)) + s) / 2;
                if (l === s) l = e = 0;
                else {
                    var o = s - l,
                        l = a <= .5 ? o / (s + l) : o / (2 - s - l);
                    switch (s) {
                        case i:
                            e = (n - r) / o + (n < r ? 6 : 0);
                            break;
                        case n:
                            e = (r - i) / o + 2;
                            break;
                        case r:
                            e = (i - n) / o + 4
                    }
                    e /= 6
                }
                return t.h = e, t.s = l, t.l = a, t
            },
            getStyle: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function(t, e, i) {
                var n = this.getHSL();
                return n.h += t, n.s += e, n.l += i, this.setHSL(n.h, n.s, n.l), this
            },
            add: function(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            },
            addColors: function(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            },
            addScalar: function(t) {
                return this.r += t, this.g += t, this.b += t, this
            },
            sub: function(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            },
            multiply: function(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            },
            multiplyScalar: function(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            },
            lerp: function(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            },
            equals: function(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            },
            toJSON: function() {
                return this.getHex()
            }
        });
        var fs, ms, gs = {
                common: {
                    diffuse: {
                        value: new N(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new g
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new X(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new N(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new N(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new g
                    }
                }
            },
            vs = {
                merge: function(t) {
                    for (var e = {}, i = 0; i < t.length; i++) {
                        var n, r = this.clone(t[i]);
                        for (n in r) e[n] = r[n]
                    }
                    return e
                },
                clone: function(t) {
                    var e, i = {};
                    for (e in t)
                        for (var n in i[e] = {}, t[e]) {
                            var r = t[e][n];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[e][n] = r.clone() : Array.isArray(r) ? i[e][n] = r.slice() : i[e][n] = r
                        }
                    return i
                }
            },
            _s = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "\nvec3 transformed = vec3( position );\n",
                beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
            },
            ys = {
                basic: {
                    uniforms: vs.merge([gs.common, gs.specularmap, gs.envmap, gs.aomap, gs.lightmap, gs.fog]),
                    vertexShader: _s.meshbasic_vert,
                    fragmentShader: _s.meshbasic_frag
                },
                lambert: {
                    uniforms: vs.merge([gs.common, gs.specularmap, gs.envmap, gs.aomap, gs.lightmap, gs.emissivemap, gs.fog, gs.lights, {
                        emissive: {
                            value: new N(0)
                        }
                    }]),
                    vertexShader: _s.meshlambert_vert,
                    fragmentShader: _s.meshlambert_frag
                },
                phong: {
                    uniforms: vs.merge([gs.common, gs.specularmap, gs.envmap, gs.aomap, gs.lightmap, gs.emissivemap, gs.bumpmap, gs.normalmap, gs.displacementmap, gs.gradientmap, gs.fog, gs.lights, {
                        emissive: {
                            value: new N(0)
                        },
                        specular: {
                            value: new N(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: _s.meshphong_vert,
                    fragmentShader: _s.meshphong_frag
                },
                standard: {
                    uniforms: vs.merge([gs.common, gs.envmap, gs.aomap, gs.lightmap, gs.emissivemap, gs.bumpmap, gs.normalmap, gs.displacementmap, gs.roughnessmap, gs.metalnessmap, gs.fog, gs.lights, {
                        emissive: {
                            value: new N(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: .5
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: _s.meshphysical_vert,
                    fragmentShader: _s.meshphysical_frag
                },
                points: {
                    uniforms: vs.merge([gs.points, gs.fog]),
                    vertexShader: _s.points_vert,
                    fragmentShader: _s.points_frag
                },
                dashed: {
                    uniforms: vs.merge([gs.common, gs.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: _s.linedashed_vert,
                    fragmentShader: _s.linedashed_frag
                },
                depth: {
                    uniforms: vs.merge([gs.common, gs.displacementmap]),
                    vertexShader: _s.depth_vert,
                    fragmentShader: _s.depth_frag
                },
                normal: {
                    uniforms: vs.merge([gs.common, gs.bumpmap, gs.normalmap, gs.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: _s.normal_vert,
                    fragmentShader: _s.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: _s.cube_vert,
                    fragmentShader: _s.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: _s.equirect_vert,
                    fragmentShader: _s.equirect_frag
                },
                distanceRGBA: {
                    uniforms: vs.merge([gs.common, gs.displacementmap, {
                        referencePosition: {
                            value: new St
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: _s.distanceRGBA_vert,
                    fragmentShader: _s.distanceRGBA_frag
                },
                shadow: {
                    uniforms: vs.merge([gs.lights, gs.fog, {
                        color: {
                            value: new N(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: _s.shadow_vert,
                    fragmentShader: _s.shadow_frag
                }
            };
        ys.physical = {
            uniforms: vs.merge([ys.standard.uniforms, {
                clearCoat: {
                    value: 0
                },
                clearCoatRoughness: {
                    value: 0
                }
            }]),
            vertexShader: _s.meshphysical_vert,
            fragmentShader: _s.meshphysical_frag
        }, Object.assign(z.prototype, {
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: (ms = new X, function(t, e) {
                return e = ms.copy(e).multiplyScalar(.5), this.min.copy(t).sub(e), this.max.copy(t).add(e), this
            }),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function(t) {
                return t = t || new X, this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return t = t || new X, this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function(t, e) {
                return (e || new X).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function(t, e) {
                return (e || new X).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: (fs = new X, function(t) {
                return fs.copy(t).clamp(this.min, this.max).sub(t).length()
            }),
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), (H.prototype = Object.create(d.prototype)).constructor = H;
        var xs, bs, ws, Ts, Ms, Es, Ss, As, Ps, Cs, Rs, Ls, Os, Ds, ks, Is, Ns, zs, Bs, Us, Fs, Hs = 0;

        function Gs(t) {
            var e = t.geometry;
            if (void 0 !== e)
                if (e.isGeometry)
                    for (e = e.vertices, Es = 0, Ss = e.length; Es < Ss; Es++) As.copy(e[Es]), As.applyMatrix4(t.matrixWorld), Ms.expandByPoint(As);
                else if (e.isBufferGeometry && void 0 !== (e = e.attributes.position))
                for (Es = 0, Ss = e.count; Es < Ss; Es++) As.fromBufferAttribute(e, Es).applyMatrix4(t.matrixWorld), Ms.expandByPoint(As)
        }
        B.prototype = Object.assign(Object.create(e.prototype), {
            constructor: B,
            isMaterial: !0,
            onBeforeCompile: function() {},
            setValues: function(t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var i, n = t[e];
                        void 0 === n ? console.warn("THREE.Material: '" + e + "' parameter is undefined.") : "shading" === e ? (console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n) : void 0 === (i = this[e]) ? console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = "overdraw" === e ? Number(n) : n
                    }
            },
            toJSON: function(t) {
                function e(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        delete n.metadata, i.push(n)
                    }
                    return i
                }
                var i = void 0 === t || "string" == typeof t;
                i && (t = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                var e = t.clippingPlanes,
                    i = null;
                if (null !== e)
                    for (var n = e.length, i = Array(n), r = 0; r !== n; ++r) i[r] = e[r].clone();
                return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), ((U.prototype = Object.create(B.prototype)).constructor = U).prototype.isMeshDepthMaterial = !0, U.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, ((F.prototype = Object.create(B.prototype)).constructor = F).prototype.isMeshDistanceMaterial = !0, F.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        }, Object.assign(G.prototype, {
            isBox3: !0,
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromArray: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, l = t.length; o < l; o += 3) {
                    var h = t[o],
                        c = t[o + 1],
                        u = t[o + 2];
                    h < e && (e = h), c < i && (i = c), u < n && (n = u), r < h && (r = h), s < c && (s = c), a < u && (a = u)
                }
                return this.min.set(e, i, n), this.max.set(r, s, a), this
            },
            setFromBufferAttribute: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, l = t.count; o < l; o++) {
                    var h = t.getX(o),
                        c = t.getY(o),
                        u = t.getZ(o);
                    h < e && (e = h), c < i && (i = c), u < n && (n = u), r < h && (r = h), s < c && (s = c), a < u && (a = u)
                }
                return this.min.set(e, i, n), this.max.set(r, s, a), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: (Ps = new St, function(t, e) {
                return e = Ps.copy(e).multiplyScalar(.5), this.min.copy(t).sub(e), this.max.copy(t).add(e), this
            }),
            setFromObject: function(t) {
                return this.makeEmpty(), this.expandByObject(t)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function(t) {
                return t = t || new St, this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return t = t || new St, this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            expandByObject: (As = new St, function(t) {
                return Ms = this, t.updateMatrixWorld(!0), t.traverse(Gs), this
            }),
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function(t, e) {
                return (e || new St).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: (Ts = new St, function(t) {
                return this.clampPoint(t.center, Ts), Ts.distanceToSquared(t.center) <= t.radius * t.radius
            }),
            intersectsPlane: function(t) {
                var e, i = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x);
                return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= t.constant && i >= t.constant
            },
            clampPoint: function(t, e) {
                return (e || new St).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: (ws = new St, function(t) {
                return ws.copy(t).clamp(this.min, this.max).sub(t).length()
            }),
            getBoundingSphere: (bs = new St, function(t) {
                return t = t || new V, this.getCenter(t.center), t.radius = .5 * this.getSize(bs).length(), t
            }),
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            applyMatrix4: (xs = [new St, new St, new St, new St, new St, new St, new St, new St], function(t) {
                return this.isEmpty() || (xs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), xs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), xs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), xs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), xs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), xs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), xs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), xs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(xs)), this
            }),
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), Object.assign(V.prototype, {
            set: function(t, e) {
                return this.center.copy(t), this.radius = e, this
            },
            setFromPoints: (Cs = new G, function(t, e) {
                var i = this.center;
                void 0 !== e ? i.copy(e) : Cs.setFromPoints(t).getCenter(i);
                for (var n = e = 0, r = t.length; n < r; n++) e = Math.max(e, i.distanceToSquared(t[n]));
                return this.radius = Math.sqrt(e), this
            }),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            },
            empty: function() {
                return this.radius <= 0
            },
            containsPoint: function(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function(t) {
                return t.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function(t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            },
            intersectsBox: function(t) {
                return t.intersectsSphere(this)
            },
            intersectsPlane: function(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            },
            clampPoint: function(t, e) {
                var i = this.center.distanceToSquared(t);
                return (e = e || new St).copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            },
            getBoundingBox: function(t) {
                return (t = t || new G).set(this.center, this.center), t.expandByScalar(this.radius), t
            },
            applyMatrix4: function(t) {
                return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this
            },
            translate: function(t) {
                return this.center.add(t), this
            },
            equals: function(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        }), Object.assign(j.prototype, {
            set: function(t, e) {
                return this.normal.copy(t), this.constant = e, this
            },
            setComponents: function(t, e, i, n) {
                return this.normal.set(t, e, i), this.constant = n, this
            },
            setFromNormalAndCoplanarPoint: function(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            },
            setFromCoplanarPoints: (Ds = new St, ks = new St, function(t, e, i) {
                return e = Ds.subVectors(i, e).cross(ks.subVectors(t, e)).normalize(), this.setFromNormalAndCoplanarPoint(e, t), this
            }),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            },
            normalize: function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            },
            negate: function() {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function(t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function(t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function(t, e) {
                return (e || new St).copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            },
            intersectLine: (Os = new St, function(t, e) {
                e = e || new St;
                var i = t.delta(Os),
                    n = this.normal.dot(i);
                if (0 === n) {
                    if (0 === this.distanceToPoint(t.start)) return e.copy(t.start)
                } else if (!((n = -(t.start.dot(this.normal) + this.constant) / n) < 0 || 1 < n)) return e.copy(i).multiplyScalar(n).add(t.start)
            }),
            intersectsLine: function(t) {
                var e = this.distanceToPoint(t.start);
                return t = this.distanceToPoint(t.end), e < 0 && 0 < t || t < 0 && 0 < e
            },
            intersectsBox: function(t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function(t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function(t) {
                return (t || new St).copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: (Rs = new St, Ls = new g, function(t, e) {
                return e = e || Ls.getNormalMatrix(t), t = this.coplanarPoint(Rs).applyMatrix4(t), e = this.normal.applyMatrix3(e).normalize(), this.constant = -t.dot(e), this
            }),
            translate: function(t) {
                return this.constant -= t.dot(this.normal), this
            },
            equals: function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        }), Object.assign(Ot.prototype, {
            set: function(t, e, i, n, r, s) {
                var a = this.planes;
                return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(s), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                return this
            },
            setFromMatrix: function(t) {
                var e = this.planes;
                t = (g = t.elements)[0];
                var i = g[1],
                    n = g[2],
                    r = g[3],
                    s = g[4],
                    a = g[5],
                    o = g[6],
                    l = g[7],
                    h = g[8],
                    c = g[9],
                    u = g[10],
                    d = g[11],
                    p = g[12],
                    f = g[13],
                    m = g[14],
                    g = g[15];
                return e[0].setComponents(r - t, l - s, d - h, g - p).normalize(), e[1].setComponents(r + t, l + s, d + h, g + p).normalize(), e[2].setComponents(r + i, l + a, d + c, g + f).normalize(), e[3].setComponents(r - i, l - a, d - c, g - f).normalize(), e[4].setComponents(r - n, l - o, d - u, g - m).normalize(), e[5].setComponents(r + n, l + o, d + u, g + m).normalize(), this
            },
            intersectsObject: (Bs = new V, function(t) {
                var e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), Bs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Bs)
            }),
            intersectsSprite: (zs = new V, function(t) {
                return zs.center.set(0, 0, 0), zs.radius = .7071067811865476, zs.applyMatrix4(t.matrixWorld), this.intersectsSphere(zs)
            }),
            intersectsSphere: function(t) {
                var e = this.planes,
                    i = t.center;
                t = -t.radius;
                for (var n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(i) < t) return !1;
                return !0
            },
            intersectsBox: (Is = new St, Ns = new St, function(t) {
                for (var e = this.planes, i = 0; i < 6; i++) {
                    var n = e[i];
                    Is.x = (0 < n.normal.x ? t.min : t.max).x, Ns.x = (0 < n.normal.x ? t.max : t.min).x, Is.y = (0 < n.normal.y ? t.min : t.max).y, Ns.y = (0 < n.normal.y ? t.max : t.min).y, Is.z = (0 < n.normal.z ? t.min : t.max).z, Ns.z = (0 < n.normal.z ? t.max : t.min).z;
                    var r = n.distanceToPoint(Is),
                        n = n.distanceToPoint(Ns);
                    if (r < 0 && n < 0) return !1
                }
                return !0
            }),
            containsPoint: function(t) {
                for (var e = this.planes, i = 0; i < 6; i++)
                    if (e[i].distanceToPoint(t) < 0) return !1;
                return !0
            }
        }), W.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), W.DefaultOrder = "XYZ", Object.defineProperties(W.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            order: {
                get: function() {
                    return this._order
                },
                set: function(t) {
                    this._order = t, this.onChangeCallback()
                }
            }
        }), Object.assign(W.prototype, {
            isEuler: !0,
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(t, e, i) {
                var n = es.clamp;
                t = (u = t.elements)[0];
                var r = u[4],
                    s = u[8],
                    a = u[1],
                    o = u[5],
                    l = u[9],
                    h = u[2],
                    c = u[6],
                    u = u[10];
                return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, u), this._z = Math.atan2(-r, t)) : (this._x = Math.atan2(c, o), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(s, u), this._z = Math.atan2(a, o)) : (this._y = Math.atan2(-h, t), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(-h, u), this._z = Math.atan2(-r, o)) : (this._y = 0, this._z = Math.atan2(a, t))) : "ZYX" === e ? (this._y = Math.asin(-n(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(c, u), this._z = Math.atan2(a, t)) : (this._x = 0, this._z = Math.atan2(-r, o))) : "YZX" === e ? (this._z = Math.asin(n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(-l, o), this._y = Math.atan2(-h, t)) : (this._x = 0, this._y = Math.atan2(s, u))) : "XZY" === e ? (this._z = Math.asin(-n(r, -1, 1)), Math.abs(r) < .99999 ? (this._x = Math.atan2(c, o), this._y = Math.atan2(s, t)) : (this._x = Math.atan2(-l, u), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
            },
            setFromQuaternion: (Fs = new Et, function(t, e, i) {
                return Fs.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Fs, e, i)
            }),
            setFromVector3: function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: (Us = new o, function(t) {
                return Us.setFromEuler(this), this.setFromQuaternion(Us, t)
            }),
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            },
            toVector3: function(t) {
                return t ? t.set(this._x, this._y, this._z) : new St(this._x, this._y, this._z)
            },
            onChange: function(t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function() {}
        }), Object.assign(q.prototype, {
            set: function(t) {
                this.mask = 1 << t | 0
            },
            enable: function(t) {
                this.mask = this.mask | 1 << t | 0
            },
            toggle: function(t) {
                this.mask ^= 1 << t | 0
            },
            disable: function(t) {
                this.mask &= ~(1 << t | 0)
            },
            test: function(t) {
                return 0 != (this.mask & t.mask)
            }
        });
        var Vs, js, Ws, Xs, qs, Ys, Zs, Js, Qs, Ks, $s, ta, ea, ia, na, ra, sa, aa, oa, la = 0;
        Y.DefaultUp = new St(0, 1, 0), Y.DefaultMatrixAutoUpdate = !0, Y.prototype = Object.assign(Object.create(e.prototype), {
            constructor: Y,
            isObject3D: !0,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix: function(t) {
                this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function(t) {
                return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: (aa = new o, function(t, e) {
                return aa.setFromAxisAngle(t, e), this.quaternion.multiply(aa), this
            }),
            rotateOnWorldAxis: (sa = new o, function(t, e) {
                return sa.setFromAxisAngle(t, e), this.quaternion.premultiply(sa), this
            }),
            rotateX: (ra = new St(1, 0, 0), function(t) {
                return this.rotateOnAxis(ra, t)
            }),
            rotateY: (na = new St(0, 1, 0), function(t) {
                return this.rotateOnAxis(na, t)
            }),
            rotateZ: (ia = new St(0, 0, 1), function(t) {
                return this.rotateOnAxis(ia, t)
            }),
            translateOnAxis: (ea = new St, function(t, e) {
                return ea.copy(t).applyQuaternion(this.quaternion), this.position.add(ea.multiplyScalar(e)), this
            }),
            translateX: (ta = new St(1, 0, 0), function(t) {
                return this.translateOnAxis(ta, t)
            }),
            translateY: ($s = new St(0, 1, 0), function(t) {
                return this.translateOnAxis($s, t)
            }),
            translateZ: (Ks = new St(0, 0, 1), function(t) {
                return this.translateOnAxis(Ks, t)
            }),
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: (Qs = new Et, function(t) {
                return t.applyMatrix4(Qs.getInverse(this.matrixWorld))
            }),
            lookAt: (Zs = new Et, Js = new St, function(t, e, i) {
                t.isVector3 ? Js.copy(t) : Js.set(t, e, i), this.isCamera ? Zs.lookAt(this.position, Js, this.up) : Zs.lookAt(Js, this.position, this.up), this.quaternion.setFromRotationMatrix(Zs)
            }),
            add: function(t) {
                if (1 < arguments.length) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", t) : t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                    type: "added"
                }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this
            },
            remove: function(t) {
                if (1 < arguments.length) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                return -1 !== (e = this.children.indexOf(t)) && (t.parent = null, t.dispatchEvent({
                    type: "removed"
                }), this.children.splice(e, 1)), this
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e) return this;
                for (var i = 0, n = this.children.length; i < n; i++) {
                    var r = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            },
            getWorldPosition: function(t) {
                return t = t || new St, this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: (qs = new St, Ys = new St, function(t) {
                return t = t || new o, this.updateMatrixWorld(!0), this.matrixWorld.decompose(qs, t, Ys), t
            }),
            getWorldRotation: (Xs = new o, function(t) {
                return t = t || new W, this.getWorldQuaternion(Xs), t.setFromQuaternion(Xs, this.rotation.order, !1)
            }),
            getWorldScale: (js = new St, Ws = new o, function(t) {
                return t = t || new St, this.updateMatrixWorld(!0), this.matrixWorld.decompose(js, Ws, t), t
            }),
            getWorldDirection: (Vs = new o, function(t) {
                return t = t || new St, this.getWorldQuaternion(Vs), t.set(0, 0, 1).applyQuaternion(Vs)
            }),
            raycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
            },
            traverseVisible: function(t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t = !(this.matrixWorldNeedsUpdate = !1));
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
            },
            toJSON: function(i) {
                function t(t, e) {
                    return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(i)), e.uuid
                }

                function e(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        delete n.metadata, i.push(n)
                    }
                    return i
                }
                var n = void 0 === i || "string" == typeof i,
                    r = {};
                n && (i = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, r.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var s, a = {};
                if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.matrix = this.matrix.toArray(), void 0 !== this.geometry) {
                    a.geometry = t(i.geometries, this.geometry);
                    var o = this.geometry.parameters;
                    if (void 0 !== o && void 0 !== o.shapes)
                        if (o = o.shapes, Array.isArray(o))
                            for (var l = 0, h = o.length; l < h; l++) t(i.shapes, o[l]);
                        else t(i.shapes, o)
                }
                if (void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        for (o = [], l = 0, h = this.material.length; l < h; l++) o.push(t(i.materials, this.material[l]));
                        a.material = o
                    } else a.material = t(i.materials, this.material);
                if (0 < this.children.length)
                    for (a.children = [], l = 0; l < this.children.length; l++) a.children.push(this.children[l].toJSON(i).object);
                return n && (n = e(i.geometries), l = e(i.materials), h = e(i.textures), s = e(i.images), o = e(i.shapes), 0 < n.length && (r.geometries = n), 0 < l.length && (r.materials = l), 0 < h.length && (r.textures = h), 0 < s.length && (r.images = s), 0 < o.length && (r.shapes = o)), r.object = a, r
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (e = 0; e < t.children.length; e++) this.add(t.children[e].clone());
                return this
            }
        }), Z.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: Z,
            isCamera: !0,
            copy: function(t, e) {
                return Y.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
            },
            getWorldDirection: (oa = new o, function(t) {
                return t = t || new St, this.getWorldQuaternion(oa), t.set(0, 0, -1).applyQuaternion(oa)
            }),
            updateMatrixWorld: function(t) {
                Y.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), J.prototype = Object.assign(Object.create(Z.prototype), {
            constructor: J,
            isOrthographicCamera: !0,
            copy: function(t, e) {
                return Z.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function(t, e, i, n, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t, e = (this.right - this.left) / (2 * this.zoom),
                    i = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2,
                    s = n - e,
                    n = n + e,
                    e = r + i,
                    i = r - i;
                null !== this.view && this.view.enabled && (n = this.zoom / (this.view.width / this.view.fullWidth), i = this.zoom / (this.view.height / this.view.fullHeight), t = (this.right - this.left) / this.view.width, r = (this.top - this.bottom) / this.view.height, n = (s += this.view.offsetX / n * t) + this.view.width / n * t, i = (e -= this.view.offsetY / i * r) - this.view.height / i * r), this.projectionMatrix.makeOrthographic(s, n, e, i, this.near, this.far)
            },
            toJSON: function(t) {
                return (t = Y.prototype.toJSON.call(this, t)).object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
            }
        }), Object.assign(Q.prototype, {
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        });
        var ha, ca, ua, da, pa, fa, ma = 0;
        K.prototype = Object.assign(Object.create(e.prototype), {
            constructor: K,
            isGeometry: !0,
            applyMatrix: function(t) {
                for (var e = (new g).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(t);
                for (i = 0, n = this.faces.length; i < n; i++) {
                    (t = this.faces[i]).normal.applyMatrix3(e).normalize();
                    for (var r = 0, s = t.vertexNormals.length; r < s; r++) t.vertexNormals[r].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
            },
            rotateX: (fa = new Et, function(t) {
                return fa.makeRotationX(t), this.applyMatrix(fa), this
            }),
            rotateY: (pa = new Et, function(t) {
                return pa.makeRotationY(t), this.applyMatrix(pa), this
            }),
            rotateZ: (da = new Et, function(t) {
                return da.makeRotationZ(t), this.applyMatrix(da), this
            }),
            translate: (ua = new Et, function(t, e, i) {
                return ua.makeTranslation(t, e, i), this.applyMatrix(ua), this
            }),
            scale: (ca = new Et, function(t, e, i) {
                return ca.makeScale(t, e, i), this.applyMatrix(ca), this
            }),
            lookAt: (ha = new Y, function(t) {
                ha.lookAt(t), ha.updateMatrix(), this.applyMatrix(ha.matrix)
            }),
            fromBufferGeometry: function(t) {
                function e(t, e, i, n) {
                    n = new Q(t, e, i, void 0 !== a ? [c[t].clone(), c[e].clone(), c[i].clone()] : [], void 0 !== o ? [r.colors[t].clone(), r.colors[e].clone(), r.colors[i].clone()] : [], n), r.faces.push(n), void 0 !== l && r.faceVertexUvs[0].push([u[t].clone(), u[e].clone(), u[i].clone()]), void 0 !== h && r.faceVertexUvs[1].push([d[t].clone(), d[e].clone(), d[i].clone()])
                }
                var r = this,
                    i = null !== t.index ? t.index.array : void 0,
                    n = t.attributes,
                    s = n.position.array,
                    a = void 0 !== n.normal ? n.normal.array : void 0,
                    o = void 0 !== n.color ? n.color.array : void 0,
                    l = void 0 !== n.uv ? n.uv.array : void 0,
                    h = void 0 !== n.uv2 ? n.uv2.array : void 0;
                void 0 !== h && (this.faceVertexUvs[1] = []);
                for (var c = [], u = [], d = [], p = n = 0; n < s.length; n += 3, p += 2) r.vertices.push(new St(s[n], s[n + 1], s[n + 2])), void 0 !== a && c.push(new St(a[n], a[n + 1], a[n + 2])), void 0 !== o && r.colors.push(new N(o[n], o[n + 1], o[n + 2])), void 0 !== l && u.push(new X(l[p], l[p + 1])), void 0 !== h && d.push(new X(h[p], h[p + 1]));
                var f = t.groups;
                if (0 < f.length)
                    for (n = 0; n < f.length; n++)
                        for (var p = m = (s = f[n]).start, m = m + s.count; p < m; p += 3) void 0 !== i ? e(i[p], i[p + 1], i[p + 2], s.materialIndex) : e(p, p + 1, p + 2, s.materialIndex);
                else if (void 0 !== i)
                    for (n = 0; n < i.length; n += 3) e(i[n], i[n + 1], i[n + 2]);
                else
                    for (n = 0; n < s.length / 3; n += 3) e(n, n + 1, n + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                    e = 0 === (e = this.boundingSphere.radius) ? 1 : 1 / e,
                    i = new Et;
                return i.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
            },
            computeFaceNormals: function() {
                for (var t = new St, e = new St, i = 0, n = this.faces.length; i < n; i++) {
                    var r = this.faces[i],
                        s = this.vertices[r.a],
                        a = this.vertices[r.b];
                    t.subVectors(this.vertices[r.c], a), e.subVectors(s, a), t.cross(e), t.normalize(), r.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                void 0 === t && (t = !0);
                for (var e = Array(this.vertices.length), i = 0, n = this.vertices.length; i < n; i++) e[i] = new St;
                if (t) {
                    var r = new St,
                        s = new St;
                    for (t = 0, i = this.faces.length; t < i; t++) {
                        n = this.faces[t];
                        var a = this.vertices[n.a],
                            o = this.vertices[n.b],
                            l = this.vertices[n.c];
                        r.subVectors(l, o), s.subVectors(a, o), r.cross(s), e[n.a].add(r), e[n.b].add(r), e[n.c].add(r)
                    }
                } else
                    for (this.computeFaceNormals(), t = 0, i = this.faces.length; t < i; t++) e[(n = this.faces[t]).a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal);
                for (i = 0, n = this.vertices.length; i < n; i++) e[i].normalize();
                for (t = 0, i = this.faces.length; t < i; t++) 3 === (a = (n = this.faces[t]).vertexNormals).length ? (a[0].copy(e[n.a]), a[1].copy(e[n.b]), a[2].copy(e[n.c])) : (a[0] = e[n.a].clone(), a[1] = e[n.b].clone(), a[2] = e[n.c].clone());
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function() {
                this.computeFaceNormals();
                for (var t = 0, e = this.faces.length; t < e; t++) {
                    var i = this.faces[t],
                        n = i.vertexNormals;
                    3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                }
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                var t = 0;
                for (a = this.faces.length; t < a; t++) {
                    var e = this.faces[t];
                    e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []);
                    for (var i = 0, n = e.vertexNormals.length; i < n; i++) e.__originalVertexNormals[i] ? e.__originalVertexNormals[i].copy(e.vertexNormals[i]) : e.__originalVertexNormals[i] = e.vertexNormals[i].clone()
                }
                var r = new K;
                for (r.faces = this.faces, i = 0, n = this.morphTargets.length; i < n; i++) {
                    if (!this.morphNormals[i]) {
                        this.morphNormals[i] = {}, this.morphNormals[i].faceNormals = [], this.morphNormals[i].vertexNormals = [], e = this.morphNormals[i].faceNormals;
                        for (var s = this.morphNormals[i].vertexNormals, t = 0, a = this.faces.length; t < a; t++) {
                            var o = new St,
                                l = {
                                    a: new St,
                                    b: new St,
                                    c: new St
                                };
                            e.push(o), s.push(l)
                        }
                    }
                    for (s = this.morphNormals[i], r.vertices = this.morphTargets[i].vertices, r.computeFaceNormals(), r.computeVertexNormals(), t = 0, a = this.faces.length; t < a; t++) e = this.faces[t], o = s.faceNormals[t], l = s.vertexNormals[t], o.copy(e.normal), l.a.copy(e.vertexNormals[0]), l.b.copy(e.vertexNormals[1]), l.c.copy(e.vertexNormals[2])
                }
                for (t = 0, a = this.faces.length; t < a; t++)(e = this.faces[t]).normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
            },
            computeLineDistances: function() {
                for (var t = 0, e = this.vertices, i = 0, n = e.length; i < n; i++) 0 < i && (t += e[i].distanceTo(e[i - 1])), this.lineDistances[i] = t
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new G), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new V), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, i) {
                if (t && t.isGeometry) {
                    var n, r = this.vertices.length,
                        s = this.vertices,
                        a = t.vertices,
                        o = this.faces,
                        l = t.faces,
                        h = this.faceVertexUvs[0],
                        c = t.faceVertexUvs[0],
                        u = this.colors,
                        d = t.colors;
                    void 0 === i && (i = 0), void 0 !== e && (n = (new g).getNormalMatrix(e)), t = 0;
                    for (var p = a.length; t < p; t++) {
                        var f = a[t].clone();
                        void 0 !== e && f.applyMatrix4(e), s.push(f)
                    }
                    for (t = 0, p = d.length; t < p; t++) u.push(d[t].clone());
                    for (t = 0, p = l.length; t < p; t++) {
                        var m = (a = l[t]).vertexNormals,
                            d = a.vertexColors;
                        for ((u = new Q(a.a + r, a.b + r, a.c + r)).normal.copy(a.normal), void 0 !== n && u.normal.applyMatrix3(n).normalize(), e = 0, s = m.length; e < s; e++) f = m[e].clone(), void 0 !== n && f.applyMatrix3(n).normalize(), u.vertexNormals.push(f);
                        for (u.color.copy(a.color), e = 0, s = d.length; e < s; e++) f = d[e], u.vertexColors.push(f.clone());
                        u.materialIndex = a.materialIndex + i, o.push(u)
                    }
                    for (t = 0, p = c.length; t < p; t++)
                        if (n = [], void 0 !== (i = c[t])) {
                            for (e = 0, s = i.length; e < s; e++) n.push(i[e].clone());
                            h.push(n)
                        }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
            },
            mergeMesh: function(t) {
                t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
            },
            mergeVertices: function() {
                for (var t = {}, e = [], i = [], n = Math.pow(10, 4), r = 0, s = this.vertices.length; r < s; r++) {
                    var a = this.vertices[r];
                    void 0 === t[a = Math.round(a.x * n) + "_" + Math.round(a.y * n) + "_" + Math.round(a.z * n)] ? (t[a] = r, e.push(this.vertices[r]), i[r] = e.length - 1) : i[r] = i[t[a]]
                }
                for (t = [], r = 0, s = this.faces.length; r < s; r++)
                    for ((n = this.faces[r]).a = i[n.a], n.b = i[n.b], n.c = i[n.c], n = [n.a, n.b, n.c], a = 0; a < 3; a++)
                        if (n[a] === n[(a + 1) % 3]) {
                            t.push(r);
                            break
                        }
                for (r = t.length - 1; 0 <= r; r--)
                    for (n = t[r], this.faces.splice(n, 1), i = 0, s = this.faceVertexUvs.length; i < s; i++) this.faceVertexUvs[i].splice(n, 1);
                return r = this.vertices.length - e.length, this.vertices = e, r
            },
            setFromPoints: function(t) {
                this.vertices = [];
                for (var e = 0, i = t.length; e < i; e++) {
                    var n = t[e];
                    this.vertices.push(new St(n.x, n.y, n.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function() {
                for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                t.sort(function(t, e) {
                    return t.materialIndex - e.materialIndex
                });
                var n, r, s = this.faceVertexUvs[0],
                    a = this.faceVertexUvs[1];
                for (s && s.length === e && (n = []), a && a.length === e && (r = []), i = 0; i < e; i++) {
                    var o = t[i]._id;
                    n && n.push(s[o]), r && r.push(a[o])
                }
                n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
            },
            toJSON: function() {
                function t(t, e, i) {
                    return i ? t | 1 << e : t & ~(1 << e)
                }

                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== l[e] || (l[e] = o.length / 3, o.push(t.x, t.y, t.z)), l[e]
                }

                function i(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== c[e] || (c[e] = h.length, h.push(t.getHex())), c[e]
                }

                function n(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== d[e] || (d[e] = u.length / 2, u.push(t.x, t.y)), d[e]
                }
                var r = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                    var s = this.parameters;
                    for (p in s) void 0 !== s[p] && (r[p] = s[p]);
                    return r
                }
                for (s = [], p = 0; p < this.vertices.length; p++) {
                    var a = this.vertices[p];
                    s.push(a.x, a.y, a.z)
                }
                for (var a = [], o = [], l = {}, h = [], c = {}, u = [], d = {}, p = 0; p < this.faces.length; p++) {
                    var f = this.faces[p],
                        m = void 0 !== this.faceVertexUvs[0][p],
                        g = 0 < f.normal.length(),
                        v = 0 < f.vertexNormals.length,
                        _ = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                        y = 0 < f.vertexColors.length,
                        x = t(2, 3, m),
                        x = t(x, 4, g),
                        x = t(x, 5, v),
                        x = t(x, 6, _),
                        x = t(x, 7, y);
                    a.push(x), a.push(f.a, f.b, f.c), a.push(f.materialIndex), m && (m = this.faceVertexUvs[0][p], a.push(n(m[0]), n(m[1]), n(m[2]))), g && a.push(e(f.normal)), v && (g = f.vertexNormals, a.push(e(g[0]), e(g[1]), e(g[2]))), _ && a.push(i(f.color)), y && (f = f.vertexColors, a.push(i(f[0]), i(f[1]), i(f[2])))
                }
                return r.data = {}, r.data.vertices = s, r.data.normals = o, 0 < h.length && (r.data.colors = h), 0 < u.length && (r.data.uvs = [u]), r.data.faces = a, r
            },
            clone: function() {
                return (new K).copy(this)
            },
            copy: function(t) {
                var e;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
                for (var i = t.vertices, n = 0, r = i.length; n < r; n++) this.vertices.push(i[n].clone());
                for (n = 0, r = (i = t.colors).length; n < r; n++) this.colors.push(i[n].clone());
                for (n = 0, r = (i = t.faces).length; n < r; n++) this.faces.push(i[n].clone());
                for (n = 0, r = t.faceVertexUvs.length; n < r; n++) {
                    var s = t.faceVertexUvs[n];
                    for (void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []), i = 0, e = s.length; i < e; i++) {
                        for (var a = s[i], o = [], l = 0, h = a.length; l < h; l++) o.push(a[l].clone());
                        this.faceVertexUvs[n].push(o)
                    }
                }
                for (n = 0, r = (l = t.morphTargets).length; n < r; n++) {
                    if ((h = {}).name = l[n].name, void 0 !== l[n].vertices)
                        for (h.vertices = [], i = 0, e = l[n].vertices.length; i < e; i++) h.vertices.push(l[n].vertices[i].clone());
                    if (void 0 !== l[n].normals)
                        for (h.normals = [], i = 0, e = l[n].normals.length; i < e; i++) h.normals.push(l[n].normals[i].clone());
                    this.morphTargets.push(h)
                }
                for (n = 0, r = (l = t.morphNormals).length; n < r; n++) {
                    if (h = {}, void 0 !== l[n].vertexNormals)
                        for (h.vertexNormals = [], i = 0, e = l[n].vertexNormals.length; i < e; i++) s = l[n].vertexNormals[i], (a = {}).a = s.a.clone(), a.b = s.b.clone(), a.c = s.c.clone(), h.vertexNormals.push(a);
                    if (void 0 !== l[n].faceNormals)
                        for (h.faceNormals = [], i = 0, e = l[n].faceNormals.length; i < e; i++) h.faceNormals.push(l[n].faceNormals[i].clone());
                    this.morphNormals.push(h)
                }
                for (n = 0, r = (i = t.skinWeights).length; n < r; n++) this.skinWeights.push(i[n].clone());
                for (n = 0, r = (i = t.skinIndices).length; n < r; n++) this.skinIndices.push(i[n].clone());
                for (n = 0, r = (i = t.lineDistances).length; n < r; n++) this.lineDistances.push(i[n]);
                return null !== (n = t.boundingBox) && (this.boundingBox = n.clone()), null !== (n = t.boundingSphere) && (this.boundingSphere = n.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty($.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign($.prototype, {
            isBufferAttribute: !0,
            setArray: function(t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
            },
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.itemSize, i *= e.itemSize;
                for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t), this
            },
            copyColorsArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), s = new N), e[i++] = s.r, e[i++] = s.g, e[i++] = s.b
                }
                return this
            },
            copyIndicesArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    e[i++] = s.a, e[i++] = s.b, e[i++] = s.c
                }
                return this
            },
            copyVector2sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), s = new X), e[i++] = s.x, e[i++] = s.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new St), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), s = new At), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z, e[i++] = s.w
                }
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function(t, e, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            },
            clone: function() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
        }), (tt.prototype = Object.create($.prototype)).constructor = tt, (et.prototype = Object.create($.prototype)).constructor = et, (it.prototype = Object.create($.prototype)).constructor = it, (nt.prototype = Object.create($.prototype)).constructor = nt, (rt.prototype = Object.create($.prototype)).constructor = rt, (st.prototype = Object.create($.prototype)).constructor = st, (at.prototype = Object.create($.prototype)).constructor = at, (ot.prototype = Object.create($.prototype)).constructor = ot, (lt.prototype = Object.create($.prototype)).constructor = lt, Object.assign(ht.prototype, {
            computeGroups: function(t) {
                var e = [],
                    i = void 0;
                t = t.faces;
                for (var n = 0; n < t.length; n++) {
                    var r, s = t[n];
                    s.materialIndex !== i && (i = s.materialIndex, void 0 !== r && (r.count = 3 * n - r.start, e.push(r)), r = {
                        start: 3 * n,
                        materialIndex: i
                    })
                }
                void 0 !== r && (r.count = 3 * n - r.start, e.push(r)), this.groups = e
            },
            fromGeometry: function(t) {
                var e = t.faces,
                    i = t.vertices,
                    n = t.faceVertexUvs,
                    r = n[0] && 0 < n[0].length,
                    s = n[1] && 0 < n[1].length,
                    a = t.morphTargets,
                    o = a.length;
                if (0 < o) {
                    for (var l = [], h = 0; h < o; h++) l[h] = [];
                    this.morphTargets.position = l
                }
                var c = t.morphNormals,
                    u = c.length;
                if (0 < u) {
                    var d = [];
                    for (h = 0; h < u; h++) d[h] = [];
                    this.morphTargets.normal = d
                }
                for (var p = t.skinIndices, f = t.skinWeights, m = p.length === i.length, g = f.length === i.length, h = 0; h < e.length; h++) {
                    var v = e[h];
                    this.vertices.push(i[v.a], i[v.b], i[v.c]);
                    var _ = v.vertexNormals;
                    for (3 === _.length ? this.normals.push(_[0], _[1], _[2]) : (_ = v.normal, this.normals.push(_, _, _)), 3 === (_ = v.vertexColors).length ? this.colors.push(_[0], _[1], _[2]) : (_ = v.color, this.colors.push(_, _, _)), !0 === r && (void 0 !== (_ = n[0][h]) ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new X, new X, new X))), !0 === s && (void 0 !== (_ = n[1][h]) ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new X, new X, new X))), _ = 0; _ < o; _++) {
                        var y = a[_].vertices;
                        l[_].push(y[v.a], y[v.b], y[v.c])
                    }
                    for (_ = 0; _ < u; _++) y = c[_].vertexNormals[h], d[_].push(y.a, y.b, y.c);
                    m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            }
        });
        var ga, va, _a, ya, xa, ba, wa, Ta, Ma, Ea, Sa, Aa, Pa, Ca, Ra, La, Oa, Da, ka, Ia, Na, za, Ba, Ua, Fa, Ha, Ga, Va, ja, Wa, Xa, qa, Ya, Za, Ja, Qa, Ka, $a, to, eo, io, no, ro, so, ao, oo, lo, ho, co = 1;

        function uo(t, e, i, n, r, s, a) {
            return xt.barycoordFromPoint(t, e, i, n, oo), r.multiplyScalar(oo.x), s.multiplyScalar(oo.y), a.multiplyScalar(oo.z), r.add(s).add(a), r.clone()
        }

        function po(t, e, i, n, r, s, a, o) {
            return null === (1 === e.side ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, 2 !== e.side, o)) ? null : (ho.copy(o), ho.applyMatrix4(t.matrixWorld), (e = i.ray.origin.distanceTo(ho)) < i.near || e > i.far ? null : {
                distance: e,
                point: ho.clone(),
                object: t
            })
        }

        function fo(t, e, i, n, r, s, a, o) {
            return Ka.fromBufferAttribute(n, s), $a.fromBufferAttribute(n, a), to.fromBufferAttribute(n, o), (t = po(t, t.material, e, i, Ka, $a, to, lo)) && (r && (ro.fromBufferAttribute(r, s), so.fromBufferAttribute(r, a), ao.fromBufferAttribute(r, o), t.uv = uo(lo, Ka, $a, to, ro, so, ao)), t.face = new Q(s, a, o, xt.normal(Ka, $a, to)), t.faceIndex = s), t
        }
        ut.prototype = Object.assign(Object.create(e.prototype), {
            constructor: ut,
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                Array.isArray(t) ? this.index = new(65535 < ct(t) ? at : rt)(t, 1) : this.index = t
            },
            addAttribute: function(t, e, i) {
                if (e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute) {
                    if ("index" !== t) return this.attributes[t] = e, this;
                    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e)
                } else console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new $(e, i))
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            removeAttribute: function(t) {
                return delete this.attributes[t], this
            },
            addGroup: function(t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== i ? i : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix: function(t) {
                var e = this.attributes.position;
                return void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0), void 0 !== (e = this.attributes.normal) && ((new g).getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: (Ma = new Et, function(t) {
                return Ma.makeRotationX(t), this.applyMatrix(Ma), this
            }),
            rotateY: (Ta = new Et, function(t) {
                return Ta.makeRotationY(t), this.applyMatrix(Ta), this
            }),
            rotateZ: (wa = new Et, function(t) {
                return wa.makeRotationZ(t), this.applyMatrix(wa), this
            }),
            translate: (ba = new Et, function(t, e, i) {
                return ba.makeTranslation(t, e, i), this.applyMatrix(ba), this
            }),
            scale: (xa = new Et, function(t, e, i) {
                return xa.makeScale(t, e, i), this.applyMatrix(xa), this
            }),
            lookAt: (ya = new Y, function(t) {
                ya.lookAt(t), ya.updateMatrix(), this.applyMatrix(ya.matrix)
            }),
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            },
            setFromObject: function(t) {
                var e, i = t.geometry;
                return t.isPoints || t.isLine ? (t = new ot(3 * i.vertices.length, 3), e = new ot(3 * i.colors.length, 3), this.addAttribute("position", t.copyVector3sArray(i.vertices)), this.addAttribute("color", e.copyColorsArray(i.colors)), i.lineDistances && i.lineDistances.length === i.vertices.length && (t = new ot(i.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(i.lineDistances))), null !== i.boundingSphere && (this.boundingSphere = i.boundingSphere.clone()), null !== i.boundingBox && (this.boundingBox = i.boundingBox.clone())) : t.isMesh && i && i.isGeometry && this.fromGeometry(i), this
            },
            setFromPoints: function(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.addAttribute("position", new ot(e, 3)), this
            },
            updateFromObject: function(t) {
                var e = t.geometry;
                if (t.isMesh) {
                    var i = e.__directGeometry;
                    if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e);
                    i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i
                }
                return !0 === e.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new ht).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e, i = new Float32Array(3 * t.vertices.length);
                for (e in this.addAttribute("position", new $(i, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (i = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new $(i, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (i = new Float32Array(3 * t.colors.length), this.addAttribute("color", new $(i, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (i = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new $(i, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (i = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new $(i, 2).copyVector2sArray(t.uvs2))), 0 < t.indices.length && (i = new(65535 < ct(t.indices) ? Uint32Array : Uint16Array)(3 * t.indices.length), this.setIndex(new $(i, 1).copyIndicesArray(t.indices))), this.groups = t.groups, t.morphTargets) {
                    for (var i = [], n = t.morphTargets[e], r = 0, s = n.length; r < s; r++) {
                        var a = n[r],
                            o = new ot(3 * a.length, 3);
                        i.push(o.copyVector3sArray(a))
                    }
                    this.morphAttributes[e] = i
                }
                return 0 < t.skinIndices.length && (e = new ot(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", e.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (e = new ot(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", e.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new G);
                var t = this.attributes.position;
                void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: (va = new G, _a = new St, function() {
                null === this.boundingSphere && (this.boundingSphere = new V);
                var t = this.attributes.position;
                if (t) {
                    var e = this.boundingSphere.center;
                    va.setFromBufferAttribute(t), va.getCenter(e);
                    for (var i = 0, n = 0, r = t.count; n < r; n++) _a.x = t.getX(n), _a.y = t.getY(n), _a.z = t.getZ(n), i = Math.max(i, e.distanceToSquared(_a));
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }),
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index,
                    e = this.attributes,
                    i = this.groups;
                if (e.position) {
                    var n = e.position.array;
                    if (void 0 === e.normal) this.addAttribute("normal", new $(new Float32Array(n.length), 3));
                    else
                        for (var r = 0, s = (a = e.normal.array).length; r < s; r++) a[r] = 0;
                    var a = e.normal.array,
                        o = new St,
                        l = new St,
                        h = new St,
                        c = new St,
                        u = new St;
                    if (t) {
                        t = t.array, 0 === i.length && this.addGroup(0, t.length);
                        for (var d = 0, p = i.length; d < p; ++d) {
                            s = (r = i[d]).start;
                            var f = r.count,
                                r = s;
                            for (s += f; r < s; r += 3) {
                                f = 3 * t[r + 0];
                                var m = 3 * t[r + 1],
                                    g = 3 * t[r + 2];
                                o.fromArray(n, f), l.fromArray(n, m), h.fromArray(n, g), c.subVectors(h, l), u.subVectors(o, l), c.cross(u), a[f] += c.x, a[1 + f] += c.y, a[2 + f] += c.z, a[m] += c.x, a[1 + m] += c.y, a[2 + m] += c.z, a[g] += c.x, a[1 + g] += c.y, a[2 + g] += c.z
                            }
                        }
                    } else
                        for (r = 0, s = n.length; r < s; r += 9) o.fromArray(n, r), l.fromArray(n, r + 3), h.fromArray(n, r + 6), c.subVectors(h, l), u.subVectors(o, l), c.cross(u), a[r] = c.x, a[r + 1] = c.y, a[r + 2] = c.z, a[r + 3] = c.x, a[r + 4] = c.y, a[r + 5] = c.z, a[r + 6] = c.x, a[r + 7] = c.y, a[r + 8] = c.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (t && t.isBufferGeometry) {
                    void 0 === e && (e = 0);
                    var i, n = this.attributes;
                    for (i in n)
                        if (void 0 !== t.attributes[i])
                            for (var r = n[i].array, s = t.attributes[i], a = s.array, o = 0, s = s.itemSize * e; o < a.length; o++, s++) r[s] = a[o];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
            },
            normalizeNormals: (ga = new St, function() {
                for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++) ga.x = t.getX(e), ga.y = t.getY(e), ga.z = t.getZ(e), ga.normalize(), t.setXYZ(e, ga.x, ga.y, ga.z)
            }),
            toNonIndexed: function() {
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var t, e = new ut,
                    i = this.index.array,
                    n = this.attributes;
                for (t in n) {
                    for (var r, s = (a = n[t]).array, a = a.itemSize, o = new s.constructor(i.length * a), l = 0, h = 0, c = i.length; h < c; h++) {
                        r = i[h] * a;
                        for (var u = 0; u < a; u++) o[l++] = s[r++]
                    }
                    e.addAttribute(t, new $(o, a))
                }
                return e
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e, i = this.parameters;
                    for (e in i) void 0 !== i[e] && (t[e] = i[e]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var n = this.index;
                for (e in null !== n && (i = Array.prototype.slice.call(n.array), t.data.index = {
                        type: n.array.constructor.name,
                        array: i
                    }), n = this.attributes) {
                    var r = n[e],
                        i = Array.prototype.slice.call(r.array);
                    t.data.attributes[e] = {
                        itemSize: r.itemSize,
                        type: r.array.constructor.name,
                        array: i,
                        normalized: r.normalized
                    }
                }
                return 0 < (e = this.groups).length && (t.data.groups = JSON.parse(JSON.stringify(e))), null !== (e = this.boundingSphere) && (t.data.boundingSphere = {
                    center: e.center.toArray(),
                    radius: e.radius
                }), t
            },
            clone: function() {
                return (new ut).copy(this)
            },
            copy: function(t) {
                for (a in this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name, null !== (r = t.index) && this.setIndex(r.clone()), r = t.attributes) this.addAttribute(a, r[a].clone());
                var e = t.morphAttributes;
                for (a in e) {
                    for (var i = [], n = e[a], r = 0, s = n.length; r < s; r++) i.push(n[r].clone());
                    this.morphAttributes[a] = i
                }
                var a = t.groups;
                for (r = 0, s = a.length; r < s; r++) e = a[r], this.addGroup(e.start, e.count, e.materialIndex);
                return null !== (a = t.boundingBox) && (this.boundingBox = a.clone()), null !== (a = t.boundingSphere) && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), (dt.prototype = Object.create(K.prototype)).constructor = dt, (pt.prototype = Object.create(ut.prototype)).constructor = pt, (ft.prototype = Object.create(K.prototype)).constructor = ft, (mt.prototype = Object.create(ut.prototype)).constructor = mt, ((gt.prototype = Object.create(B.prototype)).constructor = gt).prototype.isMeshBasicMaterial = !0, gt.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        }, ((vt.prototype = Object.create(B.prototype)).constructor = vt).prototype.isShaderMaterial = !0, vt.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = vs.clone(t.uniforms), this.defines = t.defines, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, vt.prototype.toJSON = function(t) {
            return (t = B.prototype.toJSON.call(this, t)).uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
        }, Object.assign(_t.prototype, {
            set: function(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            },
            at: function(t, e) {
                return (e || new St).copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            },
            recast: (Ia = new St, function(t) {
                return this.origin.copy(this.at(t, Ia)), this
            }),
            closestPointToPoint: function(t, e) {
                return (e = e || new St).subVectors(t, this.origin), (t = e.dot(this.direction)) < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            distanceToPoint: function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: (ka = new St, function(t) {
                var e = ka.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (ka.copy(this.direction).multiplyScalar(e).add(this.origin), ka.distanceToSquared(t))
            }),
            distanceSqToSegment: (La = new St, Oa = new St, Da = new St, function(t, e, i, n) {
                La.copy(t).add(e).multiplyScalar(.5), Oa.copy(e).sub(t).normalize(), Da.copy(this.origin).sub(La);
                var r, s = .5 * t.distanceTo(e),
                    a = -this.direction.dot(Oa),
                    o = Da.dot(this.direction),
                    l = -Da.dot(Oa),
                    h = Da.lengthSq(),
                    c = Math.abs(1 - a * a);
                return a = 0 < c ? (e = a * o - l, r = s * c, 0 <= (t = a * l - o) ? -r <= e ? e <= r ? (t *= s = 1 / c) * (t + a * (e *= s) + 2 * o) + e * (a * t + e + 2 * l) + h : (e = s, -(t = Math.max(0, -(a * e + o))) * t + e * (e + 2 * l) + h) : (e = -s, -(t = Math.max(0, -(a * e + o))) * t + e * (e + 2 * l) + h) : e <= -r ? -(t = Math.max(0, -(-a * s + o))) * t + (e = 0 < t ? -s : Math.min(Math.max(-s, -l), s)) * (e + 2 * l) + h : e <= r ? (t = 0, (e = Math.min(Math.max(-s, -l), s)) * (e + 2 * l) + h) : -(t = Math.max(0, -(a * s + o))) * t + (e = 0 < t ? s : Math.min(Math.max(-s, -l), s)) * (e + 2 * l) + h) : (e = 0 < a ? -s : s, -(t = Math.max(0, -(a * e + o))) * t + e * (e + 2 * l) + h), i && i.copy(this.direction).multiplyScalar(t).add(this.origin), n && n.copy(Oa).multiplyScalar(e).add(La), a
            }),
            intersectSphere: (Ra = new St, function(t, e) {
                Ra.subVectors(t.center, this.origin);
                var i = Ra.dot(this.direction),
                    n = Ra.dot(Ra) - i * i;
                return (t = t.radius * t.radius) < n ? null : (n = i - (t = Math.sqrt(t - n)), i += t, n < 0 && i < 0 ? null : n < 0 ? this.at(i, e) : this.at(n, e))
            }),
            intersectsSphere: function(t) {
                return this.distanceToPoint(t.center) <= t.radius
            },
            distanceToPlane: function(t) {
                var e = t.normal.dot(this.direction);
                return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : 0 <= (t = -(this.origin.dot(t.normal) + t.constant) / e) ? t : null
            },
            intersectPlane: function(t, e) {
                return null === (t = this.distanceToPlane(t)) ? null : this.at(t, e)
            },
            intersectsPlane: function(t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            },
            intersectBox: function(t, e) {
                var i, n, r = 1 / this.direction.x,
                    s = 1 / this.direction.y,
                    a = 1 / this.direction.z,
                    o = this.origin;
                return 0 <= r ? (i = (t.min.x - o.x) * r, r *= t.max.x - o.x) : (i = (t.max.x - o.x) * r, r *= t.min.x - o.x), 0 <= s ? (n = (t.min.y - o.y) * s, s *= t.max.y - o.y) : (n = (t.max.y - o.y) * s, s *= t.min.y - o.y), s < i || r < n ? null : ((i < n || i != i) && (i = n), (s < r || r != r) && (r = s), (t = 0 <= a ? (n = (t.min.z - o.z) * a, (t.max.z - o.z) * a) : (n = (t.max.z - o.z) * a, (t.min.z - o.z) * a)) < i || r < n ? null : ((i < n || i != i) && (i = n), (t < r || r != r) && (r = t), r < 0 ? null : this.at(0 <= i ? i : r, e)))
            },
            intersectsBox: (Ca = new St, function(t) {
                return null !== this.intersectBox(t, Ca)
            }),
            intersectTriangle: (Ea = new St, Sa = new St, Aa = new St, Pa = new St, function(t, e, i, n, r) {
                if (Sa.subVectors(e, t), Aa.subVectors(i, t), Pa.crossVectors(Sa, Aa), 0 < (e = this.direction.dot(Pa))) {
                    if (n) return null;
                    n = 1
                } else {
                    if (!(e < 0)) return null;
                    n = -1, e = -e
                }
                return Ea.subVectors(this.origin, t), (t = n * this.direction.dot(Aa.crossVectors(Ea, Aa))) < 0 || (i = n * this.direction.dot(Sa.cross(Ea))) < 0 || e < t + i || (t = -n * Ea.dot(Pa)) < 0 ? null : this.at(t / e, r)
            }),
            applyMatrix4: function(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            },
            equals: function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        }), Object.assign(yt.prototype, {
            set: function(t, e) {
                return this.start.copy(t), this.end.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            },
            getCenter: function(t) {
                return (t || new St).addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function(t) {
                return (t || new St).subVectors(this.end, this.start)
            },
            distanceSq: function() {
                return this.start.distanceToSquared(this.end)
            },
            distance: function() {
                return this.start.distanceTo(this.end)
            },
            at: function(t, e) {
                return e = e || new St, this.delta(e).multiplyScalar(t).add(this.start)
            },
            closestPointToPointParameter: (Na = new St, za = new St, function(t, e) {
                return Na.subVectors(t, this.start), za.subVectors(this.end, this.start), t = za.dot(za), t = za.dot(Na) / t, e && (t = es.clamp(t, 0, 1)), t
            }),
            closestPointToPoint: function(t, e, i) {
                return t = this.closestPointToPointParameter(t, e), i = i || new St, this.delta(i).multiplyScalar(t).add(this.start)
            },
            applyMatrix4: function(t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            },
            equals: function(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }), Object.assign(xt, {
            normal: (Ga = new St, function(t, e, i, n) {
                return (n = n || new St).subVectors(i, e), Ga.subVectors(t, e), n.cross(Ga), 0 < (t = n.lengthSq()) ? n.multiplyScalar(1 / Math.sqrt(t)) : n.set(0, 0, 0)
            }),
            barycoordFromPoint: (Ua = new St, Fa = new St, Ha = new St, function(t, e, i, n, r) {
                Ua.subVectors(n, e), Fa.subVectors(i, e), Ha.subVectors(t, e), t = Ua.dot(Ua), e = Ua.dot(Fa), i = Ua.dot(Ha);
                var s = Fa.dot(Fa);
                n = Fa.dot(Ha);
                var a = t * s - e * e;
                return r = r || new St, 0 == a ? r.set(-2, -1, -1) : (s = (s * i - e * n) * (a = 1 / a), t = (t * n - e * i) * a, r.set(1 - s - t, t, s))
            }),
            containsPoint: (Ba = new St, function(t, e, i, n) {
                return 0 <= (t = xt.barycoordFromPoint(t, e, i, n, Ba)).x && 0 <= t.y && t.x + t.y <= 1
            })
        }), Object.assign(xt.prototype, {
            set: function(t, e, i) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
            },
            setFromPointsAndIndices: function(t, e, i, n) {
                return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            },
            area: (qa = new St, Ya = new St, function() {
                return qa.subVectors(this.c, this.b), Ya.subVectors(this.a, this.b), .5 * qa.cross(Ya).length()
            }),
            midpoint: function(t) {
                return (t || new St).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            normal: function(t) {
                return xt.normal(this.a, this.b, this.c, t)
            },
            plane: function(t) {
                return (t || new j).setFromCoplanarPoints(this.a, this.b, this.c)
            },
            barycoordFromPoint: function(t, e) {
                return xt.barycoordFromPoint(t, this.a, this.b, this.c, e)
            },
            containsPoint: function(t) {
                return xt.containsPoint(t, this.a, this.b, this.c)
            },
            closestPointToPoint: (Va = new j, ja = [new yt, new yt, new yt], Wa = new St, Xa = new St, function(t, e) {
                e = e || new St;
                var i = 1 / 0;
                if (Va.setFromCoplanarPoints(this.a, this.b, this.c), Va.projectPoint(t, Wa), !0 === this.containsPoint(Wa)) e.copy(Wa);
                else
                    for (ja[0].set(this.a, this.b), ja[1].set(this.b, this.c), ja[2].set(this.c, this.a), t = 0; t < ja.length; t++) {
                        ja[t].closestPointToPoint(Wa, !0, Xa);
                        var n = Wa.distanceToSquared(Xa);
                        n < i && (i = n, e.copy(Xa))
                    }
                return e
            }),
            equals: function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }), bt.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: bt,
            isMesh: !0,
            setDrawMode: function(t) {
                this.drawMode = t
            },
            copy: function(t) {
                return Y.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
            },
            updateMorphTargets: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    t = t.morphAttributes;
                    var e = Object.keys(t);
                    if (0 < e.length) {
                        var i = t[e[0]];
                        if (void 0 !== i)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
                                var n = i[t].name || String(t);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                            }
                    }
                } else if (void 0 !== (i = t.morphTargets) && 0 < i.length)
                    for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) n = i[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
            },
            raycast: (Za = new Et, Ja = new _t, Qa = new V, Ka = new St, $a = new St, to = new St, eo = new St, io = new St, no = new St, ro = new X, so = new X, ao = new X, oo = new St, lo = new St, ho = new St, function(t, e) {
                var i = this.geometry,
                    n = this.material,
                    r = this.matrixWorld;
                if (void 0 !== n && (null === i.boundingSphere && i.computeBoundingSphere(), Qa.copy(i.boundingSphere), Qa.applyMatrix4(r), !1 !== t.ray.intersectsSphere(Qa) && (Za.getInverse(r), Ja.copy(t.ray).applyMatrix4(Za), null === i.boundingBox || !1 !== Ja.intersectsBox(i.boundingBox))))
                    if (i.isBufferGeometry) {
                        var n = i.index,
                            s = i.attributes.position,
                            r = i.attributes.uv;
                        if (null !== n)
                            for (var a = 0, o = n.count; a < o; a += 3) {
                                i = n.getX(a);
                                var l = n.getX(a + 1),
                                    h = n.getX(a + 2);
                                (d = fo(this, t, Ja, s, r, i, l, h)) && (d.faceIndex = Math.floor(a / 3), e.push(d))
                            } else if (void 0 !== s)
                                for (a = 0, o = s.count; a < o; a += 3)(d = fo(this, t, Ja, s, r, i = a, l = a + 1, h = a + 2)) && (d.index = i, e.push(d))
                    } else if (i.isGeometry) {
                    r = Array.isArray(n), a = i.vertices;
                    o = i.faces, 0 < (l = i.faceVertexUvs[0]).length && (s = l);
                    for (var c = 0, u = o.length; c < u; c++) {
                        var d, p = o[c];
                        if (void 0 !== (d = r ? n[p.materialIndex] : n)) {
                            l = a[p.a], h = a[p.b];
                            var f = a[p.c];
                            if (!0 === d.morphTargets) {
                                var m = i.morphTargets,
                                    g = this.morphTargetInfluences;
                                Ka.set(0, 0, 0), $a.set(0, 0, 0), to.set(0, 0, 0);
                                for (var v = 0, _ = m.length; v < _; v++) {
                                    var y, x = g[v];
                                    0 !== x && (y = m[v].vertices, Ka.addScaledVector(eo.subVectors(y[p.a], l), x), $a.addScaledVector(io.subVectors(y[p.b], h), x), to.addScaledVector(no.subVectors(y[p.c], f), x))
                                }
                                Ka.add(l), $a.add(h), to.add(f), l = Ka, h = $a, f = to
                            }(d = po(this, d, t, Ja, l, h, f, lo)) && (s && s[c] && (m = s[c], ro.copy(m[0]), so.copy(m[1]), ao.copy(m[2]), d.uv = uo(lo, l, h, f, ro, so, ao)), d.face = p, d.faceIndex = c, e.push(d))
                        }
                    }
                }
            }),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var mo, go, vo, _o, yo, xo, bo, wo, To, Mo, Eo, So, Ao, Po, Co = 0;
        re.prototype = Object.assign(Object.create(Z.prototype), {
            constructor: re,
            isPerspectiveCamera: !0,
            copy: function(t, e) {
                return Z.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function(t) {
                t = .5 * this.getFilmHeight() / t, this.fov = 2 * es.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var t = Math.tan(.5 * es.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function() {
                return 2 * es.RAD2DEG * Math.atan(Math.tan(.5 * es.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(t, e, i, n, r, s) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t, e, i = this.near,
                    n = i * Math.tan(.5 * es.DEG2RAD * this.fov) / this.zoom,
                    r = 2 * n,
                    s = this.aspect * r,
                    a = -.5 * s,
                    o = this.view;
                null !== this.view && this.view.enabled && (t = o.fullWidth, e = o.fullHeight, a += o.offsetX * s / t, n -= o.offsetY * r / e, s = o.width / t * s, r = o.height / e * r), 0 !== (o = this.filmOffset) && (a += i * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + s, n, n - r, i, this.far)
            },
            toJSON: function(t) {
                return (t = Y.prototype.toJSON.call(this, t)).object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        }), se.prototype = Object.assign(Object.create(re.prototype), {
            constructor: se,
            isArrayCamera: !0
        }), ue.prototype.isFogExp2 = !0, ue.prototype.clone = function() {
            return new ue(this.color.getHex(), this.density)
        }, ue.prototype.toJSON = function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }, de.prototype.isFog = !0, de.prototype.clone = function() {
            return new de(this.color.getHex(), this.near, this.far)
        }, de.prototype.toJSON = function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }, pe.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: pe,
            copy: function(t, e) {
                return Y.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            },
            toJSON: function(t) {
                var e = Y.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }
        }), fe.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: fe,
            isLensFlare: !0,
            copy: function(t) {
                Y.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback;
                for (var e = 0, i = t.lensFlares.length; e < i; e++) this.lensFlares.push(t.lensFlares[e]);
                return this
            },
            add: function(t, e, i, n, r, s) {
                void 0 === e && (e = -1), void 0 === i && (i = 0), void 0 === s && (s = 1), void 0 === r && (r = new N(16777215)), void 0 === n && (n = 1), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
                    texture: t,
                    size: e,
                    distance: i,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 0,
                    opacity: s,
                    color: r,
                    blending: n
                })
            },
            updateLensFlares: function() {
                for (var t = this.lensFlares.length, e = 2 * -this.positionScreen.x, i = 2 * -this.positionScreen.y, n = 0; n < t; n++) {
                    var r = this.lensFlares[n];
                    r.x = this.positionScreen.x + e * r.distance, r.y = this.positionScreen.y + i * r.distance, r.wantedRotation = r.x * Math.PI * .25, r.rotation += .25 * (r.wantedRotation - r.rotation)
                }
            }
        }), ((me.prototype = Object.create(B.prototype)).constructor = me).prototype.isSpriteMaterial = !0, me.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
        }, ge.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: ge,
            isSprite: !0,
            raycast: (mo = new St, go = new St, vo = new St, function(t, e) {
                go.setFromMatrixPosition(this.matrixWorld), t.ray.closestPointToPoint(go, mo), vo.setFromMatrixScale(this.matrixWorld);
                var i = vo.x * vo.y / 4;
                go.distanceToSquared(mo) > i || ((i = t.ray.origin.distanceTo(mo)) < t.near || i > t.far || e.push({
                    distance: i,
                    point: mo.clone(),
                    face: null,
                    object: this
                }))
            }),
            clone: function() {
                return new this.constructor(this.material).copy(this)
            }
        }), ve.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: ve,
            copy: function(t) {
                Y.prototype.copy.call(this, t, !1);
                for (var e = 0, i = (t = t.levels).length; e < i; e++) {
                    var n = t[e];
                    this.addLevel(n.object.clone(), n.distance)
                }
                return this
            },
            addLevel: function(t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                i.splice(n, 0, {
                    distance: e,
                    object: t
                }), this.add(t)
            },
            getObjectForDistance: function(t) {
                for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                return e[i - 1].object
            },
            raycast: (xo = new St, function(t, e) {
                xo.setFromMatrixPosition(this.matrixWorld);
                var i = t.ray.origin.distanceTo(xo);
                this.getObjectForDistance(i).raycast(t, e)
            }),
            update: (_o = new St, yo = new St, function(t) {
                var e = this.levels;
                if (1 < e.length) {
                    _o.setFromMatrixPosition(t.matrixWorld), yo.setFromMatrixPosition(this.matrixWorld), t = _o.distanceTo(yo), e[0].object.visible = !0;
                    for (var i = 1, n = e.length; i < n && t >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                    for (; i < n; i++) e[i].object.visible = !1
                }
            }),
            toJSON: function(t) {
                (t = Y.prototype.toJSON.call(this, t)).object.levels = [];
                for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
                    var r = e[i];
                    t.object.levels.push({
                        object: r.object.uuid,
                        distance: r.distance
                    })
                }
                return t
            }
        }), Object.assign(_e.prototype, {
            calculateInverses: function() {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = new Et;
                    this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                }
            },
            pose: function() {
                for (var t, e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            },
            update: (bo = new Et, wo = new Et, function() {
                for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, s = t.length; r < s; r++) bo.multiplyMatrices(t[r] ? t[r].matrixWorld : wo, e[r]), bo.toArray(i, 16 * r);
                void 0 !== n && (n.needsUpdate = !0)
            }),
            clone: function() {
                return new _e(this.bones, this.boneInverses)
            },
            getBoneByName: function(t) {
                for (var e = 0, i = this.bones.length; e < i; e++) {
                    var n = this.bones[e];
                    if (n.name === t) return n
                }
            }
        }), ye.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: ye,
            isBone: !0
        }), xe.prototype = Object.assign(Object.create(bt.prototype), {
            constructor: xe,
            isSkinnedMesh: !0,
            initBones: function() {
                var t = [];
                if (this.geometry && void 0 !== this.geometry.bones) {
                    for (var e = 0, i = this.geometry.bones.length; e < i; e++) {
                        var n = this.geometry.bones[e],
                            r = new ye;
                        t.push(r), r.name = n.name, r.position.fromArray(n.pos), r.quaternion.fromArray(n.rotq), void 0 !== n.scl && r.scale.fromArray(n.scl)
                    }
                    for (e = 0, i = this.geometry.bones.length; e < i; e++)(-1 !== (n = this.geometry.bones[e]).parent && null !== n.parent && void 0 !== t[n.parent] ? t[n.parent] : this).add(t[e])
                }
                return this.updateMatrixWorld(!0), t
            },
            bind: function(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                if (this.geometry && this.geometry.isGeometry)
                    for (n = 0; n < this.geometry.skinWeights.length; n++) {
                        var t = 1 / (e = this.geometry.skinWeights[n]).manhattanLength();
                        1 / 0 !== t ? e.multiplyScalar(t) : e.set(1, 0, 0, 0)
                    } else if (this.geometry && this.geometry.isBufferGeometry)
                        for (var e = new At, i = this.geometry.attributes.skinWeight, n = 0; n < i.count; n++) e.x = i.getX(n), e.y = i.getY(n), e.z = i.getZ(n), e.w = i.getW(n), 1 / 0 !== (t = 1 / e.manhattanLength()) ? e.multiplyScalar(t) : e.set(1, 0, 0, 0), i.setXYZW(n, e.x, e.y, e.z, e.w)
            },
            updateMatrixWorld: function(t) {
                bt.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), ((be.prototype = Object.create(B.prototype)).constructor = be).prototype.isLineBasicMaterial = !0, be.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
        }, we.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: we,
            isLine: !0,
            raycast: (To = new Et, Mo = new _t, Eo = new V, function(t, e) {
                var i = (i = t.linePrecision) * i,
                    n = this.geometry,
                    r = this.matrixWorld;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Eo.copy(n.boundingSphere), Eo.applyMatrix4(r), !1 !== t.ray.intersectsSphere(Eo)) {
                    To.getInverse(r), Mo.copy(t.ray).applyMatrix4(To);
                    var s = new St,
                        a = new St,
                        r = new St,
                        o = new St,
                        l = this && this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        var h = n.index,
                            c = n.attributes.position.array;
                        if (null !== h)
                            for (var u = h.array, n = 0, d = u.length - 1; n < d; n += l) h = u[n + 1], s.fromArray(c, 3 * u[n]), a.fromArray(c, 3 * h), i < (h = Mo.distanceSqToSegment(s, a, o, r)) || (o.applyMatrix4(this.matrixWorld), (h = t.ray.origin.distanceTo(o)) < t.near || h > t.far || e.push({
                                distance: h,
                                point: r.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            }));
                        else
                            for (n = 0, d = c.length / 3 - 1; n < d; n += l) s.fromArray(c, 3 * n), a.fromArray(c, 3 * n + 3), i < (h = Mo.distanceSqToSegment(s, a, o, r)) || (o.applyMatrix4(this.matrixWorld), (h = t.ray.origin.distanceTo(o)) < t.near || h > t.far || e.push({
                                distance: h,
                                point: r.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    } else if (n.isGeometry)
                        for (a = (s = n.vertices).length, n = 0; n < a - 1; n += l) i < (h = Mo.distanceSqToSegment(s[n], s[n + 1], o, r)) || (o.applyMatrix4(this.matrixWorld), (h = t.ray.origin.distanceTo(o)) < t.near || h > t.far || e.push({
                            distance: h,
                            point: r.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                }
            }),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Te.prototype = Object.assign(Object.create(we.prototype), {
            constructor: Te,
            isLineSegments: !0
        }), Me.prototype = Object.assign(Object.create(we.prototype), {
            constructor: Me,
            isLineLoop: !0
        }), ((Ee.prototype = Object.create(B.prototype)).constructor = Ee).prototype.isPointsMaterial = !0, Ee.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
        }, Se.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: Se,
            isPoints: !0,
            raycast: (So = new Et, Ao = new _t, Po = new V, function(r, s) {
                function t(t, e) {
                    var i, n = Ao.distanceSqToPoint(t);
                    n < l && ((t = Ao.closestPointToPoint(t)).applyMatrix4(o), (i = r.ray.origin.distanceTo(t)) < r.near || i > r.far || s.push({
                        distance: i,
                        distanceToRay: Math.sqrt(n),
                        point: t.clone(),
                        index: e,
                        face: null,
                        object: a
                    }))
                }
                var a = this,
                    e = this.geometry,
                    o = this.matrixWorld,
                    i = r.params.Points.threshold;
                if (null === e.boundingSphere && e.computeBoundingSphere(), Po.copy(e.boundingSphere), Po.applyMatrix4(o), Po.radius += i, !1 !== r.ray.intersectsSphere(Po)) {
                    So.getInverse(o), Ao.copy(r.ray).applyMatrix4(So);
                    var l = (i = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)) * i,
                        i = new St;
                    if (e.isBufferGeometry) {
                        var n = e.index,
                            e = e.attributes.position.array;
                        if (null !== n)
                            for (var h = n.array, n = 0, c = h.length; n < c; n++) {
                                var u = h[n];
                                i.fromArray(e, 3 * u), t(i, u)
                            } else
                                for (n = 0, h = e.length / 3; n < h; n++) i.fromArray(e, 3 * n), t(i, n)
                    } else
                        for (n = 0, h = (i = e.vertices).length; n < h; n++) t(i[n], n)
                }
            }),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Ae.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: Ae,
            isGroup: !0
        }), Pe.prototype = Object.assign(Object.create(d.prototype), {
            constructor: Pe,
            isVideoTexture: !0,
            update: function() {
                var t = this.image;
                t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), ((Ce.prototype = Object.create(d.prototype)).constructor = Ce).prototype.isCompressedTexture = !0, ((Re.prototype = Object.create(d.prototype)).constructor = Re).prototype.isDepthTexture = !0, (Le.prototype = Object.create(ut.prototype)).constructor = Le, (Oe.prototype = Object.create(K.prototype)).constructor = Oe, (De.prototype = Object.create(ut.prototype)).constructor = De, (ke.prototype = Object.create(K.prototype)).constructor = ke, (Ie.prototype = Object.create(ut.prototype)).constructor = Ie, (Ne.prototype = Object.create(K.prototype)).constructor = Ne, (ze.prototype = Object.create(Ie.prototype)).constructor = ze, (Be.prototype = Object.create(K.prototype)).constructor = Be, (Ue.prototype = Object.create(Ie.prototype)).constructor = Ue, (Fe.prototype = Object.create(K.prototype)).constructor = Fe, (He.prototype = Object.create(Ie.prototype)).constructor = He, (Ge.prototype = Object.create(K.prototype)).constructor = Ge, (Ve.prototype = Object.create(Ie.prototype)).constructor = Ve, (je.prototype = Object.create(K.prototype)).constructor = je, (We.prototype = Object.create(ut.prototype)).constructor = We, (Xe.prototype = Object.create(K.prototype)).constructor = Xe, (qe.prototype = Object.create(ut.prototype)).constructor = qe, (Ye.prototype = Object.create(K.prototype)).constructor = Ye, (Ze.prototype = Object.create(ut.prototype)).constructor = Ze;
        var Ro = function(t, e, i) {
                i = i || 2;
                var n, r = (l = e && e.length) ? e[0] * i : t.length,
                    s = Je(t, 0, r, i, !0),
                    a = [];
                if (!s) return a;
                if (l) {
                    for (var o = i, l = [], h = 0, c = e.length; h < c; h++) {
                        var u = e[h] * o;
                        (u = Je(t, u, h < c - 1 ? e[h + 1] * o : t.length, o, !1)) === u.next && (u.steiner = !0), l.push(function(t) {
                            for (var e = t, i = t; e.x < i.x && (i = e), e = e.next, e !== t;);
                            return i
                        }(u))
                    }
                    for (l.sort(Ke), h = 0; h < l.length; h++)(o = function(t, e) {
                        var i = e,
                            n = t.x,
                            r = t.y,
                            s = -1 / 0;
                        do {
                            if (r <= i.y && r >= i.next.y && i.next.y !== i.y)
                                if ((l = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y)) <= n && s < l) {
                                    if ((s = l) === n) {
                                        if (r === i.y) return i;
                                        if (r === i.next.y) return i.next
                                    }
                                    var a = i.x < i.next.x ? i : i.next
                                }
                        } while ((i = i.next) !== e);
                        if (!a) return null;
                        if (n === s) return a.prev;
                        for (var o, l = (e = a).x, h = a.y, c = 1 / 0, i = a.next; i !== e;) n >= i.x && i.x >= l && n !== i.x && ti(r < h ? n : s, r, l, h, r < h ? s : n, r, i.x, i.y) && (((o = Math.abs(r - i.y) / (n - i.x)) < c || o === c && i.x > a.x) && ri(i, t) && (a = i, c = o)), i = i.next;
                        return a
                    }(e = l[h], o = s)) && Qe(e = si(o, e), e.next), s = Qe(s, s.next)
                }
                if (t.length > 80 * i) {
                    for (var d = n = t[0], p = l = t[1], o = i; o < r; o += i)(h = t[o]) < d && (d = h), (e = t[o + 1]) < p && (p = e), n < h && (n = h), l < e && (l = e);
                    n = 0 !== (n = Math.max(n - d, l - p)) ? 1 / n : 0
                }
                return function t(e, i, n, r, s, a, o) {
                    if (e) {
                        if (!o && a) {
                            for (var l = e, h = l; null === h.z && (h.z = $e(h.x, h.y, r, s, a)), h.prevZ = h.prev, h = h.nextZ = h.next, h !== l;);
                            h.prevZ.nextZ = null, h.prevZ = null;
                            var c, u, l = h,
                                d = 1;
                            do {
                                h = l;
                                for (var p = l = null, f = 0; h;) {
                                    f++;
                                    for (var m = h, g = c = 0; g < d && (c++, m = m.nextZ); g++);
                                    for (u = d; 0 < c || 0 < u && m;) 0 !== c && (0 === u || !m || h.z <= m.z) ? (h = (g = h).nextZ, c--) : (m = (g = m).nextZ, u--), p ? p.nextZ = g : l = g, g.prevZ = p, p = g;
                                    h = m
                                }
                            } while (p.nextZ = null, d *= 2, 1 < f)
                        }
                        for (l = e; e.prev !== e.next;) {
                            if (h = e.prev, m = e.next, a) t: {
                                u = r;
                                var v = s;
                                if (0 <= ei(f = (p = e).prev, c = p, d = p.next)) p = !1;
                                else {
                                    var _ = (f.x > c.x ? f.x > d.x ? f : d : c.x > d.x ? c : d).x,
                                        y = (f.y > c.y ? f.y > d.y ? f : d : c.y > d.y ? c : d).y;
                                    for (g = $e((f.x < c.x ? f.x < d.x ? f : d : c.x < d.x ? c : d).x, (f.y < c.y ? f.y < d.y ? f : d : c.y < d.y ? c : d).y, u, v, a), u = $e(_, y, u, v, a), v = p.nextZ; v && v.z <= u;) {
                                        if (v !== p.prev && v !== p.next && ti(f.x, f.y, c.x, c.y, d.x, d.y, v.x, v.y) && 0 <= ei(v.prev, v, v.next)) {
                                            p = !1;
                                            break t
                                        }
                                        v = v.nextZ
                                    }
                                    for (v = p.prevZ; v && v.z >= g;) {
                                        if (v !== p.prev && v !== p.next && ti(f.x, f.y, c.x, c.y, d.x, d.y, v.x, v.y) && 0 <= ei(v.prev, v, v.next)) {
                                            p = !1;
                                            break t
                                        }
                                        v = v.prevZ
                                    }
                                    p = !0
                                }
                            }
                            else t: if (p = e, f = p.prev, c = p, d = p.next, 0 <= ei(f, c, d)) p = !1;
                                else {
                                    for (g = p.next.next; g !== p.prev;) {
                                        if (ti(f.x, f.y, c.x, c.y, d.x, d.y, g.x, g.y) && 0 <= ei(g.prev, g, g.next)) {
                                            p = !1;
                                            break t
                                        }
                                        g = g.next
                                    }
                                    p = !0
                                } if (p) i.push(h.i / n), i.push(e.i / n), i.push(m.i / n), oi(e), l = e = m.next;
                            else if ((e = m) === l) {
                                if (o) {
                                    if (1 === o) {
                                        for (o = i, l = n, h = e; m = h.prev, p = h.next.next, !ii(m, p) && ni(m, h, h.next, p) && ri(m, p) && ri(p, m) && (o.push(m.i / l), o.push(h.i / l), o.push(p.i / l), oi(h), oi(h.next), h = e = p), h = h.next, h !== e;);
                                        t(e = h, i, n, r, s, a, 2)
                                    } else if (2 === o) t: {
                                        o = e;do {
                                            for (l = o.next.next; l !== o.prev;) {
                                                if (h = o.i !== l.i) {
                                                    if (m = l, p = (h = o).next.i !== m.i && h.prev.i !== m.i) {
                                                        e: {
                                                            p = h;do {
                                                                if (p.i !== h.i && p.next.i !== h.i && p.i !== m.i && p.next.i !== m.i && ni(p, p.next, h, m)) {
                                                                    p = !0;
                                                                    break e
                                                                }
                                                            } while ((p = p.next) !== h);p = !1
                                                        }
                                                        p = !p
                                                    }
                                                    if (p = p && ri(h, m) && ri(m, h)) {
                                                        for (p = h, f = !1, c = (h.x + m.x) / 2, m = (h.y + m.y) / 2; p.y > m != p.next.y > m && p.next.y !== p.y && c < (p.next.x - p.x) * (m - p.y) / (p.next.y - p.y) + p.x && (f = !f), p = p.next, p !== h;);
                                                        p = f
                                                    }
                                                    h = p
                                                }
                                                if (h) {
                                                    e = si(o, l), o = Qe(o, o.next), e = Qe(e, e.next), t(o, i, n, r, s, a), t(e, i, n, r, s, a);
                                                    break t
                                                }
                                                l = l.next
                                            }
                                        } while ((o = o.next) !== e)
                                    }
                                } else t(Qe(e), i, n, r, s, a, 1);
                                break
                            }
                        }
                    }
                }(s, a, i, d, p, n), a
            },
            Lo = {
                area: function(t) {
                    for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                    return .5 * i
                },
                isClockWise: function(t) {
                    return Lo.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var i = [],
                        n = [],
                        r = [];
                    hi(t), ci(i, t);
                    var s = t.length;
                    for (e.forEach(hi), t = 0; t < e.length; t++) n.push(s), s += e[t].length, ci(i, e[t]);
                    for (e = Ro(i, n), t = 0; t < e.length; t += 3) r.push(e.slice(t, t + 3));
                    return r
                }
            };
        (ui.prototype = Object.create(K.prototype)).constructor = ui, ((di.prototype = Object.create(ut.prototype)).constructor = di).prototype.getArrays = function() {
            var t = (t = this.getAttribute("position")) ? Array.prototype.slice.call(t.array) : [],
                e = (e = this.getAttribute("uv")) ? Array.prototype.slice.call(e.array) : [],
                i = this.index;
            return {
                position: t,
                uv: e,
                index: i = i ? Array.prototype.slice.call(i.array) : []
            }
        }, di.prototype.addShapeList = function(t, e) {
            var i = t.length;
            e.arrays = this.getArrays();
            for (var n = 0; n < i; n++) this.addShape(t[n], e);
            this.setIndex(e.arrays.index), this.addAttribute("position", new ot(e.arrays.position, 3)), this.addAttribute("uv", new ot(e.arrays.uv, 2))
        }, di.prototype.addShape = function(t, i) {
            function e(t, e, i) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
            }

            function n(t, e, i) {
                var n = t.x - e.x,
                    r = t.y - e.y,
                    s = i.x - t.x,
                    a = i.y - t.y,
                    o = n * n + r * r;
                if (Math.abs(n * a - r * s) > Number.EPSILON) {
                    var l = Math.sqrt(o),
                        h = Math.sqrt(s * s + a * a),
                        o = e.x - r / l;
                    if (e = e.y + n / l, (r = (s = o + n * (a = ((i.x - a / h - o) * a - (i.y + s / h - e) * s) / (n * a - r * s)) - t.x) * s + (n = e + r * a - t.y) * n) <= 2) return new X(s, n);
                    r = Math.sqrt(r / 2)
                } else t = !1, n > Number.EPSILON ? s > Number.EPSILON && (t = !0) : n < -Number.EPSILON ? s < -Number.EPSILON && (t = !0) : Math.sign(r) === Math.sign(a) && (t = !0), r = t ? (s = -r, Math.sqrt(o)) : (s = n, n = r, Math.sqrt(o / 2));
                return new X(s / r, n / r)
            }

            function r(t, e) {
                for (B = t.length; 0 <= --B;) {
                    var i = B,
                        n = B - 1;
                    n < 0 && (n = t.length - 1);
                    for (var r = M + 2 * b, s = 0; s < r; s++) {
                        var a = N * s,
                            o = e + n + a,
                            l = e + n + (h = N * (s + 1)),
                            h = e + i + h;
                        c(e + i + a), c(o), c(h), c(o), c(l), c(h), a = f.length / 3, u((a = A.generateSideWallUV(P, f, a - 6, a - 3, a - 2, a - 1))[0]), u(a[1]), u(a[3]), u(a[1]), u(a[2]), u(a[3])
                    }
                }
            }

            function s(t, e, i) {
                v.push(t), v.push(e), v.push(i)
            }

            function a(t, e, i) {
                c(t), c(e), c(i), t = f.length / 3, u((t = A.generateTopUV(P, f, t - 3, t - 2, t - 1))[0]), u(t[1]), u(t[2])
            }

            function c(t) {
                m.push(f.length / 3), f.push(v[3 * t + 0]), f.push(v[3 * t + 1]), f.push(v[3 * t + 2])
            }

            function u(t) {
                g.push(t.x), g.push(t.y)
            }
            var o, l, h, d, p, f = (_ = i.arrays || this.getArrays()).position,
                m = _.index,
                g = _.uv,
                v = [],
                _ = void 0 !== i.amount ? i.amount : 100,
                y = void 0 !== i.bevelThickness ? i.bevelThickness : 6,
                x = void 0 !== i.bevelSize ? i.bevelSize : y - 2,
                b = void 0 !== i.bevelSegments ? i.bevelSegments : 3,
                w = void 0 === i.bevelEnabled || i.bevelEnabled,
                T = void 0 !== i.curveSegments ? i.curveSegments : 12,
                M = void 0 !== i.steps ? i.steps : 1,
                E = i.extrudePath,
                S = !1,
                A = void 0 !== i.UVGenerator ? i.UVGenerator : ui.WorldUVGenerator;
            E && (o = E.getSpacedPoints(M), w = !(S = !0), l = void 0 !== i.frames ? i.frames : E.computeFrenetFrames(M, !1), h = new St, d = new St, p = new St), w || (x = y = b = 0);
            var P = this;
            t = (T = t.extractPoints(T)).shape;
            var C = T.holes;
            if (!Lo.isClockWise(t)) {
                t = t.reverse();
                for (var R = 0, L = C.length; R < L; R++) {
                    var O = C[R];
                    Lo.isClockWise(O) && (C[R] = O.reverse())
                }
            }
            var D = Lo.triangulateShape(t, C),
                k = t,
                R = 0;
            for (L = C.length; R < L; R++) O = C[R], t = t.concat(O);
            var I, N = t.length,
                z = D.length,
                T = [],
                B = 0,
                U = (H = k.length) - 1;
            for (V = B + 1; B < H; B++, U++, V++) U === H && (U = 0), V === H && (V = 0), T[B] = n(k[B], k[U], k[V]);
            var E = [],
                F = T.concat();
            for (R = 0, L = C.length; R < L; R++) {
                O = C[R];
                for (var H, G = [], B = 0, U = (H = O.length) - 1, V = B + 1; B < H; B++, U++, V++) U === H && (U = 0), V === H && (V = 0), G[B] = n(O[B], O[U], O[V]);
                E.push(G), F = F.concat(G)
            }
            for (U = 0; U < b; U++) {
                H = U / b;
                var j = y * Math.cos(H * Math.PI / 2);
                for (V = x * Math.sin(H * Math.PI / 2), B = 0, H = k.length; B < H; B++) {
                    var W = e(k[B], T[B], V);
                    s(W.x, W.y, -j)
                }
                for (R = 0, L = C.length; R < L; R++)
                    for (O = C[R], G = E[R], B = 0, H = O.length; B < H; B++) s((W = e(O[B], G[B], V)).x, W.y, -j)
            }
            for (V = x, B = 0; B < N; B++) W = w ? e(t[B], F[B], V) : t[B], S ? (d.copy(l.normals[0]).multiplyScalar(W.x), h.copy(l.binormals[0]).multiplyScalar(W.y), p.copy(o[0]).add(d).add(h), s(p.x, p.y, p.z)) : s(W.x, W.y, 0);
            for (H = 1; H <= M; H++)
                for (B = 0; B < N; B++) W = w ? e(t[B], F[B], V) : t[B], S ? (d.copy(l.normals[H]).multiplyScalar(W.x), h.copy(l.binormals[H]).multiplyScalar(W.y), p.copy(o[H]).add(d).add(h), s(p.x, p.y, p.z)) : s(W.x, W.y, _ / M * H);
            for (U = b - 1; 0 <= U; U--) {
                for (H = U / b, j = y * Math.cos(H * Math.PI / 2), V = x * Math.sin(H * Math.PI / 2), B = 0, H = k.length; B < H; B++) s((W = e(k[B], T[B], V)).x, W.y, _ + j);
                for (R = 0, L = C.length; R < L; R++)
                    for (O = C[R], G = E[R], B = 0, H = O.length; B < H; B++) W = e(O[B], G[B], V), S ? s(W.x, W.y + o[M - 1].y, o[M - 1].x + j) : s(W.x, W.y, _ + j)
            }! function() {
                var t = f.length / 3;
                if (w) {
                    var e = 0 * N;
                    for (B = 0; B < z; B++) a((I = D[B])[2] + e, I[1] + e, I[0] + e);
                    for (e = N * (M + 2 * b), B = 0; B < z; B++) a((I = D[B])[0] + e, I[1] + e, I[2] + e)
                } else {
                    for (B = 0; B < z; B++) a((I = D[B])[2], I[1], I[0]);
                    for (B = 0; B < z; B++) a((I = D[B])[0] + N * M, I[1] + N * M, I[2] + N * M)
                }
                P.addGroup(t, f.length / 3 - t, void 0 !== i.material ? i.material : 0)
            }(),
            function() {
                var t = f.length / 3,
                    e = 0;
                for (r(k, e), e += k.length, R = 0, L = C.length; R < L; R++) r(O = C[R], e), e += O.length;
                P.addGroup(t, f.length / 3 - t, void 0 !== i.extrudeMaterial ? i.extrudeMaterial : 1)
            }(), i.arrays || (this.setIndex(m), this.addAttribute("position", new ot(f, 3)), this.addAttribute("uv", new ot(g, 2)))
        }, ui.WorldUVGenerator = {
            generateTopUV: function(t, e, i, n, r) {
                t = e[3 * n], n = e[3 * n + 1];
                var s = e[3 * r];
                return r = e[3 * r + 1], [new X(e[3 * i], e[3 * i + 1]), new X(t, n), new X(s, r)]
            },
            generateSideWallUV: function(t, e, i, n, r, s) {
                t = e[3 * i];
                var a = e[3 * i + 1];
                i = e[3 * i + 2];
                var o = e[3 * n],
                    l = e[3 * n + 1];
                n = e[3 * n + 2];
                var h = e[3 * r],
                    c = e[3 * r + 1];
                r = e[3 * r + 2];
                var u = e[3 * s],
                    d = e[3 * s + 1];
                return e = e[3 * s + 2], Math.abs(a - l) < .01 ? [new X(t, 1 - i), new X(o, 1 - n), new X(h, 1 - r), new X(u, 1 - e)] : [new X(a, 1 - i), new X(l, 1 - n), new X(c, 1 - r), new X(d, 1 - e)]
            }
        }, (pi.prototype = Object.create(K.prototype)).constructor = pi, (fi.prototype = Object.create(di.prototype)).constructor = fi, (mi.prototype = Object.create(K.prototype)).constructor = mi, (gi.prototype = Object.create(ut.prototype)).constructor = gi, (vi.prototype = Object.create(K.prototype)).constructor = vi, (_i.prototype = Object.create(ut.prototype)).constructor = _i, (yi.prototype = Object.create(K.prototype)).constructor = yi, (xi.prototype = Object.create(ut.prototype)).constructor = xi, ((bi.prototype = Object.create(K.prototype)).constructor = bi).prototype.toJSON = function() {
            var t = K.prototype.toJSON.call(this);
            return Ti(this.parameters.shapes, t)
        }, ((wi.prototype = Object.create(ut.prototype)).constructor = wi).prototype.toJSON = function() {
            var t = ut.prototype.toJSON.call(this);
            return Ti(this.parameters.shapes, t)
        }, (Mi.prototype = Object.create(ut.prototype)).constructor = Mi, (Ei.prototype = Object.create(K.prototype)).constructor = Ei, (Si.prototype = Object.create(ut.prototype)).constructor = Si, (Ai.prototype = Object.create(Ei.prototype)).constructor = Ai, (Pi.prototype = Object.create(Si.prototype)).constructor = Pi, (Ci.prototype = Object.create(K.prototype)).constructor = Ci, (Ri.prototype = Object.create(ut.prototype)).constructor = Ri;
        var Oo = Object.freeze({
            WireframeGeometry: Le,
            ParametricGeometry: Oe,
            ParametricBufferGeometry: De,
            TetrahedronGeometry: Ne,
            TetrahedronBufferGeometry: ze,
            OctahedronGeometry: Be,
            OctahedronBufferGeometry: Ue,
            IcosahedronGeometry: Fe,
            IcosahedronBufferGeometry: He,
            DodecahedronGeometry: Ge,
            DodecahedronBufferGeometry: Ve,
            PolyhedronGeometry: ke,
            PolyhedronBufferGeometry: Ie,
            TubeGeometry: je,
            TubeBufferGeometry: We,
            TorusKnotGeometry: Xe,
            TorusKnotBufferGeometry: qe,
            TorusGeometry: Ye,
            TorusBufferGeometry: Ze,
            TextGeometry: pi,
            TextBufferGeometry: fi,
            SphereGeometry: mi,
            SphereBufferGeometry: gi,
            RingGeometry: vi,
            RingBufferGeometry: _i,
            PlaneGeometry: ft,
            PlaneBufferGeometry: mt,
            LatheGeometry: yi,
            LatheBufferGeometry: xi,
            ShapeGeometry: bi,
            ShapeBufferGeometry: wi,
            ExtrudeGeometry: ui,
            ExtrudeBufferGeometry: di,
            EdgesGeometry: Mi,
            ConeGeometry: Ai,
            ConeBufferGeometry: Pi,
            CylinderGeometry: Ei,
            CylinderBufferGeometry: Si,
            CircleGeometry: Ci,
            CircleBufferGeometry: Ri,
            BoxGeometry: dt,
            BoxBufferGeometry: pt
        });
        ((Li.prototype = Object.create(B.prototype)).constructor = Li).prototype.isShadowMaterial = !0, ((Oi.prototype = Object.create(vt.prototype)).constructor = Oi).prototype.isRawShaderMaterial = !0, ((Di.prototype = Object.create(B.prototype)).constructor = Di).prototype.isMeshStandardMaterial = !0, Di.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((ki.prototype = Object.create(Di.prototype)).constructor = ki).prototype.isMeshPhysicalMaterial = !0, ki.prototype.copy = function(t) {
            return Di.prototype.copy.call(this, t), this.defines = {
                PHYSICAL: ""
            }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
        }, ((Ii.prototype = Object.create(B.prototype)).constructor = Ii).prototype.isMeshPhongMaterial = !0, Ii.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((Ni.prototype = Object.create(Ii.prototype)).constructor = Ni).prototype.isMeshToonMaterial = !0, Ni.prototype.copy = function(t) {
            return Ii.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
        }, ((zi.prototype = Object.create(B.prototype)).constructor = zi).prototype.isMeshNormalMaterial = !0, zi.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((Bi.prototype = Object.create(B.prototype)).constructor = Bi).prototype.isMeshLambertMaterial = !0, Bi.prototype.copy = function(t) {
            return B.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((Ui.prototype = Object.create(be.prototype)).constructor = Ui).prototype.isLineDashedMaterial = !0, Ui.prototype.copy = function(t) {
            return be.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var Do = Object.freeze({
                ShadowMaterial: Li,
                SpriteMaterial: me,
                RawShaderMaterial: Oi,
                ShaderMaterial: vt,
                PointsMaterial: Ee,
                MeshPhysicalMaterial: ki,
                MeshStandardMaterial: Di,
                MeshPhongMaterial: Ii,
                MeshToonMaterial: Ni,
                MeshNormalMaterial: zi,
                MeshLambertMaterial: Bi,
                MeshDepthMaterial: U,
                MeshDistanceMaterial: F,
                MeshBasicMaterial: gt,
                LineDashedMaterial: Ui,
                LineBasicMaterial: be,
                Material: B
            }),
            ko = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            },
            Io = new Fi,
            No = {};
        Object.assign(Hi.prototype, {
            load: function(a, t, e, i) {
                void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
                var o = this,
                    n = ko.get(a);
                if (void 0 !== n) return o.manager.itemStart(a), setTimeout(function() {
                    t && t(n), o.manager.itemEnd(a)
                }, 0), n;
                if (void 0 === No[a]) {
                    if (s = a.match(/^data:(.*?)(;base64)?,(.*)$/)) {
                        e = s[1];
                        var r = !!s[2],
                            s = s[3],
                            s = window.decodeURIComponent(s);
                        r && (s = window.atob(s));
                        try {
                            var l = (this.responseType || "").toLowerCase();
                            switch (l) {
                                case "arraybuffer":
                                case "blob":
                                    for (var h = new Uint8Array(s.length), r = 0; r < s.length; r++) h[r] = s.charCodeAt(r);
                                    var c = "blob" === l ? new Blob([h.buffer], {
                                        type: e
                                    }) : h.buffer;
                                    break;
                                case "document":
                                    c = (new DOMParser).parseFromString(s, e);
                                    break;
                                case "json":
                                    c = JSON.parse(s);
                                    break;
                                default:
                                    c = s
                            }
                            window.setTimeout(function() {
                                t && t(c), o.manager.itemEnd(a)
                            }, 0)
                        } catch (t) {
                            window.setTimeout(function() {
                                i && i(t), o.manager.itemEnd(a), o.manager.itemError(a)
                            }, 0)
                        }
                    } else {
                        No[a] = [], No[a].push({
                            onLoad: t,
                            onProgress: e,
                            onError: i
                        });
                        var u = new XMLHttpRequest;
                        for (r in u.open("GET", a, !0), u.addEventListener("load", function(t) {
                                var e = this.response;
                                ko.add(a, e);
                                var i = No[a];
                                if (delete No[a], 200 === this.status) {
                                    for (var n = 0, r = i.length; n < r; n++) {
                                        var s = i[n];
                                        s.onLoad && s.onLoad(e)
                                    }
                                    o.manager.itemEnd(a)
                                } else if (0 === this.status) {
                                    for (console.warn("THREE.FileLoader: HTTP Status 0 received."), n = 0, r = i.length; n < r; n++)(s = i[n]).onLoad && s.onLoad(e);
                                    o.manager.itemEnd(a)
                                } else {
                                    for (n = 0, r = i.length; n < r; n++)(s = i[n]).onError && s.onError(t);
                                    o.manager.itemEnd(a), o.manager.itemError(a)
                                }
                            }, !1), u.addEventListener("progress", function(t) {
                                for (var e = No[a], i = 0, n = e.length; i < n; i++) {
                                    var r = e[i];
                                    r.onProgress && r.onProgress(t)
                                }
                            }, !1), u.addEventListener("error", function(t) {
                                var e = No[a];
                                delete No[a];
                                for (var i = 0, n = e.length; i < n; i++) {
                                    var r = e[i];
                                    r.onError && r.onError(t)
                                }
                                o.manager.itemEnd(a), o.manager.itemError(a)
                            }, !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) u.setRequestHeader(r, this.requestHeader[r]);
                        u.send(null)
                    }
                    return o.manager.itemStart(a), u
                }
                No[a].push({
                    onLoad: t,
                    onProgress: e,
                    onError: i
                })
            },
            setPath: function(t) {
                return this.path = t, this
            },
            setResponseType: function(t) {
                return this.responseType = t, this
            },
            setWithCredentials: function(t) {
                return this.withCredentials = t, this
            },
            setMimeType: function(t) {
                return this.mimeType = t, this
            },
            setRequestHeader: function(t) {
                return this.requestHeader = t, this
            }
        }), Object.assign(Gi.prototype, {
            load: function(t, r, i, n) {
                var s, a = this,
                    o = [],
                    l = new Ce;
                l.image = o;
                var h = new Hi(this.manager);
                if (h.setPath(this.path), h.setResponseType("arraybuffer"), Array.isArray(t))
                    for (var e = s = 0, c = t.length; e < c; ++e) ! function(e) {
                        h.load(t[e], function(t) {
                            t = a._parser(t, !0), o[e] = {
                                width: t.width,
                                height: t.height,
                                format: t.format,
                                mipmaps: t.mipmaps
                            }, 6 === (s += 1) && (1 === t.mipmapCount && (l.minFilter = 1006), l.format = t.format, l.needsUpdate = !0, r && r(l))
                        }, i, n)
                    }(e);
                else h.load(t, function(t) {
                    if ((t = a._parser(t, !0)).isCubemap)
                        for (var e = t.mipmaps.length / t.mipmapCount, i = 0; i < e; i++) {
                            o[i] = {
                                mipmaps: []
                            };
                            for (var n = 0; n < t.mipmapCount; n++) o[i].mipmaps.push(t.mipmaps[i * t.mipmapCount + n]), o[i].format = t.format, o[i].width = t.width, o[i].height = t.height
                        } else l.image.width = t.width, l.image.height = t.height, l.mipmaps = t.mipmaps;
                    1 === t.mipmapCount && (l.minFilter = 1006), l.format = t.format, l.needsUpdate = !0, r && r(l)
                }, i, n);
                return l
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(Vi.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    s = new Pt,
                    a = new Hi(this.manager);
                return a.setResponseType("arraybuffer"), a.load(t, function(t) {
                    (t = r._parser(t)) && (void 0 !== t.image ? s.image = t.image : void 0 !== t.data && (s.image.width = t.width, s.image.height = t.height, s.image.data = t.data), s.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001, s.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001, s.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006, s.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008, s.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (s.format = t.format), void 0 !== t.type && (s.type = t.type), void 0 !== t.mipmaps && (s.mipmaps = t.mipmaps), 1 === t.mipmapCount && (s.minFilter = 1006), s.needsUpdate = !0, e && e(s, t))
                }, i, n), s
            }
        }), Object.assign(ji.prototype, {
            crossOrigin: "Anonymous",
            load: function(e, t, i, n) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                var r = this,
                    s = ko.get(e);
                return void 0 !== s ? (r.manager.itemStart(e), setTimeout(function() {
                    t && t(s), r.manager.itemEnd(e)
                }, 0), s) : ((i = document.createElementNS("http://www.w3.org/1999/xhtml", "img")).addEventListener("load", function() {
                    ko.add(e, this), t && t(this), r.manager.itemEnd(e)
                }, !1), i.addEventListener("error", function(t) {
                    n && n(t), r.manager.itemEnd(e), r.manager.itemError(e)
                }, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (i.crossOrigin = this.crossOrigin), r.manager.itemStart(e), i.src = e, i)
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(Wi.prototype, {
            crossOrigin: "Anonymous",
            load: function(t, i, e, n) {
                var r = new l,
                    s = new ji(this.manager);
                s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                var a = 0;
                for (e = 0; e < t.length; ++e) ! function(e) {
                    s.load(t[e], function(t) {
                        r.images[e] = t, 6 === ++a && (r.needsUpdate = !0, i && i(r))
                    }, void 0, n)
                }(e);
                return r
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(Xi.prototype, {
            crossOrigin: "Anonymous",
            load: function(e, i, t, n) {
                var r = new d,
                    s = new ji(this.manager);
                return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function(t) {
                    r.image = t, t = 0 < e.search(/\.(jpg|jpeg)$/) || 0 === e.search(/^data\:image\/jpeg/), r.format = t ? 1022 : 1023, r.needsUpdate = !0, void 0 !== i && i(r)
                }, t, n), r
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(qi.prototype, {
            getPoint: function() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            },
            getPointAt: function(t, e) {
                return t = this.getUtoTmapping(t), this.getPoint(t, e)
            },
            getPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return e
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                return e
            },
            getLength: function() {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, i = [],
                    n = this.getPoint(0),
                    r = 0;
                for (i.push(0), e = 1; e <= t; e++) {
                    var s = this.getPoint(e / t);
                    r += s.distanceTo(n), i.push(r), n = s
                }
                return this.cacheArcLengths = i
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                var i = this.getLengths(),
                    n = i.length;
                e = e || t * i[n - 1];
                for (var r, s = 0, a = n - 1; s <= a;)
                    if ((r = i[t = Math.floor(s + (a - s) / 2)] - e) < 0) s = t + 1;
                    else {
                        if (!(0 < r)) {
                            a = t;
                            break
                        }
                        a = t - 1
                    }
                return i[t = a] === e ? t / (n - 1) : (t + (e - (s = i[t])) / (i[t + 1] - s)) / (n - 1)
            },
            getTangent: function(t) {
                var e = t - 1e-4;
                return e < 0 && (e = 0), 1 < (t += 1e-4) && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize()
            },
            getTangentAt: function(t) {
                return t = this.getUtoTmapping(t), this.getTangent(t)
            },
            computeFrenetFrames: function(t, e) {
                for (var i = new St, n = [], r = [], s = [], a = new St, o = new Et, l = 0; l <= t; l++) {
                    var h = l / t;
                    n[l] = this.getTangentAt(h), n[l].normalize()
                }
                r[0] = new St, s[0] = new St, l = Number.MAX_VALUE, h = Math.abs(n[0].x);
                var c = Math.abs(n[0].y),
                    u = Math.abs(n[0].z);
                for (h <= l && (l = h, i.set(1, 0, 0)), c <= l && (l = c, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), s[0].crossVectors(n[0], r[0]), l = 1; l <= t; l++) r[l] = r[l - 1].clone(), s[l] = s[l - 1].clone(), a.crossVectors(n[l - 1], n[l]), a.length() > Number.EPSILON && (a.normalize(), i = Math.acos(es.clamp(n[l - 1].dot(n[l]), -1, 1)), r[l].applyMatrix4(o.makeRotationAxis(a, i))), s[l].crossVectors(n[l], r[l]);
                if (!0 === e)
                    for (i = Math.acos(es.clamp(r[0].dot(r[t]), -1, 1)), i /= t, 0 < n[0].dot(a.crossVectors(r[0], r[t])) && (i = -i), l = 1; l <= t; l++) r[l].applyMatrix4(o.makeRotationAxis(n[l], i * l)), s[l].crossVectors(n[l], r[l]);
                return {
                    tangents: n,
                    normals: r,
                    binormals: s
                }
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            },
            fromJSON: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }), ((Yi.prototype = Object.create(qi.prototype)).constructor = Yi).prototype.isEllipseCurve = !0, Yi.prototype.getPoint = function(t, e) {
            e = e || new X;
            for (var i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, r = Math.abs(n) < Number.EPSILON; n < 0;) n += i;
            for (; i < n;) n -= i;
            n < Number.EPSILON && (n = r ? 0 : i), !0 !== this.aClockwise || r || (n = n === i ? -i : n - i), i = this.aStartAngle + t * n, t = this.aX + this.xRadius * Math.cos(i);
            var s = this.aY + this.yRadius * Math.sin(i);
            return 0 !== this.aRotation && (i = Math.cos(this.aRotation), n = Math.sin(this.aRotation), t = (r = t - this.aX) * i - (s -= this.aY) * n + this.aX, s = r * n + s * i + this.aY), e.set(t, s)
        }, Yi.prototype.copy = function(t) {
            return qi.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, Yi.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
        }, Yi.prototype.fromJSON = function(t) {
            return qi.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, ((Zi.prototype = Object.create(Yi.prototype)).constructor = Zi).prototype.isArcCurve = !0;
        var zo = new St,
            Bo = new Ji,
            Uo = new Ji,
            Fo = new Ji;
        ((Qi.prototype = Object.create(qi.prototype)).constructor = Qi).prototype.isCatmullRomCurve3 = !0, Qi.prototype.getPoint = function(t, e) {
            e = e || new St;
            var i = (l = this.points).length;
            t *= i - (this.closed ? 0 : 1);
            var n, r = Math.floor(t);
            t -= r, this.closed ? r += 0 < r ? 0 : (Math.floor(Math.abs(r) / l.length) + 1) * l.length : 0 === t && r === i - 1 && (r = i - 2, t = 1), n = this.closed || 0 < r ? l[(r - 1) % i] : (zo.subVectors(l[0], l[1]).add(l[0]), zo);
            var s, a = l[r % i],
                o = l[(r + 1) % i],
                l = this.closed || r + 2 < i ? l[(r + 2) % i] : (zo.subVectors(l[i - 1], l[i - 2]).add(l[i - 1]), zo);
            return "centripetal" === this.curveType || "chordal" === this.curveType ? (s = "chordal" === this.curveType ? .5 : .25, i = Math.pow(n.distanceToSquared(a), s), (r = Math.pow(a.distanceToSquared(o), s)) < 1e-4 && (r = 1), i < 1e-4 && (i = r), (s = Math.pow(o.distanceToSquared(l), s)) < 1e-4 && (s = r), Bo.initNonuniformCatmullRom(n.x, a.x, o.x, l.x, i, r, s), Uo.initNonuniformCatmullRom(n.y, a.y, o.y, l.y, i, r, s), Fo.initNonuniformCatmullRom(n.z, a.z, o.z, l.z, i, r, s)) : "catmullrom" === this.curveType && (Bo.initCatmullRom(n.x, a.x, o.x, l.x, this.tension), Uo.initCatmullRom(n.y, a.y, o.y, l.y, this.tension), Fo.initCatmullRom(n.z, a.z, o.z, l.z, this.tension)), e.set(Bo.calc(t), Uo.calc(t), Fo.calc(t)), e
        }, Qi.prototype.copy = function(t) {
            qi.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) this.points.push(t.points[e].clone());
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Qi.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) t.points.push(this.points[e].toArray());
            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
        }, Qi.prototype.fromJSON = function(t) {
            qi.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push((new St).fromArray(n))
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, ((en.prototype = Object.create(qi.prototype)).constructor = en).prototype.isCubicBezierCurve = !0, en.prototype.getPoint = function(t, e) {
            e = e || new X;
            var i = this.v0,
                n = this.v1,
                r = this.v2,
                s = this.v3;
            return e.set(tn(t, i.x, n.x, r.x, s.x), tn(t, i.y, n.y, r.y, s.y)), e
        }, en.prototype.copy = function(t) {
            return qi.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, en.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, en.prototype.fromJSON = function(t) {
            return qi.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, ((nn.prototype = Object.create(qi.prototype)).constructor = nn).prototype.isCubicBezierCurve3 = !0, nn.prototype.getPoint = function(t, e) {
            e = e || new St;
            var i = this.v0,
                n = this.v1,
                r = this.v2,
                s = this.v3;
            return e.set(tn(t, i.x, n.x, r.x, s.x), tn(t, i.y, n.y, r.y, s.y), tn(t, i.z, n.z, r.z, s.z)), e
        }, nn.prototype.copy = function(t) {
            return qi.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, nn.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, nn.prototype.fromJSON = function(t) {
            return qi.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, ((rn.prototype = Object.create(qi.prototype)).constructor = rn).prototype.isLineCurve = !0, rn.prototype.getPoint = function(t, e) {
            return e = e || new X, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
        }, rn.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, rn.prototype.getTangent = function() {
            return this.v2.clone().sub(this.v1).normalize()
        }, rn.prototype.copy = function(t) {
            return qi.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, rn.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, rn.prototype.fromJSON = function(t) {
            return qi.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((sn.prototype = Object.create(qi.prototype)).constructor = sn).prototype.isLineCurve3 = !0, sn.prototype.getPoint = function(t, e) {
            return e = e || new St, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
        }, sn.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, sn.prototype.copy = function(t) {
            return qi.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, sn.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, sn.prototype.fromJSON = function(t) {
            return qi.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((an.prototype = Object.create(qi.prototype)).constructor = an).prototype.isQuadraticBezierCurve = !0, an.prototype.getPoint = function(t, e) {
            e = e || new X;
            var i = this.v0,
                n = this.v1,
                r = this.v2;
            return e.set($i(t, i.x, n.x, r.x), $i(t, i.y, n.y, r.y)), e
        }, an.prototype.copy = function(t) {
            return qi.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, an.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, an.prototype.fromJSON = function(t) {
            return qi.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((on.prototype = Object.create(qi.prototype)).constructor = on).prototype.isQuadraticBezierCurve3 = !0, on.prototype.getPoint = function(t, e) {
            e = e || new St;
            var i = this.v0,
                n = this.v1,
                r = this.v2;
            return e.set($i(t, i.x, n.x, r.x), $i(t, i.y, n.y, r.y), $i(t, i.z, n.z, r.z)), e
        }, on.prototype.copy = function(t) {
            return qi.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, on.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, on.prototype.fromJSON = function(t) {
            return qi.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((ln.prototype = Object.create(qi.prototype)).constructor = ln).prototype.isSplineCurve = !0, ln.prototype.getPoint = function(t, e) {
            e = e || new X;
            var i = (i = ((a = this.points).length - 1) * t) - (t = Math.floor(i)),
                n = a[0 === t ? t : t - 1],
                r = a[t],
                s = a[t > a.length - 2 ? a.length - 1 : t + 1],
                a = a[t > a.length - 3 ? a.length - 1 : t + 2];
            return e.set(Ki(i, n.x, r.x, s.x, a.x), Ki(i, n.y, r.y, s.y, a.y)), e
        }, ln.prototype.copy = function(t) {
            qi.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) this.points.push(t.points[e].clone());
            return this
        }, ln.prototype.toJSON = function() {
            var t = qi.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) t.points.push(this.points[e].toArray());
            return t
        }, ln.prototype.fromJSON = function(t) {
            qi.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push((new X).fromArray(n))
            }
            return this
        };
        var Ho = Object.freeze({
            ArcCurve: Zi,
            CatmullRomCurve3: Qi,
            CubicBezierCurve: en,
            CubicBezierCurve3: nn,
            EllipseCurve: Yi,
            LineCurve: rn,
            LineCurve3: sn,
            QuadraticBezierCurve: an,
            QuadraticBezierCurve3: on,
            SplineCurve: ln
        });
        hn.prototype = Object.assign(Object.create(qi.prototype), {
            constructor: hn,
            add: function(t) {
                this.curves.push(t)
            },
            closePath: function() {
                var t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new rn(e, t))
            },
            getPoint: function(t) {
                var e = t * this.getLength(),
                    i = this.getCurveLengths();
                for (t = 0; t < i.length;) {
                    if (i[t] >= e) return e = i[t] - e, i = (t = this.curves[t]).getLength(), t.getPointAt(0 === i ? 0 : 1 - e / i);
                    t++
                }
                return null
            },
            getLength: function() {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 40);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            },
            getPoints: function(t) {
                t = t || 12;
                for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                    for (var s = (s = r[n]).getPoints(s && s.isEllipseCurve ? 2 * t : s && s.isLineCurve ? 1 : s && s.isSplineCurve ? t * s.points.length : t), a = 0; a < s.length; a++) {
                        var o = s[a];
                        e && e.equals(o) || (i.push(o), e = o)
                    }
                return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
            },
            copy: function(t) {
                qi.prototype.copy.call(this, t), this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) this.curves.push(t.curves[e].clone());
                return this.autoClose = t.autoClose, this
            },
            toJSON: function() {
                var t = qi.prototype.toJSON.call(this);
                t.autoClose = this.autoClose, t.curves = [];
                for (var e = 0, i = this.curves.length; e < i; e++) t.curves.push(this.curves[e].toJSON());
                return t
            },
            fromJSON: function(t) {
                qi.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var n = t.curves[e];
                    this.curves.push((new Ho[n.type]).fromJSON(n))
                }
                return this
            }
        }), cn.prototype = Object.assign(Object.create(hn.prototype), {
            constructor: cn,
            setFromPoints: function(t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
            },
            moveTo: function(t, e) {
                this.currentPoint.set(t, e)
            },
            lineTo: function(t, e) {
                var i = new rn(this.currentPoint.clone(), new X(t, e));
                this.curves.push(i), this.currentPoint.set(t, e)
            },
            quadraticCurveTo: function(t, e, i, n) {
                t = new an(this.currentPoint.clone(), new X(t, e), new X(i, n)), this.curves.push(t), this.currentPoint.set(i, n)
            },
            bezierCurveTo: function(t, e, i, n, r, s) {
                t = new en(this.currentPoint.clone(), new X(t, e), new X(i, n), new X(r, s)), this.curves.push(t), this.currentPoint.set(r, s)
            },
            splineThru: function(t) {
                var e = new ln(e = [this.currentPoint.clone()].concat(t));
                this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
            },
            arc: function(t, e, i, n, r, s) {
                this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, s)
            },
            absarc: function(t, e, i, n, r, s) {
                this.absellipse(t, e, i, i, n, r, s)
            },
            ellipse: function(t, e, i, n, r, s, a, o) {
                this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, s, a, o)
            },
            absellipse: function(t, e, i, n, r, s, a, o) {
                t = new Yi(t, e, i, n, r, s, a, o), 0 < this.curves.length && ((e = t.getPoint(0)).equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t)
            },
            copy: function(t) {
                return hn.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
            },
            toJSON: function() {
                var t = hn.prototype.toJSON.call(this);
                return t.currentPoint = this.currentPoint.toArray(), t
            },
            fromJSON: function(t) {
                return hn.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }), un.prototype = Object.assign(Object.create(cn.prototype), {
            constructor: un,
            getPointsHoles: function(t) {
                for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                return e
            },
            extractPoints: function(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            copy: function(t) {
                cn.prototype.copy.call(this, t), this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) this.holes.push(t.holes[e].clone());
                return this
            },
            toJSON: function() {
                var t = cn.prototype.toJSON.call(this);
                t.uuid = this.uuid, t.holes = [];
                for (var e = 0, i = this.holes.length; e < i; e++) t.holes.push(this.holes[e].toJSON());
                return t
            },
            fromJSON: function(t) {
                cn.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var n = t.holes[e];
                    this.holes.push((new cn).fromJSON(n))
                }
                return this
            }
        }), dn.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: dn,
            isLight: !0,
            copy: function(t) {
                return Y.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function(t) {
                return (t = Y.prototype.toJSON.call(this, t)).object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }), pn.prototype = Object.assign(Object.create(dn.prototype), {
            constructor: pn,
            isHemisphereLight: !0,
            copy: function(t) {
                return dn.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(fn.prototype, {
            copy: function(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), mn.prototype = Object.assign(Object.create(fn.prototype), {
            constructor: mn,
            isSpotLightShadow: !0,
            update: function(t) {
                var e = this.camera,
                    i = 2 * es.RAD2DEG * t.angle,
                    n = this.mapSize.width / this.mapSize.height;
                t = t.distance || e.far, i === e.fov && n === e.aspect && t === e.far || (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix())
            }
        }), gn.prototype = Object.assign(Object.create(dn.prototype), {
            constructor: gn,
            isSpotLight: !0,
            copy: function(t) {
                return dn.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), vn.prototype = Object.assign(Object.create(dn.prototype), {
            constructor: vn,
            isPointLight: !0,
            copy: function(t) {
                return dn.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), _n.prototype = Object.assign(Object.create(fn.prototype), {
            constructor: _n
        }), yn.prototype = Object.assign(Object.create(dn.prototype), {
            constructor: yn,
            isDirectionalLight: !0,
            copy: function(t) {
                return dn.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), xn.prototype = Object.assign(Object.create(dn.prototype), {
            constructor: xn,
            isAmbientLight: !0
        }), bn.prototype = Object.assign(Object.create(dn.prototype), {
            constructor: bn,
            isRectAreaLight: !0,
            copy: function(t) {
                return dn.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function(t) {
                return (t = dn.prototype.toJSON.call(this, t)).object.width = this.width, t.object.height = this.height, t
            }
        }), wn.prototype = Object.assign(Object.create(On.prototype), {
            constructor: wn,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Tn.prototype = Object.assign(Object.create(On.prototype), {
            constructor: Tn,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Object.assign(Mn.prototype, {
            evaluate: function(t) {
                var e = this.parameterPositions,
                    i = this._cachedIndex,
                    n = e[i],
                    r = e[i - 1];
                t: {
                    e: {
                        i: {
                            n: if (!(t < n)) {
                                for (var s = i + 2;;) {
                                    if (void 0 === n) {
                                        if (t < r) break n;
                                        return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, r)
                                    }
                                    if (i === s) break;
                                    if (r = n, t < (n = e[++i])) break e
                                }
                                n = e.length;
                                break i
                            }if (r <= t) break t;
                            for (t < (s = e[1]) && (i = 2, r = s), s = i - 2;;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                if (i === s) break;
                                if (n = r, (r = e[--i - 1]) <= t) break e
                            }
                            n = i,
                            i = 0
                        }
                        for (; i < n;) t < e[r = i + n >>> 1] ? n = r : i = r + 1;
                        if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                        if (void 0 === n) return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, r, t)
                    }
                    this._cachedIndex = i,
                    this.intervalChanged_(i, r, n)
                }
                return this.interpolate_(i, r, t, n)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                var e = this.resultBuffer,
                    i = this.sampleValues,
                    n = this.valueSize;
                t *= n;
                for (var r = 0; r !== n; ++r) e[r] = i[t + r];
                return e
            },
            interpolate_: function() {
                throw Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }), Object.assign(Mn.prototype, {
            beforeStart_: Mn.prototype.copySampleValue_,
            afterEnd_: Mn.prototype.copySampleValue_
        }), En.prototype = Object.assign(Object.create(Mn.prototype), {
            constructor: En,
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize;
                for (e = (i - e) / (n - e), i = (t *= a) + a; t !== i; t += 4) o.slerpFlat(r, 0, s, t - a, s, t, e);
                return r
            }
        }), Sn.prototype = Object.assign(Object.create(On.prototype), {
            constructor: Sn,
            ValueTypeName: "quaternion",
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodLinear: function(t) {
                return new En(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), An.prototype = Object.assign(Object.create(On.prototype), {
            constructor: An,
            ValueTypeName: "color"
        }), Pn.prototype = Object.assign(Object.create(On.prototype), {
            constructor: Pn,
            ValueTypeName: "number"
        }), Cn.prototype = Object.assign(Object.create(Mn.prototype), {
            constructor: Cn,
            DefaultSettings_: {
                endingStart: 2400,
                endingEnd: 2400
            },
            intervalChanged_: function(t, e, i) {
                var n = this.parameterPositions,
                    r = t - 2,
                    s = t + 1,
                    a = n[r],
                    o = n[s];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t, a = 2 * e - i;
                        break;
                    case 2402:
                        a = e + n[r = n.length - 2] - n[r + 1];
                        break;
                    default:
                        r = t, a = i
                }
                if (void 0 === o) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        s = t, o = 2 * i - e;
                        break;
                    case 2402:
                        o = i + n[s = 1] - n[0];
                        break;
                    default:
                        s = t - 1, o = e
                }
                t = .5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - a), this._weightNext = t / (o - i), this._offsetPrev = r * n, this._offsetNext = s * n
            },
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = (t *= a) - a,
                    l = this._offsetPrev,
                    h = this._offsetNext,
                    c = this._weightPrev,
                    u = this._weightNext,
                    d = (i - e) / (n - e);
                for (e = -c * (n = (i = d * d) * d) + 2 * c * i - c * d, c = (1 + c) * n + (-1.5 - 2 * c) * i + (-.5 + c) * d + 1, d = (-1 - u) * n + (1.5 + u) * i + .5 * d, u = u * n - u * i, i = 0; i !== a; ++i) r[i] = e * s[l + i] + c * s[o + i] + d * s[t + i] + u * s[h + i];
                return r
            }
        }), Rn.prototype = Object.assign(Object.create(Mn.prototype), {
            constructor: Rn,
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = (t *= a) - a;
                for (i = 1 - (e = (i - e) / (n - e)), n = 0; n !== a; ++n) r[n] = s[o + n] * i + s[t + n] * e;
                return r
            }
        }), Ln.prototype = Object.assign(Object.create(Mn.prototype), {
            constructor: Ln,
            interpolate_: function(t) {
                return this.copySampleValue_(t - 1)
            }
        });
        var Go = {
            arraySlice: function(t, e, i) {
                return Go.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
            },
            convertArray: function(t, e, i) {
                return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(i) {
                for (var t = i.length, e = Array(t), n = 0; n !== t; ++n) e[n] = n;
                return e.sort(function(t, e) {
                    return i[t] - i[e]
                }), e
            },
            sortedArray: function(t, e, i) {
                for (var n = t.length, r = new t.constructor(n), s = 0, a = 0; a !== n; ++s)
                    for (var o = i[s] * e, l = 0; l !== e; ++l) r[a++] = t[o + l];
                return r
            },
            flattenJSON: function(t, e, i, n) {
                for (var r = 1, s = t[0]; void 0 !== s && void 0 === s[n];) s = t[r++];
                if (void 0 !== s) {
                    var a = s[n];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            for (; a = s[n], void 0 !== a && (e.push(s.time), i.push.apply(i, a)), s = t[r++], void 0 !== s;);
                        else if (void 0 !== a.toArray)
                        for (; a = s[n], void 0 !== a && (e.push(s.time), a.toArray(i, i.length)), s = t[r++], void 0 !== s;);
                    else
                        for (; a = s[n], void 0 !== a && (e.push(s.time), i.push(a)), s = t[r++], void 0 !== s;);
                }
            }
        };
        Object.assign(On, {
            parse: function(t) {
                if (void 0 === t.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e, i, n = On._getTrackTypeForValueTypeName(t.type);
                return void 0 === t.times && (e = [], i = [], Go.flattenJSON(t.keys, e, i, "value"), t.times = e, t.values = i), void 0 !== n.parse ? n.parse(t) : new n(t.name, t.times, t.values, t.interpolation)
            },
            toJSON: function(t) {
                var e, i = t.constructor;
                return void 0 !== i.toJSON ? i = i.toJSON(t) : (i = {
                    name: t.name,
                    times: Go.convertArray(t.times, Array),
                    values: Go.convertArray(t.values, Array)
                }, (e = t.getInterpolation()) !== t.DefaultInterpolation && (i.interpolation = e)), i.type = t.ValueTypeName, i
            },
            _getTrackTypeForValueTypeName: function(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Pn;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Dn;
                    case "color":
                        return An;
                    case "quaternion":
                        return Sn;
                    case "bool":
                    case "boolean":
                        return Tn;
                    case "string":
                        return wn
                }
                throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }
        }), Object.assign(On.prototype, {
            constructor: On,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodDiscrete: function(t) {
                return new Ln(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function(t) {
                return new Rn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function(t) {
                return new Cn(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function(t) {
                switch (t) {
                    case 2300:
                        var e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    console.warn("THREE.KeyframeTrack:", e)
                } else this.createInterpolant = e
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(t) {
                if (0 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                return this
            },
            scale: function(t) {
                if (1 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                return this
            },
            trim: function(t, e) {
                for (var i = this.times, n = i.length, r = 0, s = n - 1; r !== n && i[r] < t;) ++r;
                for (; - 1 !== s && i[s] > e;) --s;
                return ++s, 0 === r && s === n || (s <= r && (r = (s = Math.max(s, 1)) - 1), t = this.getValueSize(), this.times = Go.arraySlice(i, r, s), this.values = Go.arraySlice(this.values, r * t, s * t)), this
            },
            validate: function() {
                var t = !0;
                0 != (i = this.getValueSize()) - Math.floor(i) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                var e = this.times,
                    i = this.values,
                    n = e.length;
                0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                for (var r = null, s = 0; s !== n; s++) {
                    var a = e[s];
                    if ("number" == typeof a && isNaN(a)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, a), t = !1;
                        break
                    }
                    if (null !== r && a < r) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, a, r), t = !1;
                        break
                    }
                    r = a
                }
                if (void 0 !== i && Go.isTypedArray(i))
                    for (s = 0, e = i.length; s !== e; ++s)
                        if (n = i[s], isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, n), t = !1;
                            break
                        }
                return t
            },
            optimize: function() {
                for (var t, e = this.times, i = this.values, n = this.getValueSize(), r = 2302 === this.getInterpolation(), s = 1, a = e.length - 1, o = 1; o < a; ++o) {
                    var l = !1;
                    if ((u = e[o]) !== e[o + 1] && (1 !== o || u !== u[0]))
                        if (r) l = !0;
                        else
                            for (var h = (t = o * n) - n, c = t + n, u = 0; u !== n; ++u) {
                                var d = i[t + u];
                                if (d !== i[h + u] || d !== i[c + u]) {
                                    l = !0;
                                    break
                                }
                            }
                    if (l) {
                        if (o !== s)
                            for (e[s] = e[o], t = o * n, l = s * n, u = 0; u !== n; ++u) i[l + u] = i[t + u];
                        ++s
                    }
                }
                if (0 < a) {
                    for (e[s] = e[a], t = a * n, l = s * n, u = 0; u !== n; ++u) i[l + u] = i[t + u];
                    ++s
                }
                return s !== e.length && (this.times = Go.arraySlice(e, 0, s), this.values = Go.arraySlice(i, 0, s * n)), this
            }
        }), Dn.prototype = Object.assign(Object.create(On.prototype), {
            constructor: Dn,
            ValueTypeName: "vector"
        }), Object.assign(kn, {
            parse: function(t) {
                for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, s = i.length; r !== s; ++r) e.push(On.parse(i[r]).scale(n));
                return new kn(t.name, t.duration, e)
            },
            toJSON: function(t) {
                var e = [],
                    i = t.tracks;
                t = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e
                };
                for (var n = 0, r = i.length; n !== r; ++n) e.push(On.toJSON(i[n]));
                return t
            },
            CreateFromMorphTargetSequence: function(t, e, i, n) {
                for (var r = e.length, s = [], a = 0; a < r; a++) {
                    var o = [];
                    (h = []).push((a + r - 1) % r, a, (a + 1) % r), o.push(0, 1, 0);
                    var l = Go.getKeyframeOrder(h),
                        h = Go.sortedArray(h, 1, l),
                        o = Go.sortedArray(o, 1, l);
                    n || 0 !== h[0] || (h.push(r), o.push(o[0])), s.push(new Pn(".morphTargetInfluences[" + e[a].name + "]", h, o).scale(1 / i))
                }
                return new kn(t, -1, s)
            },
            findByName: function(t, e) {
                var i = t;
                for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++)
                    if (i[t].name === e) return i[t];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e, i) {
                for (var n, r = {}, s = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
                    var l = t[a],
                        h = l.name.match(s);
                    h && 1 < h.length && ((h = r[n = h[1]]) || (r[n] = h = []), h.push(l))
                }
                for (n in t = [], r) t.push(kn.CreateFromMorphTargetSequence(n, r[n], e, i));
                return t
            },
            parseAnimation: function(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;

                function i(t, e, i, n, r) {
                    var s, a;
                    0 !== i.length && (s = [], a = [], Go.flattenJSON(i, s, a, n), 0 !== s.length && r.push(new t(e, s, a)))
                }
                var n = [],
                    r = t.name || "default",
                    s = t.length || -1,
                    a = t.fps || 30;
                t = t.hierarchy || [];
                for (var o = 0; o < t.length; o++) {
                    var l = t[o].keys;
                    if (l && 0 !== l.length)
                        if (l[0].morphTargets) {
                            for (var h, s = {}, c = 0; c < l.length; c++)
                                if (l[c].morphTargets)
                                    for (var u = 0; u < l[c].morphTargets.length; u++) s[l[c].morphTargets[u]] = -1;
                            for (h in s) {
                                for (var d = [], p = [], u = 0; u !== l[c].morphTargets.length; ++u) {
                                    var f = l[c];
                                    d.push(f.time), p.push(f.morphTarget === h ? 1 : 0)
                                }
                                n.push(new Pn(".morphTargetInfluence[" + h + "]", d, p))
                            }
                            s = s.length * (a || 1)
                        } else i(Dn, (c = ".bones[" + e[o].name + "]") + ".position", l, "pos", n), i(Sn, c + ".quaternion", l, "rot", n), i(Dn, c + ".scale", l, "scl", n)
                }
                return 0 === n.length ? null : new kn(r, s, n)
            }
        }), Object.assign(kn.prototype, {
            resetDuration: function() {
                for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) var n = this.tracks[e],
                    t = Math.max(t, n.times[n.times.length - 1]);
                this.duration = t
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
        }), Object.assign(In.prototype, {
            load: function(t, e, i, n) {
                var r = this;
                new Hi(r.manager).load(t, function(t) {
                    e(r.parse(JSON.parse(t)))
                }, i, n)
            },
            setTextures: function(t) {
                this.textures = t
            },
            parse: function(t) {
                function e(t) {
                    return void 0 === n[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), n[t]
                }
                var i, n = this.textures,
                    r = new Do[t.type];
                return void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (r.uniforms = t.uniforms), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = e(t.map)), void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)), void 0 !== t.normalScale && (i = t.normalScale, !1 === Array.isArray(i) && (i = [i, i]), r.normalScale = (new X).fromArray(i)), void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)), void 0 !== t.envMap && (r.envMap = e(t.envMap)), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)), r
            }
        }), Object.assign(Nn.prototype, {
            load: function(t, e, i, n) {
                var r = this;
                new Hi(r.manager).load(t, function(t) {
                    e(r.parse(JSON.parse(t)))
                }, i, n)
            },
            parse: function(t) {
                var e = new ut;
                void 0 !== (r = t.data.index) && (r = new qo[r.type](r.array), e.setIndex(new $(r, 1)));
                var i = t.data.attributes;
                for (s in i) {
                    var n = i[s],
                        r = new qo[n.type](n.array);
                    e.addAttribute(s, new $(r, n.itemSize, n.normalized))
                }
                var s = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== s)
                    for (r = 0, i = s.length; r !== i; ++r) n = s[r], e.addGroup(n.start, n.count, n.materialIndex);
                return void 0 !== (t = t.data.boundingSphere) && (s = new St, void 0 !== t.center && s.fromArray(t.center), e.boundingSphere = new V(s, t.radius)), e
            }
        });
        var Vo, jo, Wo, Xo, qo = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        zn.Handlers = {
            handlers: [],
            add: function(t, e) {
                this.handlers.push(t, e)
            },
            get: function(t) {
                for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                    var r = e[i + 1];
                    if (e[i].test(t)) return r
                }
                return null
            }
        }, Object.assign(zn.prototype, {
            crossOrigin: void 0,
            initMaterials: function(t, e, i) {
                for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
                return n
            },
            createMaterial: (Vo = {
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5
            }, jo = new N, Wo = new Xi, Xo = new In, function(t, a, o) {
                function e(t, e, i, n, r) {
                    t = a + t;
                    var s = zn.Handlers.get(t);
                    return t = null !== s ? s.load(t) : (Wo.setCrossOrigin(o), Wo.load(t)), void 0 !== e && (t.repeat.fromArray(e), 1 !== e[0] && (t.wrapS = 1e3), 1 !== e[1] && (t.wrapT = 1e3)), void 0 !== i && t.offset.fromArray(i), void 0 !== n && ("repeat" === n[0] && (t.wrapS = 1e3), "mirror" === n[0] && (t.wrapS = 1002), "repeat" === n[1] && (t.wrapT = 1e3), "mirror" === n[1] && (t.wrapT = 1002)), void 0 !== r && (t.anisotropy = r), e = es.generateUUID(), l[e] = t, e
                }
                var i, l = {},
                    n = {
                        uuid: es.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (i in t) {
                    var r = t[i];
                    switch (i) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            n.name = r;
                            break;
                        case "blending":
                            n.blending = Vo[r];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", i, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            n.color = jo.fromArray(r).getHex();
                            break;
                        case "colorSpecular":
                            n.specular = jo.fromArray(r).getHex();
                            break;
                        case "colorEmissive":
                            n.emissive = jo.fromArray(r).getHex();
                            break;
                        case "specularCoef":
                            n.shininess = r;
                            break;
                        case "shading":
                            "basic" === r.toLowerCase() && (n.type = "MeshBasicMaterial"), "phong" === r.toLowerCase() && (n.type = "MeshPhongMaterial"), "standard" === r.toLowerCase() && (n.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            n.map = e(r, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            n.emissiveMap = e(r, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            n.lightMap = e(r, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            n.aoMap = e(r, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            n.bumpMap = e(r, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            n.bumpScale = r;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            n.normalMap = e(r, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            n.normalScale = [r, r];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            n.specularMap = e(r, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            n.metalnessMap = e(r, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            n.roughnessMap = e(r, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            n.alphaMap = e(r, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            n.side = 1;
                            break;
                        case "doubleSided":
                            n.side = 2;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), n.opacity = r;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            n[i] = r;
                            break;
                        case "vertexColors":
                            !0 === r && (n.vertexColors = 2), "face" === r && (n.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", i, r)
                    }
                }
                return "MeshBasicMaterial" === n.type && delete n.emissive, "MeshPhongMaterial" !== n.type && delete n.specular, n.opacity < 1 && (n.transparent = !0), Xo.setTextures(l), Xo.parse(n)
            })
        });
        var Yo = {
            decodeText: function(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                return decodeURIComponent(escape(e))
            },
            extractUrlBase: function(t) {
                return 1 === (t = t.split("/")).length ? "./" : (t.pop(), t.join("/") + "/")
            }
        };
        Object.assign(Bn.prototype, {
            load: function(i, n, t, e) {
                var r = this,
                    s = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Yo.extractUrlBase(i),
                    a = new Hi(this.manager);
                a.setWithCredentials(this.withCredentials), a.load(i, function(t) {
                    var e = (t = JSON.parse(t)).metadata;
                    if (void 0 !== e && void 0 !== (e = e.type)) {
                        if ("object" === e.toLowerCase()) return void console.error("THREE.JSONLoader: " + i + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === e.toLowerCase()) return void console.error("THREE.JSONLoader: " + i + " should be loaded with THREE.SceneLoader instead.")
                    }
                    t = r.parse(t, s), n(t.geometry, t.materials)
                }, t, e)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            parse: function(t, e) {
                void 0 !== t.data && (t = t.data), t.scale = void 0 !== t.scale ? 1 / t.scale : 1;
                var i, n = new K,
                    r = t,
                    s = r.faces,
                    a = r.vertices,
                    o = r.normals,
                    l = r.colors,
                    h = r.scale,
                    c = 0;
                if (void 0 !== r.uvs) {
                    for (m = 0; m < r.uvs.length; m++) r.uvs[m].length && c++;
                    for (m = 0; m < c; m++) n.faceVertexUvs[m] = []
                }
                for (var u = 0, d = a.length; u < d;)(m = new St).x = a[u++] * h, m.y = a[u++] * h, m.z = a[u++] * h, n.vertices.push(m);
                for (u = 0, d = s.length; u < d;) {
                    var p = 1 & (a = s[u++]),
                        f = 2 & a,
                        m = 8 & a,
                        g = 16 & a,
                        v = 32 & a,
                        h = 64 & a;
                    if (a &= 128, p) {
                        (p = new Q).a = s[u], p.b = s[u + 1], p.c = s[u + 3];
                        var _ = new Q;
                        if (_.a = s[u + 1], _.b = s[u + 2], _.c = s[u + 3], u += 4, f && (f = s[u++], p.materialIndex = f, _.materialIndex = f), f = n.faces.length, m)
                            for (m = 0; m < c; m++) {
                                var y = r.uvs[m];
                                for (n.faceVertexUvs[m][f] = [], n.faceVertexUvs[m][f + 1] = [], i = 0; i < 4; i++) {
                                    var x = s[u++],
                                        b = new X(b = y[2 * x], x = y[2 * x + 1]);
                                    2 !== i && n.faceVertexUvs[m][f].push(b), 0 !== i && n.faceVertexUvs[m][f + 1].push(b)
                                }
                            }
                        if (g && (g = 3 * s[u++], p.normal.set(o[g++], o[g++], o[g]), _.normal.copy(p.normal)), v)
                            for (m = 0; m < 4; m++) g = 3 * s[u++], v = new St(o[g++], o[g++], o[g]), 2 !== m && p.vertexNormals.push(v), 0 !== m && _.vertexNormals.push(v);
                        if (h && (h = l[h = s[u++]], p.color.setHex(h), _.color.setHex(h)), a)
                            for (m = 0; m < 4; m++) h = l[h = s[u++]], 2 !== m && p.vertexColors.push(new N(h)), 0 !== m && _.vertexColors.push(new N(h));
                        n.faces.push(p), n.faces.push(_)
                    } else {
                        if ((p = new Q).a = s[u++], p.b = s[u++], p.c = s[u++], f && (f = s[u++], p.materialIndex = f), f = n.faces.length, m)
                            for (m = 0; m < c; m++)
                                for (y = r.uvs[m], n.faceVertexUvs[m][f] = [], i = 0; i < 3; i++) b = new X(b = y[2 * (x = s[u++])], x = y[2 * x + 1]), n.faceVertexUvs[m][f].push(b);
                        if (g && (g = 3 * s[u++], p.normal.set(o[g++], o[g++], o[g])), v)
                            for (m = 0; m < 3; m++) g = 3 * s[u++], v = new St(o[g++], o[g++], o[g]), p.vertexNormals.push(v);
                        if (h && (h = s[u++], p.color.setHex(l[h])), a)
                            for (m = 0; m < 3; m++) h = s[u++], p.vertexColors.push(new N(l[h]));
                        n.faces.push(p)
                    }
                }
                if (u = void 0 !== (r = t).influencesPerVertex ? r.influencesPerVertex : 2, r.skinWeights)
                    for (d = 0, s = r.skinWeights.length; d < s; d += u) n.skinWeights.push(new At(r.skinWeights[d], 1 < u ? r.skinWeights[d + 1] : 0, 2 < u ? r.skinWeights[d + 2] : 0, 3 < u ? r.skinWeights[d + 3] : 0));
                if (r.skinIndices)
                    for (d = 0, s = r.skinIndices.length; d < s; d += u) n.skinIndices.push(new At(r.skinIndices[d], 1 < u ? r.skinIndices[d + 1] : 0, 2 < u ? r.skinIndices[d + 2] : 0, 3 < u ? r.skinIndices[d + 3] : 0));
                if (n.bones = r.bones, n.bones && 0 < n.bones.length && (n.skinWeights.length !== n.skinIndices.length || n.skinIndices.length !== n.vertices.length) && console.warn("When skinning, number of vertices (" + n.vertices.length + "), skinIndices (" + n.skinIndices.length + "), and skinWeights (" + n.skinWeights.length + ") should match."), s = (d = t).scale, void 0 !== d.morphTargets)
                    for (r = 0, u = d.morphTargets.length; r < u; r++)
                        for (n.morphTargets[r] = {}, n.morphTargets[r].name = d.morphTargets[r].name, n.morphTargets[r].vertices = [], o = n.morphTargets[r].vertices, c = 0, a = (l = d.morphTargets[r].vertices).length; c < a; c += 3)(h = new St).x = l[c] * s, h.y = l[c + 1] * s, h.z = l[c + 2] * s, o.push(h);
                if (void 0 !== d.morphColors && 0 < d.morphColors.length)
                    for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), s = n.faces, d = d.morphColors[0].colors, r = 0, u = s.length; r < u; r++) s[r].color.fromArray(d, 3 * r);
                for (r = [], u = [], void 0 !== (d = t).animation && u.push(d.animation), void 0 !== d.animations && (d.animations.length ? u = u.concat(d.animations) : u.push(d.animations)), d = 0; d < u.length; d++)(s = kn.parseAnimation(u[d], n.bones)) && r.push(s);
                return n.morphTargets && (u = kn.CreateClipsFromMorphTargetSequences(n.morphTargets, 10), r = r.concat(u)), 0 < r.length && (n.animations = r), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length ? {
                    geometry: n
                } : {
                    geometry: n,
                    materials: t = zn.prototype.initMaterials(t.materials, e, this.crossOrigin)
                }
            }
        }), Object.assign(Un.prototype, {
            load: function(i, n, t, r) {
                "" === this.texturePath && (this.texturePath = i.substring(0, i.lastIndexOf("/") + 1));
                var s = this;
                new Hi(s.manager).load(i, function(t) {
                    var e = null;
                    try {
                        e = JSON.parse(t)
                    } catch (t) {
                        return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + i + ".", t.message)
                    }
                    void 0 === (t = e.metadata) || void 0 === t.type || "geometry" === t.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + i + ". Use THREE.JSONLoader instead.") : s.parse(e, n)
                }, t, r)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            setCrossOrigin: function(t) {
                this.crossOrigin = t
            },
            parse: function(t, e) {
                var i = this.parseShape(t.shapes),
                    i = this.parseGeometries(t.geometries, i),
                    n = this.parseImages(t.images, function() {
                        void 0 !== e && e(r)
                    }),
                    n = this.parseTextures(t.textures, n),
                    n = this.parseMaterials(t.materials, n),
                    r = this.parseObject(t.object, i, n);
                return t.animations && (r.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(r), r
            },
            parseShape: function(t) {
                var e = {};
                if (void 0 !== t)
                    for (var i = 0, n = t.length; i < n; i++) {
                        var r = (new un).fromJSON(t[i]);
                        e[r.uuid] = r
                    }
                return e
            },
            parseGeometries: function(t, e) {
                var i = {};
                if (void 0 !== t)
                    for (var n = new Bn, r = new Nn, s = 0, a = t.length; s < a; s++) {
                        var o = t[s];
                        switch (o.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                var l = new Oo[o.type](o.width, o.height, o.widthSegments, o.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                l = new Oo[o.type](o.width, o.height, o.depth, o.widthSegments, o.heightSegments, o.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                l = new Oo[o.type](o.radius, o.segments, o.thetaStart, o.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                l = new Oo[o.type](o.radiusTop, o.radiusBottom, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                l = new Oo[o.type](o.radius, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                l = new Oo[o.type](o.radius, o.widthSegments, o.heightSegments, o.phiStart, o.phiLength, o.thetaStart, o.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                l = new Oo[o.type](o.radius, o.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                l = new Oo[o.type](o.innerRadius, o.outerRadius, o.thetaSegments, o.phiSegments, o.thetaStart, o.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                l = new Oo[o.type](o.radius, o.tube, o.radialSegments, o.tubularSegments, o.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                l = new Oo[o.type](o.radius, o.tube, o.tubularSegments, o.radialSegments, o.p, o.q);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                l = new Oo[o.type](o.points, o.segments, o.phiStart, o.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                l = new Oo[o.type](o.vertices, o.indices, o.radius, o.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                for (l = [], s = 0, a = o.shapes.length; s < a; s++) l.push(e[o.shapes[s]]);
                                l = new Oo[o.type](l, o.curveSegments);
                                break;
                            case "BufferGeometry":
                                l = r.parse(o);
                                break;
                            case "Geometry":
                                l = n.parse(o, this.texturePath).geometry;
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"');
                                continue
                        }
                        l.uuid = o.uuid, void 0 !== o.name && (l.name = o.name), i[o.uuid] = l
                    }
                return i
            },
            parseMaterials: function(t, e) {
                var i = {};
                if (void 0 !== t) {
                    var n = new In;
                    n.setTextures(e), e = 0;
                    for (var r = t.length; e < r; e++) {
                        var s = t[e];
                        if ("MultiMaterial" === s.type) {
                            for (var a = [], o = 0; o < s.materials.length; o++) a.push(n.parse(s.materials[o]));
                            i[s.uuid] = a
                        } else i[s.uuid] = n.parse(s)
                    }
                }
                return i
            },
            parseAnimations: function(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = kn.parse(t[i]);
                    e.push(n)
                }
                return e
            },
            parseImages: function(t, e) {
                var i = this,
                    n = {};
                if (void 0 !== t && 0 < t.length) {
                    var r = new ji(e = new Fi(e));
                    r.setCrossOrigin(this.crossOrigin), e = 0;
                    for (var s = t.length; e < s; e++) {
                        var a = t[e],
                            o = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a.url) ? a.url : i.texturePath + a.url;
                        n[a.uuid] = function(t) {
                            return i.manager.itemStart(t), r.load(t, function() {
                                i.manager.itemEnd(t)
                            }, void 0, function() {
                                i.manager.itemEnd(t), i.manager.itemError(t)
                            })
                        }(o)
                    }
                }
                return n
            },
            parseTextures: function(t, e) {
                function i(t, e) {
                    return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                }
                var n = {};
                if (void 0 !== t)
                    for (var r = 0, s = t.length; r < s; r++) {
                        var a = t[r];
                        void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                        var o = new d(e[a.image]);
                        o.needsUpdate = !0, o.uuid = a.uuid, void 0 !== a.name && (o.name = a.name), void 0 !== a.mapping && (o.mapping = i(a.mapping, Zo)), void 0 !== a.offset && o.offset.fromArray(a.offset), void 0 !== a.repeat && o.repeat.fromArray(a.repeat), void 0 !== a.center && o.center.fromArray(a.center), void 0 !== a.rotation && (o.rotation = a.rotation), void 0 !== a.wrap && (o.wrapS = i(a.wrap[0], Jo), o.wrapT = i(a.wrap[1], Jo)), void 0 !== a.minFilter && (o.minFilter = i(a.minFilter, Qo)), void 0 !== a.magFilter && (o.magFilter = i(a.magFilter, Qo)), void 0 !== a.anisotropy && (o.anisotropy = a.anisotropy), void 0 !== a.flipY && (o.flipY = a.flipY), n[a.uuid] = o
                    }
                return n
            },
            parseObject: function(t, e, s) {
                function i(t) {
                    return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                }

                function n(t) {
                    if (void 0 !== t) {
                        if (Array.isArray(t)) {
                            for (var e = [], i = 0, n = t.length; i < n; i++) {
                                var r = t[i];
                                void 0 === s[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(s[r])
                            }
                            return e
                        }
                        return void 0 === s[t] && console.warn("THREE.ObjectLoader: Undefined material", t), s[t]
                    }
                }
                switch (t.type) {
                    case "Scene":
                        var r = new pe;
                        void 0 !== t.background && Number.isInteger(t.background) && (r.background = new N(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? r.fog = new de(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (r.fog = new ue(t.fog.color, t.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        r = new re(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (r.focus = t.focus), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset), void 0 !== t.view && (r.view = Object.assign({}, t.view));
                        break;
                    case "OrthographicCamera":
                        r = new J(t.left, t.right, t.top, t.bottom, t.near, t.far);
                        break;
                    case "AmbientLight":
                        r = new xn(t.color, t.intensity);
                        break;
                    case "DirectionalLight":
                        r = new yn(t.color, t.intensity);
                        break;
                    case "PointLight":
                        r = new vn(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case "RectAreaLight":
                        r = new bn(t.color, t.intensity, t.width, t.height);
                        break;
                    case "SpotLight":
                        r = new gn(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                        break;
                    case "HemisphereLight":
                        r = new pn(t.color, t.groundColor, t.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        r = i(t.geometry);
                        var a = n(t.material),
                            r = new(r.bones && 0 < r.bones.length ? xe : bt)(r, a);
                        break;
                    case "LOD":
                        r = new ve;
                        break;
                    case "Line":
                        r = new we(i(t.geometry), n(t.material), t.mode);
                        break;
                    case "LineLoop":
                        r = new Me(i(t.geometry), n(t.material));
                        break;
                    case "LineSegments":
                        r = new Te(i(t.geometry), n(t.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        r = new Se(i(t.geometry), n(t.material));
                        break;
                    case "Sprite":
                        r = new ge(n(t.material));
                        break;
                    case "Group":
                        r = new Ae;
                        break;
                    default:
                        r = new Y
                }
                if (r.uuid = t.uuid, void 0 !== t.name && (r.name = t.name), void 0 !== t.matrix ? (r.matrix.fromArray(t.matrix), r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== t.position && r.position.fromArray(t.position), void 0 !== t.rotation && r.rotation.fromArray(t.rotation), void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion), void 0 !== t.scale && r.scale.fromArray(t.scale)), void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.children)
                    for (var a = t.children, o = 0; o < a.length; o++) r.add(this.parseObject(a[o], e, s));
                if ("LOD" === t.type)
                    for (t = t.levels, a = 0; a < t.length; a++) {
                        var o = t[a],
                            l = r.getObjectByProperty("uuid", o.object);
                        void 0 !== l && r.addLevel(l, o.distance)
                    }
                return r
            }
        });
        var Zo = {
                UVMapping: 300,
                CubeReflectionMapping: 301,
                CubeRefractionMapping: 302,
                EquirectangularReflectionMapping: 303,
                EquirectangularRefractionMapping: 304,
                SphericalReflectionMapping: 305,
                CubeUVReflectionMapping: 306,
                CubeUVRefractionMapping: 307
            },
            Jo = {
                RepeatWrapping: 1e3,
                ClampToEdgeWrapping: 1001,
                MirroredRepeatWrapping: 1002
            },
            Qo = {
                NearestFilter: 1003,
                NearestMipMapNearestFilter: 1004,
                NearestMipMapLinearFilter: 1005,
                LinearFilter: 1006,
                LinearMipMapNearestFilter: 1007,
                LinearMipMapLinearFilter: 1008
            };
        Fn.prototype = {
            constructor: Fn,
            setOptions: function(t) {
                return this.options = t, this
            },
            load: function(e, i, t, n) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e);
                var r = this,
                    s = ko.get(e);
                if (void 0 !== s) return r.manager.itemStart(e), setTimeout(function() {
                    i && i(s), r.manager.itemEnd(e)
                }, 0), s;
                fetch(e).then(function(t) {
                    return t.blob()
                }).then(function(t) {
                    return createImageBitmap(t, r.options)
                }).then(function(t) {
                    ko.add(e, t), i && i(t), r.manager.itemEnd(e)
                }).catch(function(t) {
                    n && n(t), r.manager.itemEnd(e), r.manager.itemError(e)
                })
            },
            setCrossOrigin: function() {
                return this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }, Object.assign(Hn.prototype, {
            moveTo: function(t, e) {
                this.currentPath = new cn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
            },
            lineTo: function(t, e) {
                this.currentPath.lineTo(t, e)
            },
            quadraticCurveTo: function(t, e, i, n) {
                this.currentPath.quadraticCurveTo(t, e, i, n)
            },
            bezierCurveTo: function(t, e, i, n, r, s) {
                this.currentPath.bezierCurveTo(t, e, i, n, r, s)
            },
            splineThru: function(t) {
                this.currentPath.splineThru(t)
            },
            toShapes: function(t, e) {
                function i(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i],
                            s = new un;
                        s.curves = r.curves, e.push(s)
                    }
                    return e
                }
                var n = Lo.isClockWise,
                    r = this.subPaths;
                if (0 === r.length) return [];
                if (!0 === e) return i(r);
                if (e = [], 1 === r.length) {
                    var s = r[0],
                        a = new un;
                    return a.curves = s.curves, e.push(a), e
                }
                var o = !n(r[0].getPoints()),
                    o = t ? !o : o,
                    a = [],
                    l = [],
                    h = [],
                    c = 0;
                l[c] = void 0, h[c] = [];
                for (var u = 0, d = r.length; u < d; u++) {
                    var p = (s = r[u]).getPoints(),
                        f = n(p);
                    (f = t ? !f : f) ? (!o && l[c] && c++, l[c] = {
                        s: new un,
                        p: p
                    }, l[c].s.curves = s.curves, o && c++, h[c] = []) : h[c].push({
                        h: s,
                        p: p[0]
                    })
                }
                if (!l[0]) return i(r);
                if (1 < l.length) {
                    for (u = !1, t = [], n = 0, r = l.length; n < r; n++) a[n] = [];
                    for (n = 0, r = l.length; n < r; n++)
                        for (s = h[n], f = 0; f < s.length; f++) {
                            for (o = s[f], c = !0, p = 0; p < l.length; p++) ! function(t, e) {
                                for (var i = e.length, n = !1, r = i - 1, s = 0; s < i; r = s++) {
                                    var a = e[r],
                                        o = e[s],
                                        l = o.x - a.x,
                                        h = o.y - a.y;
                                    if (Math.abs(h) > Number.EPSILON) {
                                        if (h < 0 && (a = e[s], l = -l, o = e[r], h = -h), !(t.y < a.y || t.y > o.y))
                                            if (t.y === a.y) {
                                                if (t.x === a.x) return 1
                                            } else {
                                                if (0 === (r = h * (t.x - a.x) - l * (t.y - a.y))) return 1;
                                                r < 0 || (n = !n)
                                            }
                                    } else if (t.y === a.y && (o.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= o.x)) return 1
                                }
                                return n
                            }(o.p, l[p].p) || (n !== p && t.push({
                                froms: n,
                                tos: p,
                                hole: f
                            }), c ? (c = !1, a[p].push(o)) : u = !0);
                            c && a[n].push(o)
                        }
                    0 < t.length && (u || (h = a))
                }
                for (u = 0, n = l.length; u < n; u++)
                    for (a = l[u].s, e.push(a), r = 0, s = (t = h[u]).length; r < s; r++) a.holes.push(t[r].h);
                return e
            }
        }), Object.assign(Gn.prototype, {
            isFont: !0,
            generateShapes: function(t, e, i) {
                void 0 === e && (e = 100), i = [];
                var n = e;
                e = this.data;
                var r = String(t).split(""),
                    n = n / e.resolution,
                    s = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
                t = [];
                for (var a = 0, o = 0, l = 0; l < r.length; l++) {
                    var h = r[l];
                    if ("\n" === h) a = 0, o -= s;
                    else {
                        var c = n,
                            u = a,
                            d = o;
                        if (h = e.glyphs[h] || e.glyphs["?"]) {
                            var p = new Hn;
                            if (h.o)
                                for (var f = h._cachedOutline || (h._cachedOutline = h.o.split(" ")), m = 0, g = f.length; m < g;) switch (f[m++]) {
                                    case "m":
                                        var v = f[m++] * c + u,
                                            _ = f[m++] * c + d;
                                        p.moveTo(v, _);
                                        break;
                                    case "l":
                                        v = f[m++] * c + u, _ = f[m++] * c + d, p.lineTo(v, _);
                                        break;
                                    case "q":
                                        var y = f[m++] * c + u,
                                            x = f[m++] * c + d,
                                            b = f[m++] * c + u,
                                            w = f[m++] * c + d;
                                        p.quadraticCurveTo(b, w, y, x);
                                        break;
                                    case "b":
                                        y = f[m++] * c + u, x = f[m++] * c + d, b = f[m++] * c + u, w = f[m++] * c + d, v = f[m++] * c + u, _ = f[m++] * c + d, p.bezierCurveTo(b, w, v, _, y, x)
                                }
                            c = {
                                offsetX: h.ha * c,
                                path: p
                            }
                        } else c = void 0;
                        a += c.offsetX, t.push(c.path)
                    }
                }
                for (e = 0, r = t.length; e < r; e++) Array.prototype.push.apply(i, t[e].toShapes());
                return i
            }
        }), Object.assign(Vn.prototype, {
            load: function(t, n, e, i) {
                var r = this,
                    s = new Hi(this.manager);
                s.setPath(this.path), s.load(t, function(e) {
                    try {
                        var i = JSON.parse(e)
                    } catch (t) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2))
                    }
                    e = r.parse(i), n && n(e)
                }, e, i)
            },
            parse: function(t) {
                return new Gn(t)
            },
            setPath: function(t) {
                return this.path = t, this
            }
        });
        var Ko, $o, tl, el, il, nl, rl, sl, al, ol, ll, hl, cl, ul, dl, pl, fl, ml, gl, vl, _l, yl, xl, bl, wl, Tl, Ml, El, Sl, Al, Pl, Cl, Rl, Ll, Ol, Dl, kl, Il, Nl, zl, Bl, Ul, Fl, Hl, Gl, Vl, jl, Wl, Xl, ql, Yl = {
            getContext: function() {
                return void 0 === Ko && (Ko = new(window.AudioContext || window.webkitAudioContext)), Ko
            },
            setContext: function(t) {
                Ko = t
            }
        };

        function Zl(t, e, i, n) {
            if (Fl.set(e, i, n).unproject(Hl), void 0 !== (t = Ul[t]))
                for (e = Bl.getAttribute("position"), i = 0, n = t.length; i < n; i++) e.setXYZ(t[i], Fl.x, Fl.y, Fl.z)
        }
        Object.assign(jn.prototype, {
            load: function(t, e, i, n) {
                var r = new Hi(this.manager);
                r.setResponseType("arraybuffer"), r.load(t, function(t) {
                    Yl.getContext().decodeAudioData(t, function(t) {
                        e(t)
                    })
                }, i, n)
            }
        }), Object.assign(Wn.prototype, {
            update: (ol = new Et, ll = new Et, function(t) {
                var e, i, n, r, s;
                $o === this && tl === t.focus && el === t.fov && il === t.aspect * this.aspect && nl === t.near && rl === t.far && sl === t.zoom && al === this.eyeSep || ($o = this, tl = t.focus, el = t.fov, il = t.aspect * this.aspect, nl = t.near, rl = t.far, sl = t.zoom, e = t.projectionMatrix.clone(), i = (al = this.eyeSep / 2) * nl / tl, n = nl * Math.tan(es.DEG2RAD * el * .5) / sl, ll.elements[12] = -al, ol.elements[12] = al, r = -n * il + i, s = n * il + i, e.elements[0] = 2 * nl / (s - r), e.elements[8] = (s + r) / (s - r), this.cameraL.projectionMatrix.copy(e), r = -n * il - i, s = n * il - i, e.elements[0] = 2 * nl / (s - r), e.elements[8] = (s + r) / (s - r), this.cameraR.projectionMatrix.copy(e)), this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(ll), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(ol)
            })
        }), (Xn.prototype = Object.create(Y.prototype)).constructor = Xn, qn.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: qn,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(t) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(t) {
                this.gain.gain.value = t
            },
            updateMatrixWorld: (hl = new St, cl = new o, ul = new St, dl = new St, function(t) {
                Y.prototype.updateMatrixWorld.call(this, t), t = this.context.listener;
                var e = this.up;
                this.matrixWorld.decompose(hl, cl, ul), dl.set(0, 0, -1).applyQuaternion(cl), t.positionX ? (t.positionX.setValueAtTime(hl.x, this.context.currentTime), t.positionY.setValueAtTime(hl.y, this.context.currentTime), t.positionZ.setValueAtTime(hl.z, this.context.currentTime), t.forwardX.setValueAtTime(dl.x, this.context.currentTime), t.forwardY.setValueAtTime(dl.y, this.context.currentTime), t.forwardZ.setValueAtTime(dl.z, this.context.currentTime), t.upX.setValueAtTime(e.x, this.context.currentTime), t.upY.setValueAtTime(e.y, this.context.currentTime), t.upZ.setValueAtTime(e.z, this.context.currentTime)) : (t.setPosition(hl.x, hl.y, hl.z), t.setOrientation(dl.x, dl.y, dl.z, e.x, e.y, e.z))
            })
        }), Yn.prototype = Object.assign(Object.create(Y.prototype), {
            constructor: Yn,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            },
            setBuffer: function(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function() {
                if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
                else {
                    if (!1 !== this.hasPlaybackControl) {
                        var t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
            },
            pause: function() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            stop: function() {
                if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            connect: function() {
                if (0 < this.filters.length) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (0 < this.filters.length) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(t) {
                return t = t || [], !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(t) {
                return this.setFilters(t ? [t] : [])
            },
            setPlaybackRate: function(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(t) {
                return this.gain.gain.value = t, this
            }
        }), Zn.prototype = Object.assign(Object.create(Yn.prototype), {
            constructor: Zn,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(t) {
                this.panner.refDistance = t
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(t) {
                this.panner.rolloffFactor = t
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(t) {
                this.panner.distanceModel = t
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(t) {
                this.panner.maxDistance = t
            },
            updateMatrixWorld: (pl = new St, function(t) {
                Y.prototype.updateMatrixWorld.call(this, t), pl.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(pl.x, pl.y, pl.z)
            })
        }), Object.assign(Jn.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function() {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }
        }), Object.assign(Qn.prototype, {
            accumulate: function(t, e) {
                var i = this.buffer,
                    n = this.valueSize;
                t = t * n + n;
                var r = this.cumulativeWeight;
                if (0 === r) {
                    for (r = 0; r !== n; ++r) i[t + r] = i[r];
                    r = e
                } else r += e, this._mixBufferRegion(i, t, 0, e / r, n);
                this.cumulativeWeight = r
            },
            apply: function(t) {
                var e = this.valueSize,
                    i = this.buffer;
                t = t * e + e;
                var n = this.cumulativeWeight,
                    r = this.binding;
                this.cumulativeWeight = 0, n < 1 && this._mixBufferRegion(i, t, 3 * e, 1 - n, e);
                for (var n = e, s = e + e; n !== s; ++n)
                    if (i[n] !== i[n + e]) {
                        r.setValue(i, t);
                        break
                    }
            },
            saveOriginalState: function() {
                var t = this.buffer,
                    e = this.valueSize,
                    i = 3 * e;
                this.binding.getValue(t, i);
                for (var n = e; n !== i; ++n) t[n] = t[i + n % e];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                this.binding.setValue(this.buffer, 3 * this.valueSize)
            },
            _select: function(t, e, i, n, r) {
                if (.5 <= n)
                    for (n = 0; n !== r; ++n) t[e + n] = t[i + n]
            },
            _slerp: function(t, e, i, n) {
                o.slerpFlat(t, e, t, e, t, i, n)
            },
            _lerp: function(t, e, i, n, r) {
                for (var s = 1 - n, a = 0; a !== r; ++a) {
                    var o = e + a;
                    t[o] = t[o] * s + t[i + a] * n
                }
            }
        }), Object.assign(Kn.prototype, {
            getValue: function(t, e) {
                this.bind();
                var i = this._bindings[this._targetGroup.nCachedObjects_];
                void 0 !== i && i.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), Object.assign($n, {
            Composite: Kn,
            create: function(t, e, i) {
                return new(t && t.isAnimationObjectGroup ? $n.Composite : $n)(t, e, i)
            },
            sanitizeNodeName: (xl = /[\[\]\.:\/]/g, function(t) {
                return t.replace(/\s/g, "_").replace(xl, "")
            }),
            parseTrackName: (fl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", ml = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), fl = /(WCOD+)?/.source.replace("WCOD", fl), gl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), vl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), _l = new RegExp("^" + ml + fl + gl + vl + "$"), yl = ["material", "materials", "bones"], function(t) {
                var e = _l.exec(t);
                if (!e) throw Error("PropertyBinding: Cannot parse trackName: " + t);
                var i, n = (e = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }).nodeName && e.nodeName.lastIndexOf(".");
                if (void 0 !== n && -1 !== n && (i = e.nodeName.substring(n + 1), -1 !== yl.indexOf(i) && (e.nodeName = e.nodeName.substring(0, n), e.objectName = i)), null === e.propertyName || 0 === e.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return e
            }),
            findNode: function(t, n) {
                if (!n || "" === n || "root" === n || "." === n || -1 === n || n === t.name || n === t.uuid) return t;
                if (t.skeleton) {
                    var e = t.skeleton.getBoneByName(n);
                    if (void 0 !== e) return e
                }
                if (t.children) {
                    var r = function(t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            if (i.name === n || i.uuid === n || (i = r(i.children))) return i
                        }
                        return null
                    };
                    if (t = r(t.children)) return t
                }
                return null
            }
        }), Object.assign($n.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
            }, function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                    e = this.parsedPath,
                    i = e.objectName,
                    n = e.propertyName,
                    r = e.propertyIndex;
                if (t || (this.node = t = $n.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                    if (i) {
                        var s = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                for (t = t.skeleton.bones, i = 0; i < t.length; i++)
                                    if (t[i].name === s) {
                                        s = i;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[i]
                        }
                        if (void 0 !== s) {
                            if (void 0 === t[s]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[s]
                        }
                    }
                    if (void 0 === (s = t[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.", t);
                    else {
                        if (e = this.Versioning.None, void 0 !== t.needsUpdate ? (e = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t), i = this.BindingType.Direct, void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (t.geometry.isBufferGeometry) {
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                        if (t.geometry.morphAttributes.position[i].name === r) {
                                            r = i;
                                            break
                                        }
                                } else {
                                    if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                        if (t.geometry.morphTargets[i].name === r) {
                                            r = i;
                                            break
                                        }
                                }
                            }
                            i = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (i = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                        this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e]
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign($n.prototype, {
            _getValue_unbound: $n.prototype.getValue,
            _setValue_unbound: $n.prototype.setValue
        }), Object.assign(tr.prototype, {
            isAnimationObjectGroup: !0,
            add: function() {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, s = this._parsedPaths, a = this._bindings, o = a.length, l = void 0, h = 0, c = arguments.length; h !== c; ++h) {
                    var u = arguments[h],
                        d = n[p = u.uuid];
                    if (void 0 === d) {
                        d = e++, n[p] = d, t.push(u);
                        for (var p = 0, f = o; p !== f; ++p) a[p].push(new $n(u, r[p], s[p]))
                    } else if (d < i) {
                        var l = t[d],
                            m = --i;
                        for (t[n[(f = t[m]).uuid] = d] = f, t[n[p] = m] = u, p = 0, f = o; p !== f; ++p) {
                            var g = a[p],
                                v = g[d];
                            g[d] = g[m], void 0 === v && (v = new $n(u, r[p], s[p])), g[m] = v
                        }
                    } else t[d] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = i
            },
            remove: function() {
                for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, s = 0, a = arguments.length; s !== a; ++s) {
                    var o = arguments[s],
                        l = o.uuid,
                        h = i[l];
                    if (void 0 !== h && e <= h) {
                        var c = e++;
                        for (t[i[(u = t[c]).uuid] = h] = u, t[i[l] = c] = o, o = 0, l = r; o !== l; ++o) {
                            var u, d = (u = n[o])[h];
                            u[h] = u[c], u[c] = d
                        }
                    }
                }
                this.nCachedObjects_ = e
            },
            uncache: function() {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, s = r.length, a = 0, o = arguments.length; a !== o; ++a) {
                    var l = n[h = arguments[a].uuid];
                    if (void 0 !== l)
                        if (delete n[h], l < i) {
                            var h, c = --i,
                                u = t[c],
                                d = t[h = --e];
                            t[n[u.uuid] = l] = u, t[n[d.uuid] = c] = d, t.pop();
                            for (var u = 0, p = s; u !== p; ++u) {
                                var f = (d = r[u])[h];
                                d[l] = d[c], d[c] = f, d.pop()
                            }
                        } else
                            for (t[n[(d = t[h = --e]).uuid] = l] = d, t.pop(), u = 0, p = s; u !== p; ++u)(d = r[u])[l] = d[h], d.pop()
                }
                this.nCachedObjects_ = i
            },
            subscribe_: function(t, e) {
                var i = this._bindingsIndicesByPath,
                    n = i[t],
                    r = this._bindings;
                if (void 0 !== n) return r[n];
                var s = this._paths,
                    a = this._parsedPaths,
                    o = this._objects,
                    l = this.nCachedObjects_,
                    h = Array(o.length),
                    n = r.length;
                for (i[t] = n, s.push(t), a.push(e), r.push(h), i = l, n = o.length; i !== n; ++i) h[i] = new $n(o[i], t, e);
                return h
            },
            unsubscribe_: function(t) {
                var e, i, n, r, s, a = this._bindingsIndicesByPath,
                    o = a[t];
                void 0 !== o && (e = this._paths, i = this._parsedPaths, s = (n = this._bindings)[r = n.length - 1], n[a[t[r]] = o] = s, n.pop(), i[o] = i[r], i.pop(), e[o] = e[r], e.pop())
            }
        }), Object.assign(er.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(t) {
                return this._startTime = t, this
            },
            setLoop: function(t, e) {
                return this.loop = t, this.repetitions = e, this
            },
            setEffectiveWeight: function(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function(t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function(t, e, i) {
                var n, r;
                return t.fadeOut(e), this.fadeIn(e), i && (r = (i = this._clip.duration) / (n = t._clip.duration), t.warp(1, n / i, e), this.warp(r, 1, e)), this
            },
            crossFadeTo: function(t, e, i) {
                return t.crossFadeFrom(this, e, i)
            },
            stopFading: function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            setEffectiveTimeScale: function(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            },
            syncWith: function(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            },
            halt: function(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            },
            warp: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    s = this._timeScaleInterpolant,
                    a = this.timeScale;
                return null === s && (this._timeScaleInterpolant = s = n._lendControlInterpolant()), n = s.parameterPositions, s = s.sampleValues, n[0] = r, n[1] = r + i, s[0] = t / a, s[1] = e / a, this
            },
            stopWarping: function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(t, e, i, n) {
                if (this.enabled) {
                    if (null !== (r = this._startTime)) {
                        if ((e = (t - r) * i) < 0 || 0 === i) return;
                        this._startTime = null, e *= i
                    }
                    if (e *= this._updateTimeScale(t), i = this._updateTime(e), 0 < (t = this._updateWeight(t))) {
                        e = this._interpolants;
                        for (var r = this._propertyBindings, s = 0, a = e.length; s !== a; ++s) e[s].evaluate(i), r[s].accumulate(n, t)
                    }
                } else this._updateWeight(t)
            },
            _updateWeight: function(t) {
                var e, i, n = 0;
                return this.enabled && (n = this.weight, null !== (e = this._weightInterpolant) && (n *= i = e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)))), this._effectiveWeight = n
            },
            _updateTimeScale: function(t) {
                var e, i = 0;
                return this.paused || (i = this.timeScale, null !== (e = this._timeScaleInterpolant) && (i *= e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopWarping(), 0 === i ? this.paused = !0 : this.timeScale = i))), this._effectiveTimeScale = i
            },
            _updateTime: function(t) {
                var e = this.time + t;
                if (0 === t) return e;
                var i = this._clip.duration,
                    n = this.loop,
                    r = this._loopCount;
                if (2200 === n) t: {
                    if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), i <= e) e = i;
                    else {
                        if (!(e < 0)) break t;
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
                else {
                    var s, a, n = 2202 === n;
                    if (-1 === r && (0 <= t ? (r = 0, this._setEndings(!0, 0 === this.repetitions, n)) : this._setEndings(0 === this.repetitions, !0, n)), (i <= e || e < 0) && (e -= i * (s = Math.floor(e / i)), r += Math.abs(s), (a = this.repetitions - r) < 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 < t ? 1 : -1
                        })) : (0 == a ? (t = t < 0, this._setEndings(t, !t, n)) : this._setEndings(!1, !1, n), this._loopCount = r, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: s
                        }))), n && 1 == (1 & r)) return i - (this.time = e)
                }
                return this.time = e
            },
            _setEndings: function(t, e, i) {
                var n = this._interpolantSettings;
                i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            },
            _scheduleFading: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    s = this._weightInterpolant;
                return null === s && (this._weightInterpolant = s = n._lendControlInterpolant()), n = s.parameterPositions, s = s.sampleValues, n[0] = r, s[0] = e, n[1] = r + t, s[1] = i, this
            }
        }), ir.prototype = Object.assign(Object.create(e.prototype), {
            constructor: ir,
            _bindAction: function(t, e) {
                var i = t._localRoot || this._root,
                    n = t._clip.tracks,
                    r = n.length,
                    s = t._propertyBindings;
                t = t._interpolants;
                var a = i.uuid,
                    o = this._bindingsByRootAndName,
                    l = o[a];
                for (void 0 === l && (l = {}, o[a] = l), o = 0; o !== r; ++o) {
                    var h = n[o],
                        c = h.name,
                        u = l[c];
                    if (void 0 === u) {
                        if (void 0 !== (u = s[o])) {
                            null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, c));
                            continue
                        }++(u = new Qn($n.create(i, c, e && e._propertyBindings[o].binding.parsedPath), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(u, a, c)
                    }
                    s[o] = u, t[o].resultBuffer = u.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    var e, i, n;
                    for (null === t._cacheIndex && (e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i], this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)), i = 0, n = (e = t._propertyBindings).length; i !== n; ++i) {
                        var r = e[i];
                        0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                return null !== (t = t._cacheIndex) && t < this._nActiveActions
            },
            _addInactiveAction: function(t, e, i) {
                var n = this._actions,
                    r = this._actionsByClip,
                    s = r[e];
                void 0 === s ? (s = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, r[e] = s) : (e = s.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t
            },
            _removeInactiveAction: function(t) {
                var e = (n = this._actions)[n.length - 1],
                    i = t._cacheIndex;
                n[e._cacheIndex = i] = e, n.pop(), t._cacheIndex = null;
                var n = t._clip.uuid,
                    r = (i = (e = this._actionsByClip)[n]).knownActions,
                    s = r[r.length - 1],
                    a = t._byClipCacheIndex;
                r[s._byClipCacheIndex = a] = s, r.pop(), t._byClipCacheIndex = null, delete i.actionByRoot[(t._localRoot || this._root).uuid], 0 === r.length && delete e[n], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                for (var e = 0, i = (t = t._propertyBindings).length; e !== i; ++e) {
                    var n = t[e];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            },
            _lendAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = this._nActiveActions++,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _takeBackAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = --this._nActiveActions,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _addInactiveBinding: function(t, e, i) {
                var n = this._bindingsByRootAndName,
                    r = n[e],
                    s = this._bindings;
                void 0 === r && (r = {}, n[e] = r), (r[i] = t)._cacheIndex = s.length, s.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings,
                    i = (n = t.binding).rootNode.uuid,
                    n = n.path,
                    r = this._bindingsByRootAndName,
                    s = r[i],
                    a = e[e.length - 1];
                t = t._cacheIndex, e[a._cacheIndex = t] = a, e.pop(), delete s[n];
                t: {
                    for (var o in s) break t;delete r[i]
                }
            },
            _lendBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = this._nActiveBindings++,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _takeBackBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = --this._nActiveBindings,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    i = t[e];
                return void 0 === i && (t[(i = new Rn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e] = i), i
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants,
                    i = t.__cacheIndex,
                    n = --this._nActiveControlInterpolants,
                    r = e[n];
                e[t.__cacheIndex = n] = t, e[r.__cacheIndex = i] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid;
                t = null !== (i = "string" == typeof t ? kn.findByName(i, t) : t) ? i.uuid : t;
                var r = this._actionsByClip[t],
                    s = null;
                if (void 0 !== r) {
                    if (void 0 !== (s = r.actionByRoot[n])) return s;
                    s = r.knownActions[0], null === i && (i = s._clip)
                }
                return null === i ? null : (e = new er(this, i, e), this._bindAction(e, s), this._addInactiveAction(e, t, n), e)
            },
            existingAction: function(t, e) {
                var i = e || this._root;
                return e = i.uuid, i = "string" == typeof t ? kn.findByName(i, t) : t, void 0 !== (t = this._actionsByClip[i ? i.uuid : t]) && t.actionByRoot[e] || null
            },
            stopAllAction: function() {
                for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r) t[r].reset();
                for (r = 0; r !== n; ++r) i[r].useCount = 0;
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), s = this._accuIndex ^= 1, a = 0; a !== i; ++a) e[a]._update(n, t, r, s);
                for (t = this._bindings, e = this._nActiveBindings, a = 0; a !== e; ++a) t[a].apply(s);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions;
                t = t.uuid;
                var i = this._actionsByClip;
                if (void 0 !== (n = i[t])) {
                    for (var n, r = 0, s = (n = n.knownActions).length; r !== s; ++r) {
                        var a = n[r];
                        this._deactivateAction(a);
                        var o = a._cacheIndex,
                            l = e[e.length - 1];
                        a._cacheIndex = null, a._byClipCacheIndex = null, e[l._cacheIndex = o] = l, e.pop(), this._removeInactiveBindingsForAction(a)
                    }
                    delete i[t]
                }
            },
            uncacheRoot: function(t) {
                t = t.uuid;
                var e = this._actionsByClip;
                for (n in e) {
                    var i = e[n].actionByRoot[t];
                    void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
                var n = this._bindingsByRootAndName[t];
                if (void 0 !== n)
                    for (var r in n) t = n[r], t.restoreOriginalState(), this._removeInactiveBinding(t)
            },
            uncacheAction: function(t, e) {
                null !== (t = this.existingAction(t, e)) && (this._deactivateAction(t), this._removeInactiveAction(t))
            }
        }), nr.prototype.clone = function() {
            return new nr(void 0 === this.value.clone ? this.value : this.value.clone())
        }, rr.prototype = Object.assign(Object.create(ut.prototype), {
            constructor: rr,
            isInstancedBufferGeometry: !0,
            copy: function(t) {
                return ut.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), Object.defineProperties(sr.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            }
        }), Object.assign(sr.prototype, {
            isInterleavedBufferAttribute: !0,
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
            }
        }), Object.defineProperty(ar.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(ar.prototype, {
            isInterleavedBuffer: !0,
            setArray: function(t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
            },
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            }
        }), or.prototype = Object.assign(Object.create(ar.prototype), {
            constructor: or,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return ar.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), lr.prototype = Object.assign(Object.create($.prototype), {
            constructor: lr,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return $.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Object.assign(hr.prototype, {
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(t, e) {
                var i = [];
                return ur(t, this, i, e), i.sort(cr), i
            },
            intersectObjects: function(t, e) {
                var i = [];
                if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                for (var n = 0, r = t.length; n < r; n++) ur(t[n], this, i, e);
                return i.sort(cr), i
            }
        }), Object.assign(dr.prototype, {
            start: function() {
                this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.autoStart = this.running = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var t, e = 0;
                return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (e = ((t = ("undefined" == typeof performance ? Date : performance).now()) - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e), e)
            }
        }), Object.assign(pr.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(t) {
                return this.radius = t.length(), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(es.clamp(t.y / this.radius, -1, 1))), this
            }
        }), Object.assign(fr.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            },
            setFromVector3: function(t) {
                return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
            }
        }), ((mr.prototype = Object.create(Y.prototype)).constructor = mr).prototype.isImmediateRenderObject = !0, ((gr.prototype = Object.create(Te.prototype)).constructor = gr).prototype.update = (bl = new St, wl = new St, Tl = new g, function() {
            var t, e = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), Tl.getNormalMatrix(this.object.matrixWorld);
            var i = this.object.matrixWorld,
                n = this.geometry.attributes.position;
            if ((t = this.object.geometry) && t.isGeometry)
                for (var r = t.vertices, s = t.faces, a = t = 0, o = s.length; a < o; a++)
                    for (var l = s[a], h = 0, c = l.vertexNormals.length; h < c; h++) {
                        var u = l.vertexNormals[h];
                        bl.copy(r[l[e[h]]]).applyMatrix4(i), wl.copy(u).applyMatrix3(Tl).normalize().multiplyScalar(this.size).add(bl), n.setXYZ(t, bl.x, bl.y, bl.z), t += 1, n.setXYZ(t, wl.x, wl.y, wl.z), t += 1
                    } else if (t && t.isBufferGeometry)
                        for (e = t.attributes.position, r = t.attributes.normal, h = t = 0, c = e.count; h < c; h++) bl.set(e.getX(h), e.getY(h), e.getZ(h)).applyMatrix4(i), wl.set(r.getX(h), r.getY(h), r.getZ(h)), wl.applyMatrix3(Tl).normalize().multiplyScalar(this.size).add(bl), n.setXYZ(t, bl.x, bl.y, bl.z), t += 1, n.setXYZ(t, wl.x, wl.y, wl.z), t += 1;
            n.needsUpdate = !0
        }), ((vr.prototype = Object.create(Y.prototype)).constructor = vr).prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, vr.prototype.update = (Ml = new St, El = new St, function() {
            this.light.updateMatrixWorld();
            var t = this.light.distance || 1e3,
                e = t * Math.tan(this.light.angle);
            this.cone.scale.set(e, e, t), Ml.setFromMatrixPosition(this.light.matrixWorld), El.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(El.sub(Ml)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }), ((_r.prototype = Object.create(Te.prototype)).constructor = _r).prototype.updateMatrixWorld = (Sl = new St, Al = new Et, Pl = new Et, function(t) {
            var e = this.bones,
                i = this.geometry,
                n = i.getAttribute("position");
            Pl.getInverse(this.root.matrixWorld);
            for (var r = 0, s = 0; r < e.length; r++) {
                var a = e[r];
                a.parent && a.parent.isBone && (Al.multiplyMatrices(Pl, a.matrixWorld), Sl.setFromMatrixPosition(Al), n.setXYZ(s, Sl.x, Sl.y, Sl.z), Al.multiplyMatrices(Pl, a.parent.matrixWorld), Sl.setFromMatrixPosition(Al), n.setXYZ(s + 1, Sl.x, Sl.y, Sl.z), s += 2)
            }
            i.getAttribute("position").needsUpdate = !0, Y.prototype.updateMatrixWorld.call(this, t)
        }), ((yr.prototype = Object.create(bt.prototype)).constructor = yr).prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, yr.prototype.update = function() {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }, ((xr.prototype = Object.create(Y.prototype)).constructor = xr).prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, xr.prototype.update = function() {
            var t = .5 * this.light.width,
                e = .5 * this.light.height,
                i = this.line.geometry.attributes.position,
                n = i.array;
            n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
        }, ((br.prototype = Object.create(Y.prototype)).constructor = br).prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, br.prototype.update = (Cl = new St, Rl = new N, Ll = new N, function() {
            var t = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var e = t.geometry.getAttribute("color");
                Rl.copy(this.light.color), Ll.copy(this.light.groundColor);
                for (var i = 0, n = e.count; i < n; i++) {
                    var r = i < n / 2 ? Rl : Ll;
                    e.setXYZ(i, r.r, r.g, r.b)
                }
                e.needsUpdate = !0
            }
            t.lookAt(Cl.setFromMatrixPosition(this.light.matrixWorld).negate())
        }), (wr.prototype = Object.create(Te.prototype)).constructor = wr, (Tr.prototype = Object.create(Te.prototype)).constructor = Tr, ((Mr.prototype = Object.create(Te.prototype)).constructor = Mr).prototype.update = (Ol = new St, Dl = new St, kl = new g, function() {
            this.object.updateMatrixWorld(!0), kl.getNormalMatrix(this.object.matrixWorld);
            for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, i = this.object.geometry, n = i.vertices, r = 0, s = 0, a = (i = i.faces).length; s < a; s++) {
                var o = i[s],
                    l = o.normal;
                Ol.copy(n[o.a]).add(n[o.b]).add(n[o.c]).divideScalar(3).applyMatrix4(t), Dl.copy(l).applyMatrix3(kl).normalize().multiplyScalar(this.size).add(Ol), e.setXYZ(r, Ol.x, Ol.y, Ol.z), r += 1, e.setXYZ(r, Dl.x, Dl.y, Dl.z), r += 1
            }
            e.needsUpdate = !0
        }), ((Er.prototype = Object.create(Y.prototype)).constructor = Er).prototype.dispose = function() {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, Er.prototype.update = (Il = new St, Nl = new St, zl = new St, function() {
            Il.setFromMatrixPosition(this.light.matrixWorld), Nl.setFromMatrixPosition(this.light.target.matrixWorld), zl.subVectors(Nl, Il), this.lightPlane.lookAt(zl), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(zl), this.targetLine.scale.z = zl.length()
        }), ((Sr.prototype = Object.create(Te.prototype)).constructor = Sr).prototype.update = (Fl = new St, Hl = new Z, function() {
            Bl = this.geometry, Ul = this.pointMap, Hl.projectionMatrix.copy(this.camera.projectionMatrix), Zl("c", 0, 0, -1), Zl("t", 0, 0, 1), Zl("n1", -1, -1, -1), Zl("n2", 1, -1, -1), Zl("n3", -1, 1, -1), Zl("n4", 1, 1, -1), Zl("f1", -1, -1, 1), Zl("f2", 1, -1, 1), Zl("f3", -1, 1, 1), Zl("f4", 1, 1, 1), Zl("u1", .7, 1.1, -1), Zl("u2", -.7, 1.1, -1), Zl("u3", 0, 2, -1), Zl("cf1", -1, 0, 1), Zl("cf2", 1, 0, 1), Zl("cf3", 0, -1, 1), Zl("cf4", 0, 1, 1), Zl("cn1", -1, 0, -1), Zl("cn2", 1, 0, -1), Zl("cn3", 0, -1, -1), Zl("cn4", 0, 1, -1), Bl.getAttribute("position").needsUpdate = !0
        }), ((Ar.prototype = Object.create(Te.prototype)).constructor = Ar).prototype.update = (Gl = new G, function(t) {
            var e, i, n;
            void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Gl.setFromObject(this.object), Gl.isEmpty() || (t = Gl.min, e = Gl.max, (n = (i = this.geometry.attributes.position).array)[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = t.x, n[4] = e.y, n[5] = e.z, n[6] = t.x, n[7] = t.y, n[8] = e.z, n[9] = e.x, n[10] = t.y, n[11] = e.z, n[12] = e.x, n[13] = e.y, n[14] = t.z, n[15] = t.x, n[16] = e.y, n[17] = t.z, n[18] = t.x, n[19] = t.y, n[20] = t.z, n[21] = e.x, n[22] = t.y, n[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere())
        }), Ar.prototype.setFromObject = function(t) {
            return this.object = t, this.update(), this
        }, ((Pr.prototype = Object.create(Te.prototype)).constructor = Pr).prototype.updateMatrixWorld = function(t) {
            var e = this.box;
            e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Y.prototype.updateMatrixWorld.call(this, t))
        }, ((Cr.prototype = Object.create(we.prototype)).constructor = Cr).prototype.updateMatrixWorld = function(t) {
            var e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.lookAt(this.plane.normal), Y.prototype.updateMatrixWorld.call(this, t)
        }, ((Rr.prototype = Object.create(Y.prototype)).constructor = Rr).prototype.setDirection = (Xl = new St, function(t) {
            .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Xl.set(t.z, 0, -t.x).normalize(), Wl = Math.acos(t.y), this.quaternion.setFromAxisAngle(Xl, Wl))
        }), Rr.prototype.setLength = function(t, e, i) {
            void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
        }, Rr.prototype.setColor = function(t) {
            this.line.material.color.copy(t), this.cone.material.color.copy(t)
        }, (Lr.prototype = Object.create(Te.prototype)).constructor = Lr, qi.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(qi.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t
        }, Object.assign(hn.prototype, {
            createPointsGeometry: function(t) {
                return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getPoints(t), this.createGeometry(t)
            },
            createSpacedPointsGeometry: function(t) {
                return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getSpacedPoints(t), this.createGeometry(t)
            },
            createGeometry: function(t) {
                console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                for (var e = new K, i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.vertices.push(new St(r.x, r.y, r.z || 0))
                }
                return e
            }
        }), Object.assign(cn.prototype, {
            fromPoints: function(t) {
                console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
            }
        }), Or.prototype = Object.create(Qi.prototype), Dr.prototype = Object.create(Qi.prototype), kr.prototype = Object.create(Qi.prototype), Object.assign(kr.prototype, {
            initFromArray: function() {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            },
            getControlPointsArray: function() {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            },
            reparametrizeByArcLength: function() {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), wr.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, _r.prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, Object.assign(zn.prototype, {
            extractUrlBase: function(t) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Yo.extractUrlBase(t)
            }
        }), Object.assign(z.prototype, {
            center: function(t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            size: function(t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), Object.assign(G.prototype, {
            center: function(t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            },
            size: function(t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), yt.prototype.center = function(t) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, Object.assign(es, {
            random16: function() {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
            },
            nearestPowerOfTwo: function(t) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), es.floorPowerOfTwo(t)
            },
            nextPowerOfTwo: function(t) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), es.ceilPowerOfTwo(t)
            }
        }), Object.assign(g.prototype, {
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            },
            multiplyVector3Array: function() {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            },
            applyToBuffer: function(t) {
                return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function() {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), Object.assign(Et.prototype, {
            extractPosition: function(t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            },
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            getPosition: function() {
                return void 0 === ql && (ql = new St), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), ql.setFromMatrixColumn(this, 3)
            },
            setRotationFromQuaternion: function(t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            },
            multiplyToArray: function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector4: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector3Array: function() {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            },
            rotateAxis: function(t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            },
            crossVector: function(t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            translate: function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            },
            applyToBuffer: function(t) {
                return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function() {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            },
            makeFrustum: function(t, e, i, n, r, s) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, s)
            }
        }), j.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, o.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, Object.assign(_t.prototype, {
            isIntersectionBox: function(t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionPlane: function(t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }
        }), Object.assign(un.prototype, {
            extractAllPoints: function(t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
            },
            extrude: function(t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ui(this, t)
            },
            makeGeometry: function(t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new bi(this, t)
            }
        }), Object.assign(X.prototype, {
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(St.prototype, {
            setEulerFromRotationMatrix: function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            },
            getScaleFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            },
            getColumnFromMatrix: function(t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            },
            applyProjection: function(t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            },
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(At.prototype, {
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), K.prototype.computeTangents = function() {
            console.warn("THREE.Geometry: .computeTangents() has been removed.")
        }, Object.assign(Y.prototype, {
            getChildByName: function(t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            },
            renderDepth: function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            },
            translate: function(t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }
        }), Object.defineProperties(Y.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.defineProperties(ve.prototype, {
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), Object.defineProperty(_e.prototype, "useVertexTexture", {
            get: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            },
            set: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }), Object.defineProperty(qi.prototype, "__arcLengthDivisions", {
            get: function() {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            },
            set: function(t) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
            }
        }), re.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(dn.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties($.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            }
        }), Object.assign(ut.prototype, {
            addIndex: function(t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            },
            addDrawCall: function(t, e, i) {
                void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            },
            clearDrawCalls: function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            },
            computeTangents: function() {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            },
            computeOffsets: function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }), Object.defineProperties(ut.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.defineProperties(nr.prototype, {
            dynamic: {
                set: function() {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            },
            onUpdate: {
                value: function() {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), Object.defineProperties(B.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new N
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                }
            }
        }), Object.defineProperties(Ii.prototype, {
            metal: {
                get: function() {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                },
                set: function() {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties(vt.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), Object.assign(ce.prototype, {
            getCurrentRenderTarget: function() {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            },
            getMaxAnisotropy: function() {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function() {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            },
            resetGLState: function() {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            },
            supportsFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function(t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            },
            initMaterial: function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            },
            addPrePlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            },
            addPostPlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            },
            updateShadowMap: function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }
        }), Object.defineProperties(ce.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(Dt.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(S.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), Object.assign(ae.prototype, {
            getStandingMatrix: function() {
                console.warn("THREE.WebVRManager: .getStandingMatrix() has been removed.")
            }
        }), Object.defineProperties(ae.prototype, {
            standing: {
                set: function() {
                    console.warn("THREE.WebVRManager: .standing has been removed.")
                }
            }
        }), Yn.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            var e = this;
            return (new jn).load(t, function(t) {
                e.setBuffer(t)
            }), this
        }, Jn.prototype.getData = function() {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, Xn.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
        }, t.WebGLRenderTargetCube = n, t.WebGLRenderTarget = S, t.WebGLRenderer = ce, t.ShaderLib = ys, t.UniformsLib = gs, t.UniformsUtils = vs, t.ShaderChunk = _s, t.FogExp2 = ue, t.Fog = de, t.Scene = pe, t.LensFlare = fe, t.Sprite = ge, t.LOD = ve, t.SkinnedMesh = xe, t.Skeleton = _e, t.Bone = ye, t.Mesh = bt, t.LineSegments = Te, t.LineLoop = Me, t.Line = we, t.Points = Se, t.Group = Ae, t.VideoTexture = Pe, t.DataTexture = Pt, t.CompressedTexture = Ce, t.CubeTexture = l, t.CanvasTexture = H, t.DepthTexture = Re, t.Texture = d, t.CompressedTextureLoader = Gi, t.DataTextureLoader = Vi, t.CubeTextureLoader = Wi, t.TextureLoader = Xi, t.ObjectLoader = Un, t.MaterialLoader = In, t.BufferGeometryLoader = Nn, t.DefaultLoadingManager = Io, t.LoadingManager = Fi, t.JSONLoader = Bn, t.ImageLoader = ji, t.ImageBitmapLoader = Fn, t.FontLoader = Vn, t.FileLoader = Hi, t.Loader = zn, t.LoaderUtils = Yo, t.Cache = ko, t.AudioLoader = jn, t.SpotLightShadow = mn, t.SpotLight = gn, t.PointLight = vn, t.RectAreaLight = bn, t.HemisphereLight = pn, t.DirectionalLightShadow = _n, t.DirectionalLight = yn, t.AmbientLight = xn, t.LightShadow = fn, t.Light = dn, t.StereoCamera = Wn, t.PerspectiveCamera = re, t.OrthographicCamera = J, t.CubeCamera = Xn, t.ArrayCamera = se, t.Camera = Z, t.AudioListener = qn, t.PositionalAudio = Zn, t.AudioContext = Yl, t.AudioAnalyser = Jn, t.Audio = Yn, t.VectorKeyframeTrack = Dn, t.StringKeyframeTrack = wn, t.QuaternionKeyframeTrack = Sn, t.NumberKeyframeTrack = Pn, t.ColorKeyframeTrack = An, t.BooleanKeyframeTrack = Tn, t.PropertyMixer = Qn, t.PropertyBinding = $n, t.KeyframeTrack = On, t.AnimationUtils = Go, t.AnimationObjectGroup = tr, t.AnimationMixer = ir, t.AnimationClip = kn, t.Uniform = nr, t.InstancedBufferGeometry = rr, t.BufferGeometry = ut, t.Geometry = K, t.InterleavedBufferAttribute = sr, t.InstancedInterleavedBuffer = or, t.InterleavedBuffer = ar, t.InstancedBufferAttribute = lr, t.Face3 = Q, t.Object3D = Y, t.Raycaster = hr, t.Layers = q, t.EventDispatcher = e, t.Clock = dr, t.QuaternionLinearInterpolant = En, t.LinearInterpolant = Rn, t.DiscreteInterpolant = Ln, t.CubicInterpolant = Cn, t.Interpolant = Mn, t.Triangle = xt, t.Math = es, t.Spherical = pr, t.Cylindrical = fr, t.Plane = j, t.Frustum = Ot, t.Sphere = V, t.Ray = _t, t.Matrix4 = Et, t.Matrix3 = g, t.Box3 = G, t.Box2 = z, t.Line3 = yt, t.Euler = W, t.Vector4 = At, t.Vector3 = St, t.Vector2 = X, t.Quaternion = o, t.Color = N, t.ImmediateRenderObject = mr, t.VertexNormalsHelper = gr, t.SpotLightHelper = vr, t.SkeletonHelper = _r, t.PointLightHelper = yr, t.RectAreaLightHelper = xr, t.HemisphereLightHelper = br, t.GridHelper = wr, t.PolarGridHelper = Tr, t.FaceNormalsHelper = Mr, t.DirectionalLightHelper = Er, t.CameraHelper = Sr, t.BoxHelper = Ar, t.Box3Helper = Pr, t.PlaneHelper = Cr, t.ArrowHelper = Rr, t.AxesHelper = Lr, t.Shape = un, t.Path = cn, t.ShapePath = Hn, t.Font = Gn, t.CurvePath = hn, t.Curve = qi, t.ShapeUtils = Lo, t.WebGLUtils = he, t.WireframeGeometry = Le, t.ParametricGeometry = Oe, t.ParametricBufferGeometry = De, t.TetrahedronGeometry = Ne, t.TetrahedronBufferGeometry = ze, t.OctahedronGeometry = Be, t.OctahedronBufferGeometry = Ue, t.IcosahedronGeometry = Fe, t.IcosahedronBufferGeometry = He, t.DodecahedronGeometry = Ge, t.DodecahedronBufferGeometry = Ve, t.PolyhedronGeometry = ke, t.PolyhedronBufferGeometry = Ie, t.TubeGeometry = je, t.TubeBufferGeometry = We, t.TorusKnotGeometry = Xe, t.TorusKnotBufferGeometry = qe, t.TorusGeometry = Ye, t.TorusBufferGeometry = Ze, t.TextGeometry = pi, t.TextBufferGeometry = fi, t.SphereGeometry = mi, t.SphereBufferGeometry = gi, t.RingGeometry = vi, t.RingBufferGeometry = _i, t.PlaneGeometry = ft, t.PlaneBufferGeometry = mt, t.LatheGeometry = yi, t.LatheBufferGeometry = xi, t.ShapeGeometry = bi, t.ShapeBufferGeometry = wi, t.ExtrudeGeometry = ui, t.ExtrudeBufferGeometry = di, t.EdgesGeometry = Mi, t.ConeGeometry = Ai, t.ConeBufferGeometry = Pi, t.CylinderGeometry = Ei, t.CylinderBufferGeometry = Si, t.CircleGeometry = Ci, t.CircleBufferGeometry = Ri, t.BoxGeometry = dt, t.BoxBufferGeometry = pt, t.ShadowMaterial = Li, t.SpriteMaterial = me, t.RawShaderMaterial = Oi, t.ShaderMaterial = vt, t.PointsMaterial = Ee, t.MeshPhysicalMaterial = ki, t.MeshStandardMaterial = Di, t.MeshPhongMaterial = Ii, t.MeshToonMaterial = Ni, t.MeshNormalMaterial = zi, t.MeshLambertMaterial = Bi, t.MeshDepthMaterial = U, t.MeshDistanceMaterial = F, t.MeshBasicMaterial = gt, t.LineDashedMaterial = Ui, t.LineBasicMaterial = be, t.Material = B, t.Float64BufferAttribute = lt, t.Float32BufferAttribute = ot, t.Uint32BufferAttribute = at, t.Int32BufferAttribute = st, t.Uint16BufferAttribute = rt, t.Int16BufferAttribute = nt, t.Uint8ClampedBufferAttribute = it, t.Uint8BufferAttribute = et, t.Int8BufferAttribute = tt, t.BufferAttribute = $, t.ArcCurve = Zi, t.CatmullRomCurve3 = Qi, t.CubicBezierCurve = en, t.CubicBezierCurve3 = nn, t.EllipseCurve = Yi, t.LineCurve = rn, t.LineCurve3 = sn, t.QuadraticBezierCurve = an, t.QuadraticBezierCurve3 = on, t.SplineCurve = ln, t.REVISION = "90dev", t.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        }, t.CullFaceNone = 0, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.FrontSide = 0, t.BackSide = 1, t.DoubleSide = 2, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = 0, t.FaceColors = 1, t.VertexColors = 2, t.NoBlending = 0, t.NormalBlending = 1, t.AdditiveBlending = 2, t.SubtractiveBlending = 3, t.MultiplyBlending = 4, t.CustomBlending = 5, t.AddEquation = 100, t.SubtractEquation = 101, t.ReverseSubtractEquation = 102, t.MinEquation = 103, t.MaxEquation = 104, t.ZeroFactor = 200, t.OneFactor = 201, t.SrcColorFactor = 202, t.OneMinusSrcColorFactor = 203, t.SrcAlphaFactor = 204, t.OneMinusSrcAlphaFactor = 205, t.DstAlphaFactor = 206, t.OneMinusDstAlphaFactor = 207, t.DstColorFactor = 208, t.OneMinusDstColorFactor = 209, t.SrcAlphaSaturateFactor = 210, t.NeverDepth = 0, t.AlwaysDepth = 1, t.LessDepth = 2, t.LessEqualDepth = 3, t.EqualDepth = 4, t.GreaterEqualDepth = 5, t.GreaterDepth = 6, t.NotEqualDepth = 7, t.MultiplyOperation = 0, t.MixOperation = 1, t.AddOperation = 2, t.NoToneMapping = 0, t.LinearToneMapping = 1, t.ReinhardToneMapping = 2, t.Uncharted2ToneMapping = 3, t.CineonToneMapping = 4, t.UVMapping = 300, t.CubeReflectionMapping = 301, t.CubeRefractionMapping = 302, t.EquirectangularReflectionMapping = 303, t.EquirectangularRefractionMapping = 304, t.SphericalReflectionMapping = 305, t.CubeUVReflectionMapping = 306, t.CubeUVRefractionMapping = 307, t.RepeatWrapping = 1e3, t.ClampToEdgeWrapping = 1001, t.MirroredRepeatWrapping = 1002, t.NearestFilter = 1003, t.NearestMipMapNearestFilter = 1004, t.NearestMipMapLinearFilter = 1005, t.LinearFilter = 1006, t.LinearMipMapNearestFilter = 1007, t.LinearMipMapLinearFilter = 1008, t.UnsignedByteType = 1009, t.ByteType = 1010, t.ShortType = 1011, t.UnsignedShortType = 1012, t.IntType = 1013, t.UnsignedIntType = 1014, t.FloatType = 1015, t.HalfFloatType = 1016, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedInt248Type = 1020, t.AlphaFormat = 1021, t.RGBFormat = 1022, t.RGBAFormat = 1023, t.LuminanceFormat = 1024, t.LuminanceAlphaFormat = 1025, t.RGBEFormat = 1023, t.DepthFormat = 1026, t.DepthStencilFormat = 1027, t.RGB_S3TC_DXT1_Format = 33776, t.RGBA_S3TC_DXT1_Format = 33777, t.RGBA_S3TC_DXT3_Format = 33778, t.RGBA_S3TC_DXT5_Format = 33779, t.RGB_PVRTC_4BPPV1_Format = 35840, t.RGB_PVRTC_2BPPV1_Format = 35841, t.RGBA_PVRTC_4BPPV1_Format = 35842, t.RGBA_PVRTC_2BPPV1_Format = 35843, t.RGB_ETC1_Format = 36196, t.RGBA_ASTC_4x4_Format = 37808, t.RGBA_ASTC_5x4_Format = 37809, t.RGBA_ASTC_5x5_Format = 37810, t.RGBA_ASTC_6x5_Format = 37811, t.RGBA_ASTC_6x6_Format = 37812, t.RGBA_ASTC_8x5_Format = 37813, t.RGBA_ASTC_8x6_Format = 37814, t.RGBA_ASTC_8x8_Format = 37815, t.RGBA_ASTC_10x5_Format = 37816, t.RGBA_ASTC_10x6_Format = 37817, t.RGBA_ASTC_10x8_Format = 37818, t.RGBA_ASTC_10x10_Format = 37819, t.RGBA_ASTC_12x10_Format = 37820, t.RGBA_ASTC_12x12_Format = 37821, t.LoopOnce = 2200, t.LoopRepeat = 2201, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = 2400, t.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = 0, t.TriangleStripDrawMode = 1, t.TriangleFanDrawMode = 2, t.LinearEncoding = 3e3, t.sRGBEncoding = 3001, t.GammaEncoding = 3007, t.RGBEEncoding = 3002, t.LogLuvEncoding = 3003, t.RGBM7Encoding = 3004, t.RGBM16Encoding = 3005, t.RGBDEncoding = 3006, t.BasicDepthPacking = 3200, t.RGBADepthPacking = 3201, t.CubeGeometry = dt, t.Face4 = function(t, e, i, n, r, s, a) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Q(t, e, i, r, s, a)
        }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function(t) {
            return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
        }, t.MultiMaterial = function(t) {
            return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, (t.materials = t).clone = function() {
                return t.slice()
            }, t
        }, t.PointCloud = function(t, e) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Se(t, e)
        }, t.Particle = function(t) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new ge(t)
        }, t.ParticleSystem = function(t, e) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Se(t, e)
        }, t.PointCloudMaterial = function(t) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ee(t)
        }, t.ParticleBasicMaterial = function(t) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ee(t)
        }, t.ParticleSystemMaterial = function(t) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ee(t)
        }, t.Vertex = function(t, e, i) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new St(t, e, i)
        }, t.DynamicBufferAttribute = function(t, e) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new $(t, e).setDynamic(!0)
        }, t.Int8Attribute = function(t, e) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new tt(t, e)
        }, t.Uint8Attribute = function(t, e) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new et(t, e)
        }, t.Uint8ClampedAttribute = function(t, e) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new it(t, e)
        }, t.Int16Attribute = function(t, e) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new nt(t, e)
        }, t.Uint16Attribute = function(t, e) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new rt(t, e)
        }, t.Int32Attribute = function(t, e) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new st(t, e)
        }, t.Uint32Attribute = function(t, e) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new at(t, e)
        }, t.Float32Attribute = function(t, e) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new ot(t, e)
        }, t.Float64Attribute = function(t, e) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new lt(t, e)
        }, t.ClosedSplineCurve3 = Or, t.SplineCurve3 = Dr, t.Spline = kr, t.AxisHelper = function(t) {
            return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Lr(t)
        }, t.BoundingBoxHelper = function(t, e) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Ar(t, e)
        }, t.EdgesHelper = function(t, e) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Te(new Mi(t.geometry), new be({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.WireframeHelper = function(t, e) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Te(new Le(t.geometry), new be({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.XHRLoader = function(t) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Hi(t)
        }, t.BinaryTextureLoader = function(t) {
            return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Vi(t)
        }, t.GeometryUtils = {
            merge: function(t, e, i) {
                var n;
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
            },
            center: function(t) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
            }
        }, t.ImageUtils = {
            crossOrigin: void 0,
            loadTexture: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Xi;
                return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
            },
            loadTextureCube: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Wi;
                return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        }, t.Projector = function() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
                console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
            }, this.unprojectVector = function(t, e) {
                console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
            }, this.pickingRay = function() {
                console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        }, t.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
        }, t.SceneUtils = {
            createMultiMaterialObject: function() {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
            },
            detach: function() {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
            },
            attach: function() {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
            }
        }, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }), define("parallax/parallax.store", ["dispatcher", "utils/EventEmitter", "resize/resize.store", "events/cursor.store", "THREE"], function(t, e, r, s, i) {
        "use strict";

        function n() {
            var t = s.getData().screenX,
                e = s.getData().screenY,
                i = r.getData().width,
                n = r.getData().height;
            c = (2 * t - i) / i, u = (2 * e - n) / n
        }

        function a(t) {}
        var o, l, h = new e,
            c = 0,
            u = 0,
            d = 0,
            p = 0,
            f = new i.Matrix4,
            m = function() {
                var t, e;
                .001 < Math.abs(d - c) && .001 < Math.abs(p - u) && (d += (c - d) / 20, p += (u - p) / 20, t = 5 * Math.pow(Math.pow(d, 2) + Math.pow(p, 2), .5) / 180 * Math.PI, e = new i.Vector3(-p, d, 0).normalize(), new i.Vector3(p, d, 0).normalize(), o = (new i.Matrix4).makeRotationAxis(e, t), l = (new i.Matrix4).makeTranslation(20 * d, 20 * p, 0), f = o.clone().multiply(l), h.dispatch()), requestAnimationFrame(m)
            };
        return t.subscribe(a), s.subscribe(n), m(), {
            subscribe: h.subscribe.bind(h),
            unsubscribe: h.unsubscribe.bind(h),
            getData: function() {
                return {
                    rotationMatrix: o,
                    translationMatrix: l,
                    transformationMatrix: f,
                    x: d,
                    y: p
                }
            }
        }
    }), define("slide-scroll/slide-transition.component", ["dispatcher", "parallax/parallax.store", "slide-scroll/slide-scroll.store", "scroll/scroll.store", "utils"], function(t, l, n, h, c) {
        "use strict";

        function e(t) {
            var e = this,
                i = n.getData().items["main-scroll"];
            if ("slide-scroll:click" === t.type) {
                if (!i || !i.active) return;
                this.copyElement(t.element)
            }
            "slide-scroll:transform" === t.type && i && i.active && (function(t, e, i, n, r) {
                n = "opacity " + i + "s ease " + n + "s,transform " + 1.2 * i + "s cubic-bezier(0.55, 0.005, 0.205, 1) " + n + "s", e = "rotate3d(0.0, 0.0, 1, " + e[0] / 15 + "deg) translate3d(0, " + (-10 - r) + "px, -30px)";
                t.style.transition = t.style.webkitTrabsition = n, t.style.transform = t.style.webkitTransform = e
            }(this, t.transform, 1, 0, i.shift), this.style.opacity = 0, setTimeout(function() {
                var t;
                (t = e).style.transition = t.style.webkitTrabsition = "opacity 0s ease 0s,transform 0s cubic-bezier(0.55, 0.005, 0.205, 1) 0s", t.style.transform = t.style.webkitTransform = "rotate3d(0.0, 0.0, 1, 0deg) translate3d(0, 0, 0)", e.style.opacity = 1
            }, 1e3))
        }
        var i = Object.create(HTMLElement.prototype);
        i.createdCallback = function() {
            this.handleDispatcher = e.bind(this), this.copyElement = function(t) {
                var e, i, n, r, s = t.cloneNode(!0),
                    a = getComputedStyle(t),
                    o = this;
                t.classList.contains("svg-border") ? (i = (e = c.offset(t)).top + h.getData().top, n = e.left, r = l.getData().transformationMatrix, this._inner && r && (this._inner.style.transform = "matrix3d(" + r.elements.join(",") + ")")) : (this._inner.style.transform = "none", i = (e = t.getBoundingClientRect()).top, n = e.left), s.style.position = "fixed", s.style.left = n + "px", s.style.top = i + "px", s.style.fontFamily = a.fontFamily, s.style.fontSize = a.fontSize, s.style.fontWeight = a.fontWeight, s.style.color = a.color, s.style.textTransform = a.textTransform, s.style.letterSpacing = a.letterSpacing, s.style.lineHeight = a.lineHeight, s.classList.add("fake"), t.style.visibility = "hidden", t.style.opacity = 0, this._inner.appendChild(s), this._fake = s, setTimeout(function() {
                    t.style.visibility = "visible", t.style.opacity = 1, s.parentNode.removeChild(s), o._fake = null
                }, 1e3)
            }.bind(this)
        }, i.attachedCallback = function() {
            this._inner = this.getElementsByClassName("inner")[0], t.subscribe(this.handleDispatcher)
        }, i.detachedCallback = function() {
            t.unsubscribe(this.handleDispatcher)
        }, document.registerElement("slide-transition", {
            prototype: i
        })
    }), define("slide-helper/slide-helper.component", ["dispatcher", "slide-scroll/slide-scroll.store", "TweenMax"], function(t, r, s) {
        "use strict";
        var e = Object.create(HTMLElement.prototype);
        e.createdCallback = function() {
            this.handleSlide = function() {
                var t, e = r.getData().items["main-scroll"],
                    i = this,
                    n = 1;
                e && (t = e.index) !== this._index && (this._index > t && (n = -n), 0 === (this._index = t) ? this.classList.add("disabled") : this.classList.remove("disabled"), 0 === t ? t = "" : t < 10 && (t = "0" + t), this._n2.innerHTML = t, s.set(this._n2, {
                    y: 20 * n,
                    opacity: 0
                }), s.to(this._n1, .3, {
                    y: -10 * n,
                    opacity: 0,
                    onComplete: function() {
                        var t = i._n1;
                        i._n1 = i._n2, i._n2 = t
                    }
                }), s.to(this._n2, .6, {
                    y: 0,
                    opacity: 1
                }))
            }.bind(this), this._index = 0
        }, e.attachedCallback = function() {
            this._l1 = this.getElementsByClassName("l1")[0], this._l2 = this.getElementsByClassName("l2")[0], this._n1 = this.getElementsByClassName("n1")[0], this._n2 = this.getElementsByClassName("n2")[0], this.handleSlide(), r.subscribe(this.handleSlide)
        }, e.detachedCallback = function() {
            r.unsubscribe(this.handleSlide)
        }, document.registerElement("slide-helper", {
            prototype: e
        })
    });
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
! function(i) {
    "use strict";

    function F(t, e, i, n) {
        var r;
        return (i = i || j(t, null)) ? r = (t = i.getPropertyValue(e.replace(s, "-$1").toLowerCase())) || i.length ? t : i[e] : t.currentStyle && (r = (i = t.currentStyle)[e]), n ? r : parseInt(r, 10) || 0
    }

    function a(t) {
        return !!(t.length && t[0] && (t[0].nodeType && t[0].style && !t.nodeType || t[0].length && t[0][0]))
    }

    function y(t) {
        return (t.charCodeAt(0) - 55296 << 10) + (t.charCodeAt(1) - 56320) + 65536
    }

    function l(t, e) {
        var i = -1 !== (t = t || "").indexOf("++"),
            n = 1;
        return i && (t = t.split("++").join("")),
            function() {
                return "<" + e + o + (t ? " class='" + t + (i ? n++ : "") + "'>" : ">")
            }
    }

    function H(t, e) {
        for (var i = e.length; - 1 < --i;) t.push(e[i])
    }

    function h(t) {
        for (var e = [], i = t.length, n = 0; n !== i; e.push(t[n++]));
        return e
    }

    function G(t, e, i) {
        for (var n; t && t !== e;) {
            if (n = t._next || t.nextSibling) return n.textContent.charAt(0) === i;
            t = t.parentNode || t._parent
        }
        return !1
    }
    var r = i.GreenSockGlobals || i,
        t = function(t) {
            for (var e = t.split("."), i = r, n = 0; n < e.length; n++) i[e[n]] = i = i[e[n]] || {};
            return i
        }("com.greensock.utils"),
        x = function(t) {
            var e = t.nodeType,
                i = "";
            if (1 === e || 9 === e || 11 === e) {
                if ("string" == typeof t.textContent) return t.textContent;
                for (t = t.firstChild; t; t = t.nextSibling) i += x(t)
            } else if (3 === e || 4 === e) return t.nodeValue;
            return i
        },
        V = document,
        j = V.defaultView ? V.defaultView.getComputedStyle : function() {},
        s = /([A-Z])/g,
        b = /(?:\r|\n|\t\t)/g,
        w = /(?:\s\s+)/g,
        o = " style='position:relative;display:inline-block;" + (V.all && !V.addEventListener ? "*display:inline;*zoom:1;'" : "'"),
        n = t.SplitText = r.SplitText = function(t, e) {
            if ("string" == typeof t && (t = n.selector(t)), !t) throw "cannot split a null element.";
            this.elements = a(t) ? function(t) {
                for (var e, i, n = [], r = t.length, s = 0; s < r; s++)
                    if (e = t[s], a(e))
                        for (i = e.length, i = 0; i < e.length; i++) n.push(e[i]);
                    else n.push(e);
                return n
            }(t) : [t], this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e)
        },
        W = function(t, e, i) {
            var n = t.nodeType;
            if (1 === n || 9 === n || 11 === n)
                for (t = t.firstChild; t; t = t.nextSibling) W(t, e, i);
            else 3 !== n && 4 !== n || (t.nodeValue = t.nodeValue.split(e).join(i))
        },
        X = function(t) {
            for (var e, i = h(t.childNodes), n = i.length, r = 0; r < n; r++)(e = i[r])._isSplit ? X(e) : (r && 3 === e.previousSibling.nodeType ? e.previousSibling.nodeValue += (3 === e.nodeType ? e : e.firstChild).nodeValue : 3 !== e.nodeType && t.insertBefore(e.firstChild, e), t.removeChild(e))
        },
        c = function(t, e, i, n) {
            var r, s, a = (l = h(t.childNodes)).length,
                o = "absolute" === e.position || !0 === e.absolute,
                l = Array.prototype.filter.call(l, function(t) {
                    return !t.tagName || "style" !== t.tagName.toLowerCase() && "svg" !== t.tagName.toLowerCase() && "defs" !== t.tagName.toLowerCase() && !t.closest("svg")
                });
            if (3 !== t.nodeType || 1 < a) {
                if (e.absolute = !1, l.length)
                    for (r = 0; r < a; r++)(s = l[r]) && (3 === s.nodeType && !/\S+/.test(s.nodeValue) || (o && 3 !== s.nodeType && "inline" === F(s, "display", null, !0) && (s.style.display = "inline-block", s.style.position = "relative"), s._isSplit = !0, c(s, e, i, n)));
                return e.absolute = o, void(t._isSplit = !0)
            }! function(t, e, i, n) {
                var r, s, a, o, l, h, c, u = e.span ? "span" : "div",
                    d = e.type || e.split || "chars,words,lines",
                    p = (d.indexOf("words"), -1 !== d.indexOf("chars")),
                    f = "absolute" === e.position || !0 === e.absolute,
                    m = e.wordDelimiter || " ",
                    g = " " !== m ? "" : f ? "&#173; " : " ",
                    v = e.span ? "</span>" : "</div>",
                    _ = !0,
                    d = V.createElement("div"),
                    f = t.parentNode;
                for (f.insertBefore(d, t), d.textContent = t.nodeValue, f.removeChild(t), d = -1 !== (r = x(t = d)).indexOf("<"), !1 !== e.reduceWhiteSpace && (r = r.replace(w, " ").replace(b, "")), d && (r = r.split("<").join("{{LT}}")), o = r.length, s = (" " === r.charAt(0) ? g : "") + i(), a = 0; a < o; a++)
                    if ((l = r.charAt(a)) === m && r.charAt(a - 1) !== m && a) {
                        for (s += _ ? v : "", _ = !1; r.charAt(a + 1) === m;) s += g, a++;
                        a === o - 1 ? s += g : ")" !== r.charAt(a + 1) && (s += g + i(), _ = !0)
                    } else "{" === l && "{{LT}}" === r.substr(a, 6) ? (s += p ? n() + "{{LT}}</" + u + ">" : "{{LT}}", a += 5) : 55296 <= l.charCodeAt(0) && l.charCodeAt(0) <= 56319 || 65024 <= r.charCodeAt(a + 1) && r.charCodeAt(a + 1) <= 65039 ? (h = y(r.substr(a, 2)), c = y(r.substr(a + 2, 2)), c = 127462 <= h && h <= 127487 && 127462 <= c && c <= 127487 || 127995 <= c && c <= 127999 ? 4 : 2, s += p && " " !== l ? n() + r.substr(a, c) + "</" + u + ">" : r.substr(a, c), a += c - 1) : s += p && " " !== l ? n() + l + "</" + u + ">" : l;
                t.parentNode !== document.documentElement && (t.outerHTML = s + (_ ? v : ""), d && W(f, "{{LT}}", "<"))
            }(t, e, i, n)
        },
        t = n.prototype;
    t.split = function(t) {
        this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
        for (var e, i, n, r = this.elements.length, s = t.span ? "span" : "div", a = ("absolute" === t.position || t.absolute, l(t.wordsClass, s)), o = l(t.charsClass, s); - 1 < --r;) n = this.elements[r], this._originals[r] = n.innerHTML, e = n.clientHeight, i = n.clientWidth, c(n, t, a, o),
            function(t, e, i, n, r, s, a) {
                var o, l, h, c, u, d, p, f, m, g, v, _, y = j(t),
                    x = F(t, "paddingLeft", y),
                    b = -999,
                    w = F(t, "borderBottomWidth", y) + F(t, "borderTopWidth", y),
                    T = F(t, "borderLeftWidth", y) + F(t, "borderRightWidth", y),
                    M = F(t, "paddingTop", y) + F(t, "paddingBottom", y),
                    E = F(t, "paddingLeft", y) + F(t, "paddingRight", y),
                    S = .2 * F(t, "fontSize"),
                    A = F(t, "textAlign", y, !0),
                    P = [],
                    C = [],
                    R = [],
                    L = e.wordDelimiter || " ",
                    O = e.span ? "span" : "div",
                    y = e.type || e.split || "chars,words,lines",
                    D = r && -1 !== y.indexOf("lines") ? [] : null,
                    k = -1 !== y.indexOf("words"),
                    I = -1 !== y.indexOf("chars"),
                    N = "absolute" === e.position || !0 === e.absolute,
                    z = e.linesClass,
                    B = -1 !== (z || "").indexOf("++"),
                    U = [];
                for (D && 1 === t.children.length && t.children[0]._isSplit && (t = t.children[0]), B && (z = z.split("++").join("")), h = (l = t.getElementsByTagName("*")).length, u = [], o = 0; o < h; o++) u[o] = l[o];
                if (D || N)
                    for (o = 0; o < h; o++)((d = (c = u[o]).parentNode === t) || N || I && !k) && (_ = c.offsetTop, D && d && Math.abs(_ - b) > S && "BR" !== c.nodeName && (p = [], D.push(p), b = _), N && (c._x = c.offsetLeft, c._y = _, c._w = c.offsetWidth, c._h = c.offsetHeight), D && ((c._isSplit && d || !I && d || k && d || !k && c.parentNode.parentNode === t && !c.parentNode._isSplit) && (p.push(c), c._x -= x, G(c, t, L) && (c._wordEnd = !0)), "BR" === c.nodeName && c.nextSibling && "BR" === c.nextSibling.nodeName && D.push([])));
                for (o = 0; o < h; o++) d = (c = u[o]).parentNode === t, "BR" !== c.nodeName ? (N && (m = c.style, k || d || (c._x += c.parentNode._x, c._y += c.parentNode._y), m.left = c._x + "px", m.top = c._y + "px", m.position = "absolute", m.display = "block", m.width = c._w + 1 + "px", m.height = c._h + "px"), !k && I ? c._isSplit ? (c._next = c.nextSibling, c.parentNode.appendChild(c)) : c.parentNode._isSplit ? (c._parent = c.parentNode, !c.previousSibling && c.firstChild && (c.firstChild._isFirst = !0), c.nextSibling && " " === c.nextSibling.textContent && !c.nextSibling.nextSibling && U.push(c.nextSibling), c._next = c.nextSibling && c.nextSibling._isFirst ? null : c.nextSibling, c.parentNode.removeChild(c), u.splice(o--, 1), h--) : d || (_ = !c.nextSibling && G(c.parentNode, t, L), c.parentNode._parent && c.parentNode._parent.appendChild(c), _ && c.parentNode.appendChild(V.createTextNode(" ")), e.span && (c.style.display = "inline"), P.push(c)) : c.parentNode._isSplit && !c._isSplit && "" !== c.innerHTML ? C.push(c) : I && !c._isSplit && (e.span && (c.style.display = "inline"), P.push(c))) : D || N ? (c.parentNode && c.parentNode.removeChild(c), u.splice(o--, 1), h--) : k || t.appendChild(c);
                for (o = U.length; - 1 < --o;) U[o].parentNode.removeChild(U[o]);
                if (D) {
                    for (N && (g = V.createElement(O), t.appendChild(g), v = g.offsetWidth + "px", _ = g.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(g)), m = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                    for (f = " " === L && (!N || !k && !I), o = 0; o < D.length; o++) {
                        for (p = D[o], (g = V.createElement(O)).style.cssText = "display:block;text-align:" + A + ";position:" + (N ? "absolute;" : "relative;"), z && (g.className = z + (B ? o + 1 : "")), R.push(g), h = p.length, l = 0; l < h; l++) "BR" !== p[l].nodeName && (c = p[l], g.appendChild(c), f && c._wordEnd && g.appendChild(V.createTextNode(" ")), N && (0 === l && (g.style.top = c._y + "px", g.style.left = x + _ + "px"), c.style.top = "0px", _ && (c.style.left = c._x - _ + "px")));
                        0 === h ? g.innerHTML = "&nbsp;" : k || I || (X(g), W(g, String.fromCharCode(160), " ")), N && (g.style.width = v, g.style.height = c._h + "px"), t.appendChild(g)
                    }
                    t.style.cssText = m
                }
                N && (a > t.clientHeight && (t.style.height = a - M + "px", t.clientHeight < a && (t.style.height = a + w + "px")), s > t.clientWidth && (t.style.width = s - E + "px", t.clientWidth < s && (t.style.width = s + T + "px"))), H(i, P), H(n, C), H(r, R)
            }(n, t, this.chars, this.words, this.lines, i, e);
        return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
    }, t.revert = function() {
        if (!this._originals) throw "revert() call wasn't scoped properly.";
        for (var t = this._originals.length; - 1 < --t;) this.elements[t].innerHTML = this._originals[t];
        return this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
    }, n.selector = i.$ || i.jQuery || function(t) {
        var e = i.$ || i.jQuery;
        return e ? (n.selector = e)(t) : "undefined" == typeof document ? t : document.querySelectorAll ? document.querySelectorAll(t) : document.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
    }, n.version = "0.5.7"
}(_gsScope),
function() {
    "use strict";

    function t() {
        return (_gsScope.GreenSockGlobals || _gsScope).SplitText
    }
    "undefined" != typeof module && module.exports ? module.exports = t() : "function" == typeof define && define.amd && define("SplitText", [], t)
}(), define("appear/content-appear.component", ["dispatcher", "slide-scroll/slide-scroll.store", "popup/popup.store", "resize/resize.store", "page-load/page-load.store", "TweenMax", "THREE", "SplitText", "utils"], function(n, r, t, l, a, e, h, o, i) {
    "use strict";

    function c(i) {
        var t = a.getData().loaded,
            n = this;

        function l(t) {
            t._splitText.split({
                type: "words"
            }), t._splitText.words.forEach(function(t) {
                t.style.transformStyle = "preserve-3d"
            })
        }
        if ("overlay:show" === i.type || "content-appear:show" === i.type) {
            if (!t) return;
            this.toggle(i, !1)
        }
        if ("overlay:hide" === i.type) {
            if (!t) return;
            this.toggle(i, !0)
        }
        "slide-scroll:transform" === i.type && (i.transform, i.current === this && this._hasDepth && this._elements.forEach(function(t) {
            var e, a, o = n._globalDelay;
            i.delay && (o += i.delay), t._splitText && (t._splitText.words && t._splitText.words.length || l(t), setTimeout(function() {
                e = t._splitText.words, a = Math.min(.1, .3 / e.length), e.forEach(function(t, e) {
                    var i, n, r, s;
                    n = -100, r = 1.2, s = .8 + e * a + o, (i = t) && i.style && (i.style.transition = i.style.webkitTransition = "transform 0s ease 0s, opacity 0s ease 0s", i.style.transform = i.style.webkitTransform = "translateZ(" + n + "px)", i.style.opacity = 0, setTimeout(function() {
                        i.style.transition = i.style.webkitTransition = "transform " + r + "s ease " + s + "s,opacity " + r + "s ease " + s + "s", i.style.transform = i.style.webkitTransform = "translateZ(0px)", i.style.opacity = 1
                    }, 20))
                }), clearTimeout(t._wordsTimeout), t._wordsTimeout = setTimeout(function() {
                    t._splitText.revert()
                }, 3e3 + o)
            }, 20))
        }), i.previous === this && this._hasDepth && this._elements.forEach(function(t) {
            var e, r;
            t._splitText && (t._splitText.words && t._splitText.words.length || l(t), setTimeout(function() {
                e = t._splitText.words, r = Math.min(.1, .3 / e.length), e.forEach(function(t, e) {
                    var i, n;
                    i = -100, n = .6, e = e * r, (t = t) && t.style && (t.style.transition = t.style.webkitTransition = "transform " + n + "s ease " + e + "s,opacity " + n + "s ease " + e + "s", t.style.transform = t.style.webkitTransform = "translateZ(" + i + "px)", t.style.opacity = 0)
                }), clearTimeout(t._wordsTimeout), t._wordsTimeout = setTimeout(function() {
                    t._splitText.revert()
                }, 2e3)
            }, 20))
        })), "slide-scroll:zoom-out" !== i.type || this._zoomedOut || (this._zoomedOut = !0, i.slide === this && this._hasDepth && Array.prototype.forEach.call(this._elements, function(t) {
            "drop-down" !== t.getAttribute("is") && n.rotateTo(t, [0, 0, -40], .6, .6, 0)
        })), "slide-scroll:zoom-in" === i.type && this._zoomedOut && (this._zoomedOut = !1, i.slide === this && this._hasDepth && Array.prototype.forEach.call(this._elements, function(t) {
            "drop-down" !== t.getAttribute("is") && (s, n.rotateTo(t, [0, 0, 0], 1, .45, 0))
        }))
    }
    var u = Object.create(HTMLElement.prototype);
    u.createdCallback = function() {
        this._active = !1, this.handleScroll = function(t) {
            var e = r.getData().items["main-scroll"];
            e && (this._index !== e.index || this._active ? this._index !== e.index && this._active && (this._active = !1) : this._active = !0)
        }.bind(this), this.handleDispatcher = c.bind(this), this.handleLoad = function() {
            a.getData().loaded, l.getData().width
        }.bind(this), this.handleResize = function() {
            var n = l.getData().width,
                r = l.getData().height,
                s = this;
            this._hasDepth && this._elements.forEach(function(t) {
                var e = t.getBoundingClientRect(),
                    i = e.left,
                    e = e.top,
                    i = -(i - n / 2),
                    e = -(e - r / 2) + s._slideScroll._shift * s._index;
                t._hasDepth && (t.style.perspectiveOrigin = i + "px " + e + "px")
            })
        }.bind(this), this.toggle = function(t, n, r) {
            var s, e = l.getData().width,
                i = l.getData().height,
                a = Math.pow(Math.pow(e, 2) + Math.pow(i, 2), .5),
                o = this;
            if (clearTimeout(this._initialTo), this._active) {
                if (void 0 === r && (r = 1), n) {
                    if (!0 === this._visible) return;
                    this._visible = !0
                } else {
                    if (!1 === this._visible) return;
                    this._visible = !1
                }
                t.x && t.y || (t.x = e / 2, t.y = i / 2), s = new h.Vector2(t.x, t.y), Array.prototype.forEach.call(this._elements, function(t) {
                    var e = t.getBoundingClientRect(),
                        i = new h.Vector2(e.left + e.width / 2, e.top + e.height / 2),
                        e = s.clone().sub(i),
                        i = Math.min(e.length(), 2e3),
                        e = (e = e.normalize()).multiplyScalar(i / 1e3);
                    n ? o.roteteFrom(t, [10 * e.x, 10 * e.y, -15], 0, .6 * r, .5 + i / a / 2 * r) : o.rotateTo(t, [10 * -e.x, 10 * -e.y, -15], 0, .5 * r, i / a / 3 * r)
                })
            }
        }.bind(this), this.rotateTo = function(t, e, i, n, r) {
            var s = t.tagName.toLowerCase(),
                s = "a" === s || "button" === s ? 2 : 0,
                r = "transform " + n + "s ease " + r + "s,opacity " + n + "s ease " + r + "s",
                e = "rotate3d(" + e[1] + ", " + -e[0] + ", 0.0, 5deg) translate3d(" + 2.5 * e[0] + "px, " + 2.5 * e[1] + "px, " + (e[2] + s) + "px)";
            t && t.style && (t.style.transition = t.style.webkitTransition = r, t.style.transform = t.style.webkitTransform = e, t.style.opacity = i)
        }.bind(this), this.roteteFrom = function(i, t, e, n, r) {
            var s = i.tagName.toLowerCase(),
                t = "rotate3d(" + t[1] + ", " + -t[0] + ", 0.0, -5deg) translate3d(" + 3.5 * t[0] + "px, " + 3.5 * t[1] + "px, " + t[2] + "px)";
            i.style.transition = i.style.webkitTransition = "opacity 0s ease 0s, transform 0s ease 0s", i.style.transform = i.style.webkitTransform = t, i.style.opacity = e, setTimeout(function() {
                var t = "opacity " + n + "s ease " + r + "s,transform " + n + "s ease-out " + r + "s",
                    e = "rotate3d(0, 0, 0, 0deg) translate3d(0px, 0px, " + ("a" === s || "button" === s ? 2 : 0) + "px)";
                i.style.transition = i.style.webkitTransition = t, i.style.transform = i.style.webkitTransform = e, i.style.opacity = 1
            }, 20)
        }.bind(this)
    }, u.attachedCallback = function() {
        var e = this,
            t = document.getElementsByClassName("s-slide"),
            i = this.getElementsByClassName("parse-all");
        this._index = Array.prototype.indexOf.call(t, this), this._slideScroll = this.closest("slide-scroll-wrapper"), this._elements = [], this._hasDepth = this.classList.contains("dark"), this._globalDelay = this.classList.contains("delayed") ? .65 : 0, Array.prototype.forEach.call(i, function(t) {
            t = t.children, t = Array.prototype.slice.call(t);
            e._elements = e._elements.concat(t), e._hasDepth && t.forEach(function(t) {
                var e = t.getElementsByTagName("p");
                "scroll-links" === t.tagName.toLowerCase() || "button" === t.tagName.toLowerCase() || "big-svg" === t.tagName.toLowerCase() || "a" === t.tagName.toLowerCase() || t.classList.contains("btn-wrap") ? t._hasDepth = !1 : (t._hasDepth = !0, Array.prototype.forEach.call(e, function(t) {
                    t.innerHTML = t.innerHTML.replace("–", "‑").replace("-", "‑")
                }), "p" === t.tagName.toLowerCase() && (t.innerHTML = t.innerHTML.replace("–", "‑").replace("-", "‑")), t._splitText = new o(t, {
                    type: ""
                }), t._splitText.revert(), t.style.perspective = "1200px")
            })
        }), this.handleScroll(), this.handleLoad(), this.handleResize(), r.subscribe(this.handleScroll), n.subscribe(this.handleDispatcher), a.subscribe(this.handleLoad), l.subscribe(this.handleResize)
    }, u.detachedCallback = function() {
        r.unsubscribe(this.handleScroll), n.unsubscribe(this.handleDispatcher), a.unsubscribe(this.handleLoad), l.unsubscribe(this.handleResize)
    }, document.registerElement("content-appear", {
        prototype: u,
        extends: "section"
    })
}), define("drop-down/drop-down.component", ["dispatcher", "helpers", "TweenMax", "slide-scroll/slide-scroll.store", "decor/cursor-interactive.component"], function(r, t, s, a, i) {
    "use strict";
    var e = Object.create(HTMLButtonElement.prototype);
    return e.createdCallback = function() {
        i.createdCallback.apply(this), this.show = function(t) {
            var e = this,
                i = this._in.clientHeight,
                n = a.getData().items["main-scroll"];
            void 0 === t && (t = 1), this.classList.add("active"), this._active = !0, this.onChange && this.onChange(), s.killTweensOf(this._wr), s.to(this._wr, .6 * t, {
                height: i,
                ease: Power2.easeInOut,
                onComplete: function() {
                    e._wr.style.height = "auto"
                }
            }), n && n.active && (this._mouseTo = setTimeout(function() {
                e._mouseHandlers = !0
            }, 300), r.dispatch({
                type: "slide-scroll:zoom-out",
                slide: e._slide
            }))
        }.bind(this), this.hide = function(t) {
            var e = a.getData().items["main-scroll"];
            this.classList.remove("active"), this._active = !1, void 0 === t && (t = 1), this.onChange && this.onChange(), s.killTweensOf(this._wr), s.to(this._wr, .5 * t, {
                height: 0,
                ease: Power2.easeInOut
            }), clearTimeout(this._mouseTo), e && e.active && (this._mouseHandlers = !1, r.dispatch({
                type: "slide-scroll:zoom-in",
                slide: this._slide
            }))
        }.bind(this), this.handleMouseenter = function() {
            this._mouseHandlers && r.dispatch({
                type: "slide-scroll:zoom-out",
                slide: this._slide
            })
        }.bind(this), this.handleMouseleave = function() {
            this._mouseHandlers && r.dispatch({
                type: "slide-scroll:zoom-in",
                slide: this._slide
            })
        }.bind(this), this._active = !1
    }, e.attachedCallback = function() {
        i.attachedCallback.apply(this);
        var e = this;
        this._hd = this.getElementsByClassName("dd-header")[0], this._wr = this.getElementsByClassName("dd-wrapper")[0], this._in = this.getElementsByClassName("dd-inner")[0], this._slide = this.closest(".s-slide"), this.addEventListener("click", function(t) {
            e._active ? e.hide() : e.show()
        }), this.addEventListener("mouseenter", this.handleMouseenter), this.addEventListener("mouseleave", this.handleMouseleave), this.classList.contains("active") && this.show(0)
    }, e.detachedCallback = function() {
        i.detachedCallback.apply(this)
    }, document.registerElement("drop-down", {
        prototype: e,
        extends: "button"
    }), e
}), define("drop-down/accordeon.component", ["dispatcher", "page-load/page-load.store"], function(t, e) {
    "use strict";
    var i = Object.create(HTMLElement.prototype);
    return i.createdCallback = function() {
        this._active = !1, this.handleChange = function(t) {
            t._active ? (this._active && this._active.hide(), this._active = t) : this._active = !1
        }.bind(this), this.handleLoad = function() {
            var e = this;
            Array.prototype.forEach.call(this._dropDowns, function(t) {
                t._active && (e._active = t), t.onChange = function() {
                    e.handleChange(t)
                }
            })
        }.bind(this)
    }, i.attachedCallback = function() {
        this._dropDowns = this.getElementsByClassName("drop-down"), this.handleLoad(), e.subscribe(this.handleLoad)
    }, i.detachedCallback = function() {
        e.unsubscribe(this.handleLoad)
    }, document.registerElement("accordeon-component", {
        prototype: i
    }), i
}), define("resize/breakpoint.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
    "use strict";

    function i() {
        return {
            height: window.innerHeight,
            width: window.innerWidth
        }
    }

    function n() {
        o = i(),
            function() {
                for (var t = s.length - 1; 0 <= t; t--)
                    if (o.width >= s[t].size) return a === s[t] || (a = s[t], r.dispatch())
            }()
    }
    var r = new e,
        s = [{
            size: 0,
            name: "mobile"
        }, {
            size: 640,
            name: "tablet"
        }, {
            size: 1e3,
            name: "desktop"
        }],
        a = null,
        o = {
            width: 0,
            height: 0
        };
    return o = i(), n(), window.addEventListener("resize", n, {
        passive: !0
    }), window.addEventListener("orientationchange", n, {
        passive: !0
    }), window.addEventListener("load", n, {
        passive: !0
    }), {
        subscribe: r.subscribe.bind(r),
        unsubscribe: r.unsubscribe.bind(r),
        getData: function() {
            return a
        }
    }
}), define("popup/popup.component", ["dispatcher", "popup/popup.store", "resize/breakpoint.store"], function(e, i, t) {
    "use strict";

    function n(t) {
        t.stopPropagation()
    }
    var r = Object.create(HTMLElement.prototype);
    return r.createdCallback = function() {
        this.open = function() {
            var t;
            this.getAttribute("data-lazy-slider") && (t = this.getElementsByTagName("basic-slider")[0].getAttribute("data-id"), e.dispatch({
                type: "slider:lazy-load",
                id: t
            })), "function" == typeof this.onOpen && this.onOpen(), this._active = !0, this.classList.add("active"), this.removeAttribute("inert"), (t = this.getElementsByClassName("overflow")[0]) && t.addEventListener("touchmove", n)
        }.bind(this), this.close = function() {
            var t;
            "function" == typeof this.onClose && this.onClose(), this._active = !1, this.classList.remove("active"), this.setAttribute("inert", ""), (t = this.getElementsByClassName("overflow")[0]) && t.removeEventListener("touchmove", n)
        }.bind(this), this.handleStore = function() {
            var t = i.getData().active;
            document.getElementsByTagName("body")[0];
            this._active || t !== this._id ? this._active && t !== this._id && this.close() : this.open()
        }.bind(this), this.closeAll = function() {
            e.dispatch({
                type: "popup:close-all"
            })
        }.bind(this)
    }, r.attachedCallback = function() {
        this._id = this.getAttribute("data-id"), this._active = !1, i.subscribe(this.handleStore)
    }, r.detachedCallback = function() {
        i.unsubscribe(this.handleStore)
    }, document.registerElement("popup-component", {
        prototype: r
    }), r
}), define("popup/appear-popup.component", ["dispatcher", "popup/popup.component", "popup/popup.store", "resize/resize.store", "THREE"], function(t, i, e, h, c) {
    "use strict";
    var n = Object.create(HTMLElement.prototype);
    n.createdCallback = function() {
        i.createdCallback.apply(this), this.toggle = function(t, n, r) {
            var e = document.getElementsByClassName("menu-btn")[0].getBoundingClientRect(),
                i = h.getData().width,
                s = h.getData().height,
                a = Math.pow(Math.pow(i, 2) + Math.pow(s, 2), .5),
                o = this,
                s = t.x || e.left + e.width / 2,
                e = t.y || e.top + e.height / 2,
                l = new c.Vector2(s, e);
            if (clearTimeout(this._initialTo), void 0 === r && (r = 1), n) {
                if (!0 === this._visible) return;
                this._visible = !0
            } else {
                if (!1 === this._visible) return;
                this._visible = !1
            }
            Array.prototype.forEach.call(this._elements, function(t) {
                var e = t.getBoundingClientRect(),
                    i = new c.Vector2(e.left + e.width / 2, e.top + e.height / 2),
                    e = l.clone().sub(i),
                    i = Math.min(e.length(), 2e3),
                    e = (e = e.normalize()).multiplyScalar(i / 100);
                n ? o.transformFrom(t, [e.x, e.y, -15], 0, .6 * r, .3 + i / a / 2 * r) : o.transformTo(t, [-e.x, -e.y, -15], 0, .2 * r, i / a / 4 * r)
            })
        }.bind(this), this.transformTo = function(t, e, i, n, r) {
            r = "opacity " + n + "s ease " + r + "s,transform " + n + "s ease-in " + r + "s", e = "rotate3d(" + e[1] + ", " + -e[0] + ", 0.0, 5deg) translate3d(" + 2.5 * e[0] + "px, " + 2.5 * e[1] + "px, " + e[2] + "px)";
            t.style.transition = t.style.webkitTrabsition = r, t.style.transform = t.style.webkitTransform = e, t.style.opacity = i
        }.bind(this), this.transformFrom = function(e, t, i, n, r) {
            t = "rotate3d(" + t[1] + ", " + -t[0] + ", 0.0, -5deg) translate3d(" + 3.5 * t[0] + "px, " + 3.5 * t[1] + "px, " + t[2] + "px)";
            e.style.transition = e.style.webkitTrabsition = "opacity 0s ease 0s, transform 0s ease 0s", e.style.transform = e.style.webkitTransform = t, e.style.opacity = i, setTimeout(function() {
                var t = "opacity " + n + "s ease " + r + "s,transform " + n + "s ease-out " + r + "s";
                e.style.transition = e.style.webkitTrabsition = t, e.style.transform = e.style.webkitTransform = "rotate3d(0, 0, 0, 0deg) translate3d(0px, 0px, 0px)", e.style.opacity = 1
            }, 20)
        }.bind(this), this.onOpen = function() {
            var t = e.getData().userData;
            this.toggle(t, !0)
        }.bind(this), this.onClose = function() {
            var t = e.getData().userData;
            this.toggle(t, !1)
        }.bind(this)
    }, n.attachedCallback = function() {
        var e = this,
            t = this.getElementsByClassName("parse-all");
        i.attachedCallback.apply(this), this._elements = [], Array.prototype.forEach.call(t, function(t) {
            t = t.children, t = Array.prototype.slice.call(t);
            e._elements = e._elements.concat(t)
        }), this._elements.forEach(function(t) {
            t.style.transformStyle = "preserve-3d"
        })
    }, n.detachedCallback = function() {
        i.detachedCallback.apply(this)
    }, document.registerElement("appear-popup", {
        prototype: n
    })
}), define("popup/popup-toggle.component", ["dispatcher", "popup/popup.store"], function(i, n) {
    "use strict";
    var t = Object.create(HTMLButtonElement.prototype);
    return t.createdCallback = function() {
        this.handleClick = function() {
            var t = n.getData().active,
                e = this.getAttribute("data-target"),
                e = e ? this.querySelector(e) : this;
            this.classList.contains("close-all") && t ? i.dispatch({
                type: "popup:close",
                element: e
            }) : i.dispatch({
                type: "popup:toggle",
                id: this._id,
                element: e
            })
        }.bind(this), this.handleStore = function() {
            var t = n.getData().active;
            this.classList.contains("close-all") ? t ? (this.setAttribute("aria-expanded", "true"), this.classList.add("active")) : (this.setAttribute("aria-expanded", "false"), this.classList.remove("active")) : t === this._id ? (this.setAttribute("aria-expanded", "true"), this.classList.add("active")) : (this.setAttribute("aria-expanded", "false"), this.classList.remove("active"))
        }.bind(this)
    }, t.attachedCallback = function() {
        this._id = this.getAttribute("data-id"), this.setAttribute("aria-haspopup", "true"), this.addEventListener("click", this.handleClick), n.subscribe(this.handleStore), this.handleStore()
    }, t.detachedCallback = function() {
        this.removeEventListener("click", this.handleClick), n.unsubscribe(this.handleStore)
    }, document.registerElement("popup-toggle", {
        extends: "button",
        prototype: t
    }), t
}), define("popup/popup-helper.view", ["dispatcher", "popup/popup.store"], function(a, o) {
    "use strict";

    function l(t, e, i) {
        var n = null,
            t = i ? document.querySelectorAll(t.split(":")[0] + "[is=" + t.split(":")[1] + "]") : document.getElementsByTagName(t);
        return Array.prototype.forEach.call(t, function(t) {
            t.getAttribute("data-id") === e && (n = t)
        }), n
    }

    function h(t) {
        c && "keyboard:tab" === t.type && (t.event.preventDefault(), c[++d] || (d = 0), c[d].focus())
    }

    function t(t) {
        o.getData().active && "keyboard:esc" === t.type && a.dispatch({
            type: "popup:close-all"
        })
    }

    function e() {
        var t = (s = o.getData()).active,
            e = document.getElementsByClassName("page-wrapper")[0],
            i = document.getElementsByClassName("menu-btn")[0].getBoundingClientRect(),
            n = s.userData,
            r = n.x || i.left + i.width / 2,
            s = n.y || i.top + i.height / 2;
        t ? (e.classList.add("popup-active"), n = o.getData().active, i = null, t = document.getElementsByClassName("popup-focusable"), t = Array.prototype.slice.call(t, 0), (i = l("appear-popup", n)) ? (u = document.activeElement, (n = i.querySelector("popup-close") || l("button:popup-toggle", n, !0) || document.querySelector("button.close-all")) ? (c = i.querySelectorAll("button, a, input, select, textarea"), c = (c = Array.prototype.slice.call(c, 0)).concat(t), -1 === Array.prototype.indexOf.call(t, n) && c.push(n), c.sort(function(t, e) {
            t = t.tabIndex || 0;
            return (e.tabIndex || 0) < t
        }), a.subscribe("keyboard", h), c[0].focus(), d = 0) : console.warn("hmmm.......")) : console.warn("hm..."), a.dispatch({
            type: "scroll:block"
        }), a.dispatch({
            type: "overlay:show",
            x: r,
            y: s
        })) : (e.classList.remove("popup-active"), a.unsubscribe("keyboard", h), u && u.focus(), u = null, a.dispatch({
            type: "scroll:unblock"
        }), a.dispatch({
            type: "overlay:hide",
            x: r,
            y: s
        }))
    }
    var c, u = null,
        d = 0;
    o.subscribe(e), a.subscribe("keyboard", t)
}), define("router/router.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
    "use strict";

    function i(t) {
        "router:page-change" === t.type && r.href !== t.href && (r.href = t.href, n.dispatch())
    }
    var n = new e,
        r = {};
    return t.subscribe(i), {
        subscribe: n.subscribe.bind(n),
        unsubscribe: n.unsubscribe.bind(n),
        getData: function() {
            return {
                page: r
            }
        }
    }
}), define("router/router.view", ["dispatcher", "utils", "router/router.store"], function(n, e, r) {
    "use strict";

    function i(t) {
        -1 < f && f < 11 ? window.location.href = t.href : (c = t.transitionData, n.dispatch({
            type: "router:page-change",
            href: t.href
        }), n.dispatch({
            type: "page-transition:start",
            transitionData: t.transitionData
        }), t = t.href, e.http(t).get().then(function(t) {
            (d = document.createElement("div")).innerHTML = t, n.dispatch({
                type: "page-transition:check",
                step: 1
            })
        }))
    }

    function s() {
        var t, e, i = r.getData().page.href;
        d && (e = document.getElementsByClassName("replaceable"), t = d.getElementsByTagName("title")[0].innerHTML, Array.prototype.forEach.call(e, function(t) {
            var e, i;
            (i = (e = t).getAttribute("data-id")) ? (t = d.querySelector('.replaceable[data-id="' + i + '"]')) ? (e.innerHTML = "", e.innerHTML = t.innerHTML) : console.warn("unable to find container with data-id " + i + " on fetched document"): console.warn("data-id attribute is missing")
        }), document.title = t, !p && window.history && window.history.pushState({
            url: i
        }, t, i), n.dispatch({
            type: "content:replaced"
        }), n.dispatch({
            type: "page-transition:check",
            step: 2
        }))
    }

    function t(t) {
        if ("route" === t.type) {
            if (h) return;
            p = !!t.byHistory, h = !0, i(t)
        }
        var e;
        "page-transition:check" === t.type && (e = t.step, u[e].current++, u[e].current === u[e].total && n.dispatch({
            type: "page-transition:step-" + e + "-complete"
        })), "page-transition:step-1-complete" === t.type && s(), "page-transition:step-2-complete" === t.type && n.dispatch({
            type: "page-transition:end",
            transitionData: c
        }), "page-transition:step-3-complete" === t.type && (h = !1, m())
    }

    function a(t) {
        var e;
        t && t.state && (e = t.state.url, t.preventDefault(), e && n.dispatch({
            type: "route",
            href: e,
            byHistory: !0
        }))
    }
    var o, l, h = !1,
        c = null,
        u = {},
        d = null,
        p = !1,
        f = e.getIEVersion(),
        m = function() {
            u = {
                1: {
                    current: 0,
                    total: 2
                },
                2: {
                    current: 0,
                    total: 1
                },
                3: {
                    current: 0,
                    total: 1
                }
            }
        };
    o = location.origin + location.pathname + location.search, -1 < (l = e.getIEVersion()) && l < 11 || (window.history && window.history.replaceState({
        url: o
    }, !1, o), n.dispatch({
        type: "router:page-change",
        href: o
    }), window.onpopstate = a, n.subscribe(t), m())
}), define("router/inner-link.component", ["dispatcher", "router/router.store", "utils"], function(a, o, t) {
    "use strict";
    var e = Object.create(HTMLAnchorElement.prototype),
        l = t.getIEVersion();
    return e.createdCallback = function() {
        this.handleClick = function(t) {
            var e, i = o.getData().page.href,
                n = this.getAttribute("data-target"),
                r = this.classList.contains("transition-copy"),
                s = this.classList.contains("target-copy"),
                n = (n = n && this.querySelector(n)) || this; - 1 < l && l < 11 || (t.preventDefault(), i !== this.href && (t = n.getBoundingClientRect(), s ? e = n : r && (e = this), a.dispatch({
                type: "route",
                href: this.href,
                transitionData: {
                    animation: this._transitionType,
                    coordinates: {
                        x: t.left + t.width / 2,
                        y: t.top + t.height / 2
                    },
                    url: i,
                    element: n,
                    copyElement: e,
                    originalElement: this
                }
            })))
        }.bind(this), this.handleMouseenter = function() {
            this.classList.contains("active") || this.parentNode.classList.add("hover")
        }.bind(this), this.handleMouseleave = function() {
            this.parentNode.classList.remove("hover")
        }.bind(this), this.handleRouterStore = function() {
            o.getData().page.href === this.href ? (this.classList.add("active"), this._active = !0, this.setAttribute("aria-current", "page"), this._hoverParent && this.parentNode.classList.add("active")) : (this.classList.remove("active"), this._active = !1, this.removeAttribute("aria-current"), this._hoverParent && this.parentNode.classList.remove("active"))
        }.bind(this)
    }, e.attachedCallback = function() {
        this._transitionType = this.getAttribute("data-type") || "basic", this._outer = this.getAttribute("data-outer"), this._hoverParent = this.getAttribute("data-hover-parent"), this.handleRouterStore(), this._outer || this.addEventListener("click", this.handleClick), this._hoverParent && (this.addEventListener("mouseenter", this.handleMouseenter), this.addEventListener("mouseleave", this.handleMouseleave)), o.subscribe(this.handleRouterStore)
    }, e.detachedCallback = function() {
        o.unsubscribe(this.handleRouterStore)
    }, document.registerElement("inner-link", {
        extends: "a",
        prototype: e
    }), e
}), define("router/transitions/basic-transition.decorator", ["dispatcher", "events/cursor.store", "popup/popup.store", "parallax/parallax.store", "TweenMax"], function(o, l, h, t, e) {
    "use strict";
    var c = "basic-transition";
    if (window._registeredDecorators || (window._registeredDecorators = []), -1 === window._registeredDecorators.indexOf(c)) {
        window._registeredDecorators.push(c);
        var u = function(t, e, i, n) {
            n = "opacity " + i + "s ease " + n + "s";
            t && t.style && (t.style.transition = t.style.webkitTransition = n, t.style.opacity = e)
        };
        return {
            attach: function(t) {
                var e = {};
                t._decorators || (t._decorators = {}), (t._decorators[c] = e).start = function(t) {
                    var e = this._decorators[c],
                        i = document.getElementsByClassName("page-wrapper")[0],
                        n = document.getElementsByTagName("main")[0],
                        r = h.getData().active,
                        s = r ? 200 : 1e3,
                        a = r ? 0 : 1;
                    t.copyElement && (this.copyElement(t.copyElement), this._origianlTransitionElement = t.originalElement, this._origianlTransitionElement.style.visibility = "hidden"), r = t.coordinates ? t.coordinates.x : l.getData().screenX, t = t.coordinates ? t.coordinates.y : l.getData().screenY, e._x = r, e._y = t, o.dispatch({
                        type: "popup:close-all",
                        userData: {
                            x: r,
                            y: t
                        }
                    }), i.classList.add("popup-active"), i.classList.add("transition-active"), o.dispatch({
                        type: "overlay:show",
                        x: r,
                        y: t,
                        speed: a
                    }), o.dispatch({
                        type: "stage:particle-hide"
                    }), setTimeout(function() {
                        u(n, 0, 0, 0), window.scrollTo(0, 0), setTimeout(function() {
                            o.dispatch({
                                type: "stage:reset"
                            }), o.dispatch({
                                type: "page-transition:check",
                                step: 1
                            })
                        }, 20)
                    }, s)
                }.bind(t), e.end = function(t) {
                    this._decorators[c];
                    var e = document.getElementsByClassName("page-wrapper")[0],
                        i = document.getElementsByTagName("main")[0];
                    this._origianlTransitionElement && (this._origianlTransitionElement.style.visibility = "visible", this._origianlTransitionElement = null), window.scrollTo(0, 0), o.dispatch({
                        type: "overlay:hide",
                        x: l.getData().screenX,
                        y: l.getData().screenY
                    }), o.dispatch({
                        type: "stage:particle-show"
                    }), setTimeout(function() {
                        e.classList.remove("popup-active"), e.classList.remove("transition-active"), u(i, 1, .6, 0), o.dispatch({
                            type: "page-transition:check",
                            step: 3
                        })
                    }, 600)
                }.bind(t), t._transitions.basic = {
                    start: e.start,
                    end: e.end
                }
            },
            detach: function(t) {
                t._decorators[c]
            }
        }
    }
    console.warn('error. decorator with name "' + c + '" already registered')
}), define("router/page-transition.component", ["dispatcher", "router/transitions/basic-transition.decorator", "scroll/scroll.store", "parallax/parallax.store", "utils"], function(t, e, l, h, c) {
    "use strict";
    var i = Object.create(HTMLElement.prototype);
    i.createdCallback = function() {
        this.handleDispatcher = function(t) {
            "page-transition:start" === t.type && (t.transitionData || (t.transitionData = {}), t.transitionData.animation || (t.transitionData.animation = "basic"), this._transitions[t.transitionData.animation].start(t.transitionData)), "page-transition:end" === t.type && (t.transitionData || (t.transitionData = {}), t.transitionData.animation || (t.transitionData.animation = "basic"), this._transitions[t.transitionData.animation].end(t.transitionData))
        }.bind(this), this.copyElement = function(t) {
            var e, i, n, r, s = t.cloneNode(!0),
                a = getComputedStyle(t),
                o = this._inner || this;
            t.classList.contains("arr-btn") ? (i = (e = c.offset(t)).top + l.getData().top, n = e.left, r = h.getData().transformationMatrix, this._inner && r && (this._inner.style.transform = "matrix3d(" + r.elements.join(",") + ")")) : (this._inner.style.transform = "none", i = (e = t.getBoundingClientRect()).top, n = e.left), s.style.position = "fixed", s.style.left = n + "px", s.style.top = i + "px", s.classList.add("fake"), s.style.fontFamily = a.fontFamily, s.style.fontSize = a.fontSize, s.style.fontWeight = a.fontWeight, s.style.color = a.color, s.style.textTransform = a.textTransform, s.style.letterSpacing = a.letterSpacing, s.style.lineHeight = a.lineHeight, setTimeout(function() {
                s.classList.add("fake-animate"), setTimeout(function() {
                    s.parentNode.removeChild(s)
                }, 1e3)
            }, 20), o.appendChild(s), this._fake = s
        }.bind(this), this._transitions = {}, this._inner = this.getElementsByClassName("inner")[0]
    }, i.attachedCallback = function() {
        e.attach(this), t.subscribe("page-transition", this.handleDispatcher)
    }, i.detachedCallback = function() {
        e.detach(this), t.unsubscribe("page-transition", this.handleDispatcher)
    }, document.registerElement("page-transition", {
        prototype: i
    })
}), define("scroll/scroll-blocker-css.view", ["dispatcher"], function(i) {
    "use strict";

    function n(i) {
        Array.prototype.forEach.call(t, function(t) {
            var e = t.getAttribute("data-indent") || "margin";
            i < 0 && (i = 0), "padding" === e ? t.style.paddingRight = i + "px" : "margin" === e ? t.style.marginRight = i + "px" : "right" === e && (t.style.right = i + "px")
        })
    }
    var r, s, t, a;
    r = document.getElementsByTagName("body")[0], s = document.getElementsByClassName("page-wrapper")[0], t = document.getElementsByClassName("fixed"), a = document.getElementsByClassName("fake-scrollbar")[0], i.subscribe(function(t) {
        var e;
        "scroll:block" === t.type && (e = s.clientWidth, r.classList.add("prevent-scroll"), 0 != (e = s.clientWidth - e) && (a && (a.style.width = e + "px", a.style.display = "block"), n(e), i.dispatch({
            type: "resize:store-fire"
        }))), "scroll:unblock" === t.type && function() {
            s.clientWidth;
            r.classList.remove("prevent-scroll"), a && (a.style.width = "0px", a.style.display = "none"), n(0), i.dispatch({
                type: "resize:store-fire"
            })
        }()
    })
}), define("form/form.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
    "use strict";

    function i(t) {
        if ("form-add" === t.type && (r[t.id] = {
                id: t.id,
                status: "waiting"
            }), "form-remove" === t.type) {
            if (!r.hasOwnProperty(t.id)) return;
            delete r[t.id]
        }
        if ("form-send" === t.type) {
            if (!r.hasOwnProperty(t.id)) return;
            if ("sending" === r[t.id].status) return;
            r[t.id].status = "sending", n.dispatch()
        }
        if ("form-submit" === t.type) {
            if (!r.hasOwnProperty(t.id)) return;
            if ("submitted" === r[t.id].status) return;
            r[t.id].status = "submitted", n.dispatch()
        }
        "form-reset" === t.type && r.hasOwnProperty(t.id) && "waiting" !== r[t.id].status && (r[t.id].status = "waiting", n.dispatch())
    }
    var n = new e,
        r = {};
    return t.subscribe(i), {
        subscribe: n.subscribe.bind(n),
        unsubscribe: n.unsubscribe.bind(n),
        getData: function() {
            return {
                items: r
            }
        }
    }
}), define("utils/HTTP", [], function() {
    "use strict";
    return function(i) {
        var n = function(o, l, h, c) {
            return new Promise(function(t, e) {
                var i, n, r, s, a = new XMLHttpRequest;
                if (a.onload = function() {
                        200 <= this.status && this.status < 300 ? t(this.response) : (console.warn("xhr status error (╯ಠ_ಠ)╯︵ ┻━┻"), e(this.statusText))
                    }, a.onerror = function() {
                        console.warn("xhr error (╯ಠ_ಠ)╯︵ ┻━┻"), e(this.statusText)
                    }, h) {
                    if (c && "urlencoded" !== c) "json" === c && (n = {}, h.forEach(function(t, e) {
                        n[e] = t
                    }), n = JSON.stringify(n));
                    else
                        for (s in i = "", r = 0, h) h.hasOwnProperty(s) && (r++ && (i += "&"), i += encodeURIComponent(s) + "=" + encodeURIComponent(h[s]));
                    "GET" === o || "DELETE" === o ? (a.open(o, l + "?" + i), a.setRequestHeader("X-Requested-With", "XMLHttpRequest"), a.send()) : (a.open(o, l), a.setRequestHeader("X-Requested-With", "XMLHttpRequest"), "json" === c ? (a.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), a.send(n)) : "urlencoded" === c ? (a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), a.send(i)) : a.send(h))
                } else a.open(o, l), a.setRequestHeader("X-Requested-With", "XMLHttpRequest"), a.send()
            })
        };
        return {
            get: function(t, e) {
                return n("GET", i, t, e)
            },
            post: function(t, e) {
                return n("POST", i, t, e)
            },
            put: function(t, e) {
                return n("PUT", i, t, e)
            },
            delete: function(t, e) {
                return n("DELETE", i, t, e)
            }
        }
    }
}), define("form/form.component", ["dispatcher", "form/form.store", "utils/HTTP", "config"], function(n, e, r, t) {
    "use strict";
    var i = Object.create(HTMLFormElement.prototype),
        s = 0;
    i.createdCallback = function() {
        this._status = null, this._valid = !0, this.handleSubmit = function(t) {
            var e = this.action,
                i = this;
            FormData && (t.preventDefault(), this.validate(), "waiting" === this._status && (n.dispatch({
                type: "form-validate",
                id: this._id
            }), (t = new FormData(this)).append("ajax", !0), this._valid && (n.dispatch({
                type: "form-send",
                id: this._id
            }), r(e)[this._method](t).then(function(t) {
                t = JSON.parse(t);
                n.dispatch({
                    type: "form-submit",
                    id: i._id,
                    response: t
                }), n.dispatch({
                    type: "form-response",
                    response: t,
                    id: i._id
                }), t.hasOwnProperty("status") && "success" === t.status ? i.classList.add("hidden") : t.hasOwnProperty("status") && "error" !== t.status && "success-reset" !== t.status || (i.classList.add("hidden"), setTimeout(function() {
                    i.classList.remove("hidden"), n.dispatch({
                        type: "form-reset",
                        id: i._id
                    })
                }, 3e3))
            }, function(t) {
                console.warn("Error " + t)
            }))))
        }.bind(this), this.handleStore = function() {
            var t = e.getData().items[this._id];
            t && t.status !== this._status && (this._status = t.status, this.classList.remove("waiting"), this.classList.remove("sending"), this.classList.remove("submitted"), this.classList.add(this._status))
        }.bind(this), this.validate = function() {
            this._valid = !0
        }.bind(this), this.invalidate = function() {
            this._valid = !1
        }.bind(this)
    }, i.attachedCallback = function() {
        this._id = this.getAttribute("data-id"), this._method = this.getAttribute("methog"), this._method || (t.dev ? this._method = "get" : this._method = "post"), this._id || (s++, this._id = "form-" + s, this.setAttribute("data-id", this._id)), n.dispatch({
            type: "form-add",
            id: this._id
        }), this.handleStore(), this.addEventListener("submit", this.handleSubmit), e.subscribe(this.handleStore)
    }, i.detachedCallback = function() {
        this.removeEventListener("submit", this.handleSubmit), e.unsubscribe(this.handleStore)
    }, document.registerElement("form-component", {
        prototype: i,
        extends: "form"
    })
}), define("form/input-wrapper.component", ["dispatcher", "utils"], function(e, t) {
    "use strict";
    var i = Object.create(HTMLLabelElement.prototype);
    i.createdCallback = function() {
        this.handleDispatcher = function(t) {
            var e = null,
                i = !1;
            "form-validate" === t.type && t.id === this._id && (t = this._input.getAttribute("data-required-group"), "checkbox" === this._input.type ? null !== this._input.getAttribute("required") && (this._input.checked ? this._input.value = "1" : (this._input.value = "0", this.classList.add("error"), e = "required")) : (null !== this._input.getAttribute("required") && (this._input.value || (this.classList.add("error"), e = "required")), t && (document.querySelectorAll('input[data-required-group="' + t + '"]').forEach(function(t) {
                t.value && (i = !0)
            }), i || (e = "required"))), e && (this._form.invalidate(), this.showError(e)))
        }.bind(this), this.handleInput = function() {
            this.classList.remove("error"), this._input.removeAttribute("aria-invalid"), "" !== this._input.value ? this.classList.add("not-empty") : this.classList.remove("not-empty")
        }.bind(this), this.handleFocus = function() {
            this.classList.remove("error"), this.classList.add("focus")
        }.bind(this), this.handleBlur = function() {
            this.classList.remove("focus")
        }.bind(this), this.handleChange = function() {
            this.classList.remove("error")
        }.bind(this), this.showError = function(t) {
            this.classList.add("error"), this._input.setAttribute("aria-invalid", !0)
        }.bind(this)
    }, i.attachedCallback = function() {
        var t;
        this._form = this.closest("form"), this._input = this.getElementsByTagName("input")[0], this._input || (this._input = this.getElementsByTagName("textarea")[0]), this._input || (this._input = this.parentNode.getElementsByTagName("input")[0]), this._input && (this._id = this.getAttribute("data-id"), this._id || (t = this.closest("form"), this._id = t.getAttribute("data-id")), this._requiredError = this._input.getAttribute("data-required-error"), this._invalidError = this._input.getAttribute("data-invalid-error"), "checkbox" === this._input.type ? this._input.addEventListener("change", this.handleChange) : (this._input.addEventListener("input", this.handleInput), this._input.addEventListener("focus", this.handleFocus), this._input.addEventListener("blur", this.handleBlur)), e.subscribe(this.handleDispatcher))
    }, i.detachedCallback = function() {
        "checkbox" === this._input.type ? this._input.removeEventListener("change", this.handleChange) : (this._input.removeEventListener("input", this.handleInput), this._input.removeEventListener("focus", this.handleFocus), this._input.removeEventListener("blur", this.handleBlur)), e.unsubscribe(this.handleDispatcher)
    }, document.registerElement("input-wrapper", {
        prototype: i,
        extends: "label"
    })
}), define("form/form-response.component", ["dispatcher"], function(t) {
    "use strict";
    var e = Object.create(HTMLElement.prototype);
    e.createdCallback = function() {
        this.handleForm = function(t) {
            if ("form-response" === t.type) {
                if (t.id !== this._id) return;
                t.response.hasOwnProperty("response") && "" !== t.response.response ? (this._inner.innerHTML = t.response.response, "success" === t.response.status && (this.classList.remove("status-error"), this.classList.add("status-success"), this.classList.add("active")), "error" === t.response.status && (this._inner.innerHTML = t.response.response, this.classList.add("status-error"), this.classList.remove("status-success"), this.classList.add("active"))) : (this._inner.innerHTML = "", this.classList.remove("active"))
            }
            "form-reset" === t.type && t.id === this._id && (this._inner.innerHTML = "", this.classList.remove("active"))
        }.bind(this)
    }, e.attachedCallback = function() {
        this._id = this.getAttribute("data-id"), this._inner = this.getElementsByClassName("response-inner")[0], this._inner || (this._inner = this), this._id ? t.subscribe(this.handleForm) : console.warn("data-id attribute is missing on form-response")
    }, e.detachedCallback = function() {
        t.unsubscribe(this.handleForm)
    }, document.registerElement("form-response", {
        prototype: e
    })
}), define("slider/slider.store", ["dispatcher", "utils/EventEmitter"], function(t, e) {
    "use strict";

    function i(t) {
        if ("slider:add" === t.type) {
            if (r[t.id]) return;
            r[t.id] = {
                id: t.id,
                total: t.total || 0,
                index: t.index || 0,
                continuous: t.continuous || !1
            }, n.dispatch()
        }
        if ("slider:update" === t.type) {
            if (!r[t.id]) return;
            r[t.id].total = t.total, r[t.id].index = t.index, r[t.id].continuous = t.continuous || !1, n.dispatch()
        }
        if ("slider:remove" === t.type) {
            if (!r[t.id]) return;
            delete r[t.id]
        }
        if ("slider:next" === t.type) {
            if (!r.hasOwnProperty(t.id)) return;
            r[t.id].index++, r[t.id].continuous ? r[t.id].index > r[t.id].total - 1 && (r[t.id].index = 0) : r[t.id].index > r[t.id].total - 1 && (r[t.id].index = r[t.id].total - 1), n.dispatch()
        }
        if ("slider:prev" === t.type) {
            if (!r.hasOwnProperty(t.id)) return;
            r[t.id].index--, r[t.id].continuous ? r[t.id].index < 0 && (r[t.id].index = r[t.id].total - 1) : r[t.id].index < 0 && (r[t.id].index = 0), n.dispatch()
        }
        "slider:to" === t.type && r.hasOwnProperty(t.id) && r[t.id].index !== t.index && (t.index > r[t.id].total - 1 || t.index < 0 || (r[t.id].index = t.index, n.dispatch()))
    }
    var n = new e,
        r = {};
    return t.subscribe(i), {
        subscribe: n.subscribe.bind(n),
        unsubscribe: n.unsubscribe.bind(n),
        getData: function() {
            return r
        }
    }
}), define("slider/text-slider.component", ["dispatcher", "slider/slider.store"], function(t, e) {
    "use strict";
    var i = Object.create(HTMLElement.prototype);
    i.createdCallback = function() {
        this._index = 0, this.handleStore = function() {
            var t = e.getData()[this._id];
            this._index !== t.index && (this._index = t.index, this._inner.innerHTML = this._data[this._index].innerHTML)
        }.bind(this)
    }, i.attachedCallback = function() {
        this._data = this.getElementsByClassName("data-item"), this._inner = this.getElementsByClassName("inner")[0], this._total = this._data.length, this._id = this.getAttribute("data-id"), this._inner.innerHTML = this._data[0].innerHTML, t.dispatch({
            type: "slider:add",
            id: this._id,
            total: this._total,
            index: this._index
        }), e.subscribe(this.handleStore)
    }, i.detachedCallback = function() {
        e.unsubscribe(this.handleStore)
    }, document.registerElement("text-slider", {
        prototype: i
    })
}), define("slider/slider-hover-group.component", ["dispatcher", "slider/slider.store"], function(n, r) {
    "use strict";
    var t = Object.create(HTMLElement.prototype);
    t.createdCallback = function() {
        this._index = null, this.handleStore = function() {
            var t = r.getData()[this._id];
            t && (t.index === this._index && !force || (this._items[this._index] && (this._items[this._index].classList.remove("active"), this._items[this._index].classList.add("cursor-interactive")), this._index = t.index || 0, this._items[this._index] && (this._items[this._index].classList.add("active"), this._items[this._index].classList.remove("cursor-interactive"))))
        }.bind(this), this.handleMouseenter = function(t, e) {
            var i = r.getData()[this._id];
            i && i.index !== e && n.dispatch({
                type: "slider:to",
                id: this._id,
                index: e
            })
        }.bind(this)
    }, t.attachedCallback = function() {
        var i = this;
        this._items = this.getElementsByClassName("item"), this._id = this.getAttribute("data-id"), Array.prototype.forEach.call(this._items, function(t, e) {
            t.addEventListener("mouseenter", function() {
                i.handleMouseenter(t, e)
            }), t.addEventListener("click", function() {
                i.handleMouseenter(t, e)
            })
        }), this.handleStore(), r.subscribe(this.handleStore)
    }, t.detachedCallback = function() {
        r.unsubscribe(this.handleStore)
    }, document.registerElement("slider-hover-group", {
        prototype: t
    })
}), define("slider/slider-control-group.component", ["dispatcher", "slider/slider.store"], function(r, s) {
    "use strict";
    var t = Object.create(HTMLElement.prototype);
    return t.createdCallback = function() {
        this._index = 0, this.handleStore = function() {
            var t = s.getData()[this._id];
            t && t.index !== this._index && (this._items[this._index] && (this._items[this._index].classList.remove("active"), this._items[this._index].classList.add("cursor-interactive")), this._index = t.index, this._items[this._index] && (this._items[this._index].classList.add("active"), this._items[this._index].classList.remove("cursor-interactive")))
        }.bind(this), this.handleClick = function(t, i) {
            var n = this;
            t.addEventListener("click", function(t) {
                var e = s.getData()[n._id];
                e && e.index !== i && r.dispatch({
                    type: "slider:to",
                    id: n._id,
                    index: i
                })
            })
        }.bind(this)
    }, t.attachedCallback = function() {
        this._items = this.getElementsByClassName("item"), this._id = this.getAttribute("data-id"), Array.prototype.forEach.call(this._items, this.handleClick), this.handleStore(), s.subscribe(this.handleStore)
    }, t.detachedCallback = function() {
        s.unsubscribe(this.handleStore)
    }, document.registerElement("slider-control-group", {
        prototype: t
    }), t
}), define("slider/slider-accordeon-control.component", ["dispatcher", "drop-down/accordeon.component", "slider/slider-control-group.component"], function(t, e, i) {
    "use strict";
    var n = Object.create(HTMLElement.prototype);
    n.createdCallback = function() {
        e.createdCallback.apply(this), i.createdCallback.apply(this)
    }, n.attachedCallback = function() {
        e.attachedCallback.apply(this), i.attachedCallback.apply(this)
    }, n.detachedCallback = function() {
        e.detachedCallback.apply(this), i.detachedCallback.apply(this)
    }, document.registerElement("accordeon-control-group", {
        prototype: n
    })
});
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";

        function _(t, e, i, n) {
            this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
        }

        function y(t, e, i, n) {
            var r = {
                    a: t
                },
                s = {},
                a = {},
                o = {
                    c: n
                },
                l = (t + e) / 2,
                h = (i + n) / 2,
                c = ((i = ((c = (e + i) / 2) + h) / 2) - (e = (l + c) / 2)) / 8;
            return r.b = l + (t - l) / 4, s.b = e + c, r.c = s.a = (r.b + s.b) / 2, s.c = a.a = (e + i) / 2, a.b = i - c, o.b = h + (n - h) / 4, a.c = o.a = (a.b + o.b) / 2, [r, s, a, o]
        }

        function d(t, e, i, n, r, s) {
            var a, o, l, h, c, u, d, p, f = {},
                m = [],
                g = s || t[0];
            for (o in r = "string" == typeof r ? "," + r + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == e && (e = 1), t[0]) m.push(o);
            if (1 < t.length) {
                for (p = t[t.length - 1], d = !0, a = m.length; - 1 < --a;)
                    if (o = m[a], .05 < Math.abs(g[o] - p[o])) {
                        d = !1;
                        break
                    }
                d && (t = t.concat(), s && t.unshift(s), t.push(t[1]), s = t[t.length - 3])
            }
            for (x.length = b.length = w.length = 0, a = m.length; - 1 < --a;) o = m[a], v[o] = -1 !== r.indexOf("," + o + ","), f[o] = function(t, e, i, n) {
                var r, s, a, o, l, h, c = [];
                if (n)
                    for (s = (t = [n].concat(t)).length; - 1 < --s;) "string" == typeof(h = t[s][e]) && "=" === h.charAt(1) && (t[s][e] = n[e] + Number(h.charAt(0) + h.substr(2)));
                if ((r = t.length - 2) < 0) return c[0] = new _(t[0][e], 0, 0, t[r < -1 ? 0 : 1][e]), c;
                for (s = 0; s < r; s++) a = t[s][e], o = t[s + 1][e], c[s] = new _(a, 0, 0, o), i && (l = t[s + 2][e], x[s] = (x[s] || 0) + (o - a) * (o - a), b[s] = (b[s] || 0) + (l - o) * (l - o));
                return c[s] = new _(t[s][e], 0, 0, t[s + 1][e]), c
            }(t, o, v[o], s);
            for (a = x.length; - 1 < --a;) x[a] = Math.sqrt(x[a]), b[a] = Math.sqrt(b[a]);
            if (!n) {
                for (a = m.length; - 1 < --a;)
                    if (v[o])
                        for (u = (l = f[m[a]]).length - 1, h = 0; h < u; h++) c = l[h + 1].da / b[h] + l[h].da / x[h], w[h] = (w[h] || 0) + c * c;
                for (a = w.length; - 1 < --a;) w[a] = Math.sqrt(w[a])
            }
            for (a = m.length, h = i ? 4 : 1; - 1 < --a;)(function(t, e, i, n, r) {
                for (var s, a, o, l, h, c, u, d, p, f = t.length - 1, m = 0, g = t[0].a, v = 0; v < f; v++) s = (o = t[m]).a, a = o.d, h = t[m + 1].d, h = r ? (u = x[v], p = ((d = b[v]) + u) * e * .25 / (!n && w[v] || .5), a - ((l = a - (a - s) * (n ? .5 * e : 0 !== u ? p / u : 0)) + (((p = a + (h - a) * (n ? .5 * e : 0 !== d ? p / d : 0)) - l) * (3 * u / (u + d) + .5) / 4 || 0))) : a - ((l = a - (a - s) * e * .5) + (p = a + (h - a) * e * .5)) / 2, l += h, p += h, o.c = h = l, o.b = 0 !== v ? g : g = o.a + .6 * (o.c - o.a), o.da = a - s, o.ca = h - s, o.ba = g - s, i ? (c = y(s, g, h, a), t.splice(m, 1, c[0], c[1], c[2], c[3]), m += 4) : m++, g = p;
                (o = t[m]).b = g, o.c = g + .4 * (o.d - g), o.da = o.d - o.a, o.ca = o.c - o.a, o.ba = g - o.a, i && (c = y(o.a, g, o.c, o.d), t.splice(m, 1, c[0], c[1], c[2], c[3]))
            })(l = f[o = m[a]], e, i, n, v[o]), d && (l.splice(0, h), l.splice(l.length - h, h));
            return f
        }
        var T, x, b, w, v, e, g, t;
        _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(n, c, g) {
            function v(t) {
                for (var e = [], i = t.length, n = 0; n !== i; e.push(t[n++]));
                return e
            }

            function _(t, e, i) {
                var n, r, s = t.cycle;
                for (n in s) r = s[n], t[n] = "function" == typeof r ? r.call(e[i], i) : r[i % r.length];
                delete t.cycle
            }
            var y = function(t, e, i) {
                    g.call(this, t, e, i), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = y.prototype.render
                },
                m = 1e-10,
                x = g._internals,
                b = x.isSelector,
                w = x.isArray,
                t = y.prototype = g.to({}, .1, {}),
                T = [];
            y.version = "1.18.0", t.constructor = y, t.kill()._gc = !1, y.killTweensOf = y.killDelayedCallsTo = g.killTweensOf, y.getTweensOf = g.getTweensOf, y.lagSmoothing = g.lagSmoothing, y.ticker = g.ticker, y.render = g.render, t.invalidate = function() {
                return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), g.prototype.invalidate.call(this)
            }, t.updateTo = function(t, e) {
                var i, n = this.ratio,
                    r = this.vars.immediateRender || t.immediateRender;
                for (i in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[i] = t[i];
                if (this._initted || r)
                    if (e) this._initted = !1, r && this.render(0, !0, !0);
                    else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && g._onPluginEvent("_onDisable", this), .998 < this._time / this._duration) {
                    e = this._time;
                    this.render(0, !0, !1), this._initted = !1, this.render(e, !0, !1)
                } else if (0 < this._time || r) {
                    this._initted = !1, this._init();
                    for (var s, a = 1 / (1 - n), o = this._firstPT; o;) s = o.s + o.c, o.c *= a, o.s = s - o.c, o = o._next
                }
                return this
            }, t.render = function(t, e, i) {
                this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                var n, r, s, a, o, l, h = this._dirty ? this.totalDuration() : this._totalDuration,
                    c = this._time,
                    u = this._totalTime,
                    d = this._cycle,
                    p = this._duration,
                    f = this._rawPrevTime;
                if (h <= t ? (this._totalTime = h, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = p, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === p && (!this._initted && this.vars.lazy && !i || (this._startTime === this._timeline._duration && (t = 0), (0 === t || f < 0 || f === m) && f !== t && (i = !0, m < f && (r = "onReverseComplete")), this._rawPrevTime = l = !e || t || f === t ? t : m))) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== u || 0 === p && 0 < f) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === p && (!this._initted && this.vars.lazy && !i || (0 <= f && (i = !0), this._rawPrevTime = l = !e || t || f === t ? t : m))), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (o = p + this._repeatDelay, this._cycle = this._totalTime / o >> 0, 0 !== this._cycle && this._cycle === this._totalTime / o && this._cycle--, this._time = this._totalTime - this._cycle * o, this._yoyo && 0 != (1 & this._cycle) && (this._time = p - this._time), this._time > p ? this._time = p : this._time < 0 && (this._time = 0)), this._easeType ? (a = this._time / p, (1 === (h = this._easeType) || 3 === h && .5 <= a) && (a = 1 - a), 3 === h && (a *= 2), 1 === (o = this._easePower) ? a *= a : 2 === o ? a *= a * a : 3 === o ? a *= a * a * a : 4 === o && (a *= a * a * a * a), 1 === h ? this.ratio = 1 - a : 2 === h ? this.ratio = a : this._time / p < .5 ? this.ratio = a / 2 : this.ratio = 1 - a / 2) : this.ratio = this._ease.getRatio(this._time / p)), c !== this._time || i || d !== this._cycle) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = c, this._totalTime = u, this._rawPrevTime = f, this._cycle = d, x.lazyTweens.push(this), void(this._lazy = [t, e]);
                        this._time && !n ? this.ratio = this._ease.getRatio(this._time / p) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== c && 0 <= t && (this._active = !0), 0 === u && (2 === this._initted && 0 < t && this._init(), this._startAt && (0 <= t ? this._startAt.render(t, e, i) : r = r || "_dummyGS"), this.vars.onStart && (0 === this._totalTime && 0 !== p || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                    this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, e, i), e || this._totalTime === u && !n || this._callback("onUpdate")), this._cycle !== d && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === p && this._rawPrevTime === m && l !== m && (this._rawPrevTime = 0)))
                } else u !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
            }, y.to = function(t, e, i) {
                return new y(t, e, i)
            }, y.from = function(t, e, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new y(t, e, i)
            }, y.fromTo = function(t, e, i, n) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new y(t, e, n)
            }, y.staggerTo = y.allTo = function(t, e, i, n, r, s, a) {
                n = n || 0;

                function o() {
                    i.onComplete && i.onComplete.apply(i.onCompleteScope || this, arguments), r.apply(a || i.callbackScope || this, s || T)
                }
                var l, h, c, u, d = i.delay || 0,
                    p = [],
                    f = i.cycle,
                    m = i.startAt && i.startAt.cycle;
                for (w(t) || ("string" == typeof t && (t = g.selector(t) || t), b(t) && (t = v(t))), t = t || [], n < 0 && ((t = v(t)).reverse(), n *= -1), l = t.length - 1, c = 0; c <= l; c++) {
                    for (u in h = {}, i) h[u] = i[u];
                    if (f && _(h, t, c), m) {
                        for (u in m = h.startAt = {}, i.startAt) m[u] = i.startAt[u];
                        _(h.startAt, t, c)
                    }
                    h.delay = d, c === l && r && (h.onComplete = o), p[c] = new y(t[c], e, h), d += n
                }
                return p
            }, y.staggerFrom = y.allFrom = function(t, e, i, n, r, s, a) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, y.staggerTo(t, e, i, n, r, s, a)
            }, y.staggerFromTo = y.allFromTo = function(t, e, i, n, r, s, a, o) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, y.staggerTo(t, e, n, r, s, a, o)
            }, y.delayedCall = function(t, e, i, n, r) {
                return new y(e, 0, {
                    delay: t,
                    onComplete: e,
                    onCompleteParams: i,
                    callbackScope: n,
                    onReverseComplete: e,
                    onReverseCompleteParams: i,
                    immediateRender: !1,
                    useFrames: r,
                    overwrite: 0
                })
            }, y.set = function(t, e) {
                return new y(t, 0, e)
            }, y.isTweening = function(t) {
                return 0 < g.getTweensOf(t, !0).length
            };
            var s = function(t, e) {
                    for (var i = [], n = 0, r = t._first; r;) r instanceof g ? i[n++] = r : (e && (i[n++] = r), n = (i = i.concat(s(r, e))).length), r = r._next;
                    return i
                },
                u = y.getAllTweens = function(t) {
                    return s(n._rootTimeline, t).concat(s(n._rootFramesTimeline, t))
                };
            y.killAll = function(t, e, i, n) {
                null == e && (e = !0), null == i && (i = !0);
                for (var r, s, a = u(0 != n), o = a.length, l = e && i && n, h = 0; h < o; h++) s = a[h], (l || s instanceof c || (r = s.target === s.vars.onComplete) && i || e && !r) && (t ? s.totalTime(s._reversed ? 0 : s.totalDuration()) : s._enabled(!1, !1))
            }, y.killChildTweensOf = function(t, e) {
                if (null != t) {
                    var i, n, r, s, a, o = x.tweenLookup;
                    if ("string" == typeof t && (t = g.selector(t) || t), b(t) && (t = v(t)), w(t))
                        for (s = t.length; - 1 < --s;) y.killChildTweensOf(t[s], e);
                    else {
                        for (r in i = [], o)
                            for (n = o[r].target.parentNode; n;) n === t && (i = i.concat(o[r].tweens)), n = n.parentNode;
                        for (a = i.length, s = 0; s < a; s++) e && i[s].totalTime(i[s].totalDuration()), i[s]._enabled(!1, !1)
                    }
                }
            };

            function r(t, e, i, n) {
                e = !1 !== e, i = !1 !== i;
                for (var r, s, a = u(n = !1 !== n), o = e && i && n, l = a.length; - 1 < --l;) s = a[l], (o || s instanceof c || (r = s.target === s.vars.onComplete) && i || e && !r) && s.paused(t)
            }
            return y.pauseAll = function(t, e, i) {
                r(!0, t, e, i)
            }, y.resumeAll = function(t, e, i) {
                r(!1, t, e, i)
            }, y.globalTimeScale = function(t) {
                var e = n._rootTimeline,
                    i = g.ticker.time;
                return arguments.length ? (t = t || m, e._startTime = i - (i - e._startTime) * e._timeScale / t, e = n._rootFramesTimeline, i = g.ticker.frame, e._startTime = i - (i - e._startTime) * e._timeScale / t, e._timeScale = n._rootTimeline._timeScale = t) : e._timeScale
            }, t.progress = function(t) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
            }, t.totalProgress = function(t) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration()
            }, t.time = function(t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
            }, t.duration = function(t) {
                return arguments.length ? n.prototype.duration.call(this, t) : this._duration
            }, t.totalDuration = function(t) {
                return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
            }, t.repeat = function(t) {
                return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
            }, t.repeatDelay = function(t) {
                return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
            }, t.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, y
        }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(c, u, d) {
            function p(t) {
                u.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                var e, i, n = this.vars;
                for (i in n) e = n[i], _(e) && -1 !== e.join("").indexOf("{self}") && (n[i] = this._swapSelfInParams(e));
                _(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger)
            }

            function f(t) {
                var e, i = {};
                for (e in t) i[e] = t[e];
                return i
            }

            function m(t, e, i) {
                var n, r, s = t.cycle;
                for (n in s) r = s[n], t[n] = "function" == typeof r ? r.call(e[i], i) : r[i % r.length];
                delete t.cycle
            }

            function g(t) {
                for (var e = [], i = t.length, n = 0; n !== i; e.push(t[n++]));
                return e
            }
            var t = d._internals,
                e = p._internals = {},
                v = t.isSelector,
                _ = t.isArray,
                y = t.lazyTweens,
                x = t.lazyRender,
                a = _gsScope._gsDefine.globals,
                r = e.pauseCallback = function() {},
                e = p.prototype = new u;
            return p.version = "1.18.0", e.constructor = p, e.kill()._gc = e._forcingPlayhead = e._hasPause = !1, e.to = function(t, e, i, n) {
                var r = i.repeat && a.TweenMax || d;
                return e ? this.add(new r(t, e, i), n) : this.set(t, i, n)
            }, e.from = function(t, e, i, n) {
                return this.add((i.repeat && a.TweenMax || d).from(t, e, i), n)
            }, e.fromTo = function(t, e, i, n, r) {
                var s = n.repeat && a.TweenMax || d;
                return e ? this.add(s.fromTo(t, e, i, n), r) : this.set(t, n, r)
            }, e.staggerTo = function(t, e, i, n, r, s, a, o) {
                var l, h, c = new p({
                        onComplete: s,
                        onCompleteParams: a,
                        callbackScope: o,
                        smoothChildTiming: this.smoothChildTiming
                    }),
                    u = i.cycle;
                for ("string" == typeof t && (t = d.selector(t) || t), v(t = t || []) && (t = g(t)), (n = n || 0) < 0 && ((t = g(t)).reverse(), n *= -1), h = 0; h < t.length; h++)(l = f(i)).startAt && (l.startAt = f(l.startAt), l.startAt.cycle && m(l.startAt, t, h)), u && m(l, t, h), c.to(t[h], e, l, h * n);
                return this.add(c, r)
            }, e.staggerFrom = function(t, e, i, n, r, s, a, o) {
                return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, s, a, o)
            }, e.staggerFromTo = function(t, e, i, n, r, s, a, o, l) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, s, a, o, l)
            }, e.call = function(t, e, i, n) {
                return this.add(d.delayedCall(0, t, e, i), n)
            }, e.set = function(t, e, i) {
                return i = this._parseTimeOrLabel(i, 0, !0), null == e.immediateRender && (e.immediateRender = i === this._time && !this._paused), this.add(new d(t, 0, e), i)
            }, p.exportRoot = function(t, e) {
                null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0);
                var i, n, r = new p(t),
                    t = r._timeline;
                for (null == e && (e = !0), t._remove(r, !0), r._startTime = 0, r._rawPrevTime = r._time = r._totalTime = t._time, i = t._first; i;) n = i._next, e && i instanceof d && i.target === i.vars.onComplete || r.add(i, i._startTime - i._delay), i = n;
                return t.add(r, 0), r
            }, e.add = function(t, e, i, n) {
                var r, s, a, o, l, h;
                if ("number" != typeof e && (e = this._parseTimeOrLabel(e, 0, !0, t)), !(t instanceof c)) {
                    if (t instanceof Array || t && t.push && _(t)) {
                        for (i = i || "normal", n = n || 0, r = e, s = t.length, a = 0; a < s; a++) _(o = t[a]) && (o = new p({
                            tweens: o
                        })), this.add(o, r), "string" != typeof o && "function" != typeof o && ("sequence" === i ? r = o._startTime + o.totalDuration() / o._timeScale : "start" === i && (o._startTime -= o.delay())), r += n;
                        return this._uncache(!0)
                    }
                    if ("string" == typeof t) return this.addLabel(t, e);
                    if ("function" != typeof t) throw "Cannot add " + t + " into the timeline; it is not a tween, timeline, function, or string.";
                    t = d.delayedCall(0, t)
                }
                if (u.prototype.add.call(this, t, e), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                    for (h = (l = this).rawTime() > t._startTime; l._timeline;) h && l._timeline.smoothChildTiming ? l.totalTime(l._totalTime, !0) : l._gc && l._enabled(!0, !1), l = l._timeline;
                return this
            }, e.remove = function(t) {
                if (t instanceof c) {
                    this._remove(t, !1);
                    var e = t._timeline = t.vars.useFrames ? c._rootFramesTimeline : c._rootTimeline;
                    return t._startTime = (t._paused ? t._pauseTime : e._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this
                }
                if (t instanceof Array || t && t.push && _(t)) {
                    for (var i = t.length; - 1 < --i;) this.remove(t[i]);
                    return this
                }
                return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
            }, e._remove = function(t, e) {
                u.prototype._remove.call(this, t, e);
                e = this._last;
                return e ? this._time > e._startTime + e._totalDuration / e._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
            }, e.append = function(t, e) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
            }, e.insert = e.insertMultiple = function(t, e, i, n) {
                return this.add(t, e || 0, i, n)
            }, e.appendMultiple = function(t, e, i, n) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
            }, e.addLabel = function(t, e) {
                return this._labels[t] = this._parseTimeOrLabel(e), this
            }, e.addPause = function(t, e, i, n) {
                n = d.delayedCall(0, r, i, n || this);
                return n.vars.onComplete = n.vars.onReverseComplete = e, n.data = "isPause", this._hasPause = !0, this.add(n, t)
            }, e.removeLabel = function(t) {
                return delete this._labels[t], this
            }, e.getLabelTime = function(t) {
                return null != this._labels[t] ? this._labels[t] : -1
            }, e._parseTimeOrLabel = function(t, e, i, n) {
                var r;
                if (n instanceof c && n.timeline === this) this.remove(n);
                else if (n && (n instanceof Array || n.push && _(n)))
                    for (r = n.length; - 1 < --r;) n[r] instanceof c && n[r].timeline === this && this.remove(n[r]);
                if ("string" == typeof e) return this._parseTimeOrLabel(e, i && "number" == typeof t && null == this._labels[e] ? t - this.duration() : 0, i);
                if (e = e || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = this.duration());
                else {
                    if (-1 === (r = t.indexOf("="))) return null == this._labels[t] ? i ? this._labels[t] = this.duration() + e : e : this._labels[t] + e;
                    e = parseInt(t.charAt(r - 1) + "1", 10) * Number(t.substr(r + 1)), t = 1 < r ? this._parseTimeOrLabel(t.substr(0, r - 1), 0, i) : this.duration()
                }
                return Number(t) + e
            }, e.seek = function(t, e) {
                return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
            }, e.stop = function() {
                return this.paused(!0)
            }, e.gotoAndPlay = function(t, e) {
                return this.play(t, e)
            }, e.gotoAndStop = function(t, e) {
                return this.pause(t, e)
            }, e.render = function(t, e, i) {
                this._gc && this._enabled(!0, !1);
                var n, r, s, a, o, l, h = this._dirty ? this.totalDuration() : this._totalDuration,
                    c = this._time,
                    u = this._startTime,
                    d = this._timeScale,
                    p = this._paused;
                if (h <= t) this._totalTime = this._time = h, this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", o = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === t || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (o = !0, 1e-10 < this._rawPrevTime && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = h + 1e-4;
                else if (t < 1e-7)
                    if (((this._totalTime = this._time = 0) !== c || 0 === this._duration && 1e-10 !== this._rawPrevTime && (0 < this._rawPrevTime || t < 0 && 0 <= this._rawPrevTime)) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (o = r = !0, a = "onReverseComplete") : 0 <= this._rawPrevTime && this._first && (o = !0), this._rawPrevTime = t;
                    else {
                        if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                            for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                        t = 0, this._initted || (o = !0)
                    }
                else {
                    if (this._hasPause && !this._forcingPlayhead && !e) {
                        if (c <= t)
                            for (n = this._first; n && n._startTime <= t && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (l = n), n = n._next;
                        else
                            for (n = this._last; n && n._startTime >= t && !l;) n._duration || "isPause" === n.data && 0 < n._rawPrevTime && (l = n), n = n._prev;
                        l && (this._time = t = l._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                    }
                    this._totalTime = this._time = this._rawPrevTime = t
                }
                if (this._time !== c && this._first || i || o || l) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== c && 0 < t && (this._active = !0), 0 === c && this.vars.onStart && 0 !== this._time && (e || this._callback("onStart")), this._time >= c)
                        for (n = this._first; n && (s = n._next, !this._paused || p);)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (l === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s;
                    else
                        for (n = this._last; n && (s = n._prev, !this._paused || p);) {
                            if (n._active || n._startTime <= c && !n._paused && !n._gc) {
                                if (l === n) {
                                    for (l = n._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (t - l._startTime) * l._timeScale : (t - l._startTime) * l._timeScale, e, i), l = l._prev;
                                    l = null, this.pause()
                                }
                                n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                            }
                            n = s
                        }
                    this._onUpdate && (e || (y.length && x(), this._callback("onUpdate"))), a && (this._gc || u !== this._startTime && d === this._timeScale || (0 === this._time || h >= this.totalDuration()) && (r && (y.length && x(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                }
            }, e._hasPausedChild = function() {
                for (var t = this._first; t;) {
                    if (t._paused || t instanceof p && t._hasPausedChild()) return !0;
                    t = t._next
                }
                return !1
            }, e.getChildren = function(t, e, i, n) {
                n = n || -9999999999;
                for (var r = [], s = this._first, a = 0; s;) s._startTime < n || (s instanceof d ? !1 !== e && (r[a++] = s) : (!1 !== i && (r[a++] = s), !1 !== t && (a = (r = r.concat(s.getChildren(!0, e, i))).length))), s = s._next;
                return r
            }, e.getTweensOf = function(t, e) {
                var i, n, r = this._gc,
                    s = [],
                    a = 0;
                for (r && this._enabled(!0, !0), n = (i = d.getTweensOf(t)).length; - 1 < --n;)(i[n].timeline === this || e && this._contains(i[n])) && (s[a++] = i[n]);
                return r && this._enabled(!1, !0), s
            }, e.recent = function() {
                return this._recent
            }, e._contains = function(t) {
                for (var e = t.timeline; e;) {
                    if (e === this) return !0;
                    e = e.timeline
                }
                return !1
            }, e.shiftChildren = function(t, e, i) {
                i = i || 0;
                for (var n, r = this._first, s = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                if (e)
                    for (n in s) s[n] >= i && (s[n] += t);
                return this._uncache(!0)
            }, e._kill = function(t, e) {
                if (!t && !e) return this._enabled(!1, !1);
                for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; - 1 < --n;) i[n]._kill(t, e) && (r = !0);
                return r
            }, e.clear = function(t) {
                var e = this.getChildren(!1, !0, !0),
                    i = e.length;
                for (this._time = this._totalTime = 0; - 1 < --i;) e[i]._enabled(!1, !1);
                return !1 !== t && (this._labels = {}), this._uncache(!0)
            }, e.invalidate = function() {
                for (var t = this._first; t;) t.invalidate(), t = t._next;
                return c.prototype.invalidate.call(this)
            }, e._enabled = function(t, e) {
                if (t === this._gc)
                    for (var i = this._first; i;) i._enabled(t, !0), i = i._next;
                return u.prototype._enabled.call(this, t, e)
            }, e.totalTime = function(t, e, i) {
                this._forcingPlayhead = !0;
                var n = c.prototype.totalTime.apply(this, arguments);
                return this._forcingPlayhead = !1, n
            }, e.duration = function(t) {
                return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
            }, e.totalDuration = function(t) {
                if (arguments.length) return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this;
                if (this._dirty) {
                    for (var e, i, n = 0, r = this._last, s = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > s && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : s = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), s = 0), n < (i = r._startTime + r._totalDuration / r._timeScale) && (n = i), r = e;
                    this._duration = this._totalDuration = n, this._dirty = !1
                }
                return this._totalDuration
            }, e.paused = function(t) {
                if (!t)
                    for (var e = this._first, i = this._time; e;) e._startTime === i && "isPause" === e.data && (e._rawPrevTime = 0), e = e._next;
                return c.prototype.paused.apply(this, arguments)
            }, e.usesFrames = function() {
                for (var t = this._timeline; t._timeline;) t = t._timeline;
                return t === c._rootFramesTimeline
            }, e.rawTime = function() {
                return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
            }, p
        }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(e, a, t) {
            function i(t) {
                e.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
            }
            var n = a._internals,
                M = n.lazyTweens,
                E = n.lazyRender,
                o = new t(null, null, 1, 0),
                t = i.prototype = new e;
            return t.constructor = i, t.kill()._gc = !1, i.version = "1.18.0", t.invalidate = function() {
                return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), e.prototype.invalidate.call(this)
            }, t.addCallback = function(t, e, i, n) {
                return this.add(a.delayedCall(0, t, i, n), e)
            }, t.removeCallback = function(t, e) {
                if (t)
                    if (null == e) this._kill(null, t);
                    else
                        for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); - 1 < --n;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                return this
            }, t.removePause = function(t) {
                return this.removeCallback(e._internals.pauseCallback, t)
            }, t.tweenTo = function(t, e) {
                e = e || {};
                var i, n, r, s = {
                    ease: o,
                    useFrames: this.usesFrames(),
                    immediateRender: !1
                };
                for (n in e) s[n] = e[n];
                return s.time = this._parseTimeOrLabel(t), i = Math.abs(Number(s.time) - this._time) / this._timeScale || .001, r = new a(this, i, s), s.onStart = function() {
                    r.target.paused(!0), r.vars.time !== r.target.time() && i === r.duration() && r.duration(Math.abs(r.vars.time - r.target.time()) / r.target._timeScale), e.onStart && r._callback("onStart")
                }, r
            }, t.tweenFromTo = function(t, e, i) {
                i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                    onComplete: this.seek,
                    onCompleteParams: [t],
                    callbackScope: this
                }, i.immediateRender = !1 !== i.immediateRender;
                i = this.tweenTo(e, i);
                return i.duration(Math.abs(i.vars.time - t) / this._timeScale || .001)
            }, t.render = function(t, e, i) {
                this._gc && this._enabled(!0, !1);
                var n, r, s, a, o, l, h = this._dirty ? this.totalDuration() : this._totalDuration,
                    c = this._duration,
                    u = this._time,
                    d = this._totalTime,
                    p = this._startTime,
                    f = this._timeScale,
                    m = this._rawPrevTime,
                    g = this._paused,
                    v = this._cycle;
                if (h <= t) this._locked || (this._totalTime = h, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", o = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === t || m < 0 || 1e-10 === m) && m !== t && this._first && (o = !0, 1e-10 < m && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : t = (this._time = c) + 1e-4;
                else if (t < 1e-7)
                    if (this._locked || (this._totalTime = this._cycle = 0), ((this._time = 0) !== u || 0 === c && 1e-10 !== m && (0 < m || t < 0 && 0 <= m) && !this._locked) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (o = r = !0, a = "onReverseComplete") : 0 <= m && this._first && (o = !0), this._rawPrevTime = t;
                    else {
                        if (this._rawPrevTime = c || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                            for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                        t = 0, this._initted || (o = !0)
                    }
                else if (0 === c && m < 0 && (o = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (T = c + this._repeatDelay, this._cycle = this._totalTime / T >> 0, 0 !== this._cycle && this._cycle === this._totalTime / T && this._cycle--, this._time = this._totalTime - this._cycle * T, this._yoyo && 0 != (1 & this._cycle) && (this._time = c - this._time), this._time > c ? t = (this._time = c) + 1e-4 : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                    if (u <= (t = this._time))
                        for (n = this._first; n && n._startTime <= t && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (l = n), n = n._next;
                    else
                        for (n = this._last; n && n._startTime >= t && !l;) n._duration || "isPause" === n.data && 0 < n._rawPrevTime && (l = n), n = n._prev;
                    l && (this._time = t = l._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                }
                if (this._cycle !== v && !this._locked) {
                    var _ = this._yoyo && 0 != (1 & v),
                        y = _ === (this._yoyo && 0 != (1 & this._cycle)),
                        x = this._totalTime,
                        b = this._cycle,
                        w = this._rawPrevTime,
                        T = this._time;
                    if (this._totalTime = v * c, this._cycle < v ? _ = !_ : this._totalTime += c, this._time = u, this._rawPrevTime = 0 === c ? m - 1e-4 : m, this._cycle = v, this._locked = !0, u = _ ? 0 : c, this.render(u, e, 0 === c), e || this._gc || this.vars.onRepeat && this._callback("onRepeat"), y && (u = _ ? c + 1e-4 : -1e-4, this.render(u, !0, !1)), this._locked = !1, this._paused && !g) return;
                    this._time = T, this._totalTime = x, this._cycle = b, this._rawPrevTime = w
                }
                if (this._time !== u && this._first || i || o || l) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== d && 0 < t && (this._active = !0), 0 === d && this.vars.onStart && 0 !== this._totalTime && (e || this._callback("onStart")), this._time >= u)
                        for (n = this._first; n && (s = n._next, !this._paused || g);)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (l === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s;
                    else
                        for (n = this._last; n && (s = n._prev, !this._paused || g);) {
                            if (n._active || n._startTime <= u && !n._paused && !n._gc) {
                                if (l === n) {
                                    for (l = n._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (t - l._startTime) * l._timeScale : (t - l._startTime) * l._timeScale, e, i), l = l._prev;
                                    l = null, this.pause()
                                }
                                n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                            }
                            n = s
                        }
                    this._onUpdate && (e || (M.length && E(), this._callback("onUpdate"))), a && (this._locked || this._gc || p !== this._startTime && f === this._timeScale || (0 === this._time || h >= this.totalDuration()) && (r && (M.length && E(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                } else d !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
            }, t.getActive = function(t, e, i) {
                null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                for (var n, r = [], s = this.getChildren(t, e, i), a = 0, o = s.length, l = 0; l < o; l++)(n = s[l]).isActive() && (r[a++] = n);
                return r
            }, t.getLabelAfter = function(t) {
                t || 0 !== t && (t = this._time);
                for (var e = this.getLabelsArray(), i = e.length, n = 0; n < i; n++)
                    if (e[n].time > t) return e[n].name;
                return null
            }, t.getLabelBefore = function(t) {
                null == t && (t = this._time);
                for (var e = this.getLabelsArray(), i = e.length; - 1 < --i;)
                    if (e[i].time < t) return e[i].name;
                return null
            }, t.getLabelsArray = function() {
                var t, e = [],
                    i = 0;
                for (t in this._labels) e[i++] = {
                    time: this._labels[t],
                    name: t
                };
                return e.sort(function(t, e) {
                    return t.time - e.time
                }), e
            }, t.progress = function(t, e) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
            }, t.totalProgress = function(t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
            }, t.totalDuration = function(t) {
                return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
            }, t.time = function(t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
            }, t.repeat = function(t) {
                return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
            }, t.repeatDelay = function(t) {
                return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
            }, t.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, t.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
            }, i
        }, !0), T = 180 / Math.PI, x = [], b = [], w = [], v = {}, e = _gsScope._gsDefine.globals, g = _gsScope._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.4",
            API: 2,
            global: !0,
            init: function(t, e, i) {
                this._target = t, e instanceof Array && (e = {
                    values: e
                }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                var n, r, s, a, o, l = e.values || [],
                    h = {},
                    c = l[0],
                    u = e.autoRotate || i.vars.orientToBezier;
                for (n in this._autoRotate = u ? u instanceof Array ? u : [
                        ["x", "y", "rotation", !0 !== u && Number(u) || 0]
                    ] : null, c) this._props.push(n);
                for (s = this._props.length; - 1 < --s;) n = this._props[s], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], h[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), o || h[n] !== l[0][n] && (o = h);
                if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? d(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : function(t, e, i) {
                        var n, r, s, a, o, l, h, c, u, d, p, f = {},
                            m = "cubic" === (e = e || "soft") ? 3 : 2,
                            g = "soft" === e,
                            v = [];
                        if (g && i && (t = [i].concat(t)), null == t || t.length < 1 + m) throw "invalid Bezier data";
                        for (u in t[0]) v.push(u);
                        for (l = v.length; - 1 < --l;) {
                            for (f[u = v[l]] = o = [], d = 0, c = t.length, h = 0; h < c; h++) n = null == i ? t[h][u] : "string" == typeof(p = t[h][u]) && "=" === p.charAt(1) ? i[u] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && 1 < h && h < c - 1 && (o[d++] = (n + o[d - 2]) / 2), o[d++] = n;
                            for (c = d - m + 1, h = d = 0; h < c; h += m) n = o[h], r = o[h + 1], s = o[h + 2], a = 2 == m ? 0 : o[h + 3], o[d++] = p = 3 == m ? new _(n, r, s, a) : new _(n, (2 * r + n) / 3, (2 * r + s) / 3, s);
                            o.length = d
                        }
                        return f
                    }(l, e.type, h), this._segCount = this._beziers[n].length, this._timeRes && (e = function(t, e) {
                        var i, n, r, s, a = [],
                            o = [],
                            l = 0,
                            h = 0,
                            c = (e = e >> 0 || 6) - 1,
                            u = [],
                            d = [];
                        for (i in t) ! function(t, e, i) {
                            for (var n, r, s, a, o, l, h, c, u, d, p = 1 / i, f = t.length; - 1 < --f;)
                                for (s = (u = t[f]).a, a = u.d - s, o = u.c - s, l = u.b - s, r = 0, h = 1; h <= i; h++) n = r - (r = ((d = p * h) * d * a + 3 * (c = 1 - d) * (d * o + c * l)) * d), e[d = f * i + h - 1] = (e[d] || 0) + n * n
                        }(t[i], a, e);
                        for (r = a.length, n = 0; n < r; n++) l += Math.sqrt(a[n]), d[s = n % e] = l, s == c && (h += l, u[s = n / e >> 0] = d, o[s] = h, l = 0, d = []);
                        return {
                            length: h,
                            lengths: o,
                            segments: u
                        }
                    }(this._beziers, this._timeRes), this._length = e.length, this._lengths = e.lengths, this._segments = e.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length), u = this._autoRotate)
                    for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), s = u.length; - 1 < --s;) {
                        for (a = 0; a < 3; a++) n = u[s][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                        n = u[s][2], this._initialRotations[s] = this._func[n] ? this._func[n].call(this._target) : this._target[n]
                    }
                return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
            },
            set: function(t) {
                var e, i, n, r, s, a, o, l, h, c = this._segCount,
                    u = this._func,
                    d = this._target,
                    p = t !== this._startRatio;
                if (this._timeRes) {
                    if (l = this._lengths, h = this._curSeg, t *= this._length, w = this._li, t > this._l2 && w < c - 1) {
                        for (o = c - 1; w < o && (this._l2 = l[++w]) <= t;);
                        this._l1 = l[w - 1], this._li = w, this._curSeg = h = this._segments[w], this._s2 = h[this._s1 = this._si = 0]
                    } else if (t < this._l1 && 0 < w) {
                        for (; 0 < w && (this._l1 = l[--w]) >= t;);
                        0 === w && t < this._l1 ? this._l1 = 0 : w++, this._l2 = l[w], this._li = w, this._curSeg = h = this._segments[w], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si]
                    }
                    if (e = w, t -= this._l1, w = this._si, t > this._s2 && w < h.length - 1) {
                        for (o = h.length - 1; w < o && (this._s2 = h[++w]) <= t;);
                        this._s1 = h[w - 1], this._si = w
                    } else if (t < this._s1 && 0 < w) {
                        for (; 0 < w && (this._s1 = h[--w]) >= t;);
                        0 === w && t < this._s1 ? this._s1 = 0 : w++, this._s2 = h[w], this._si = w
                    }
                    s = (w + (t - this._s1) / (this._s2 - this._s1)) * this._prec
                } else s = (t - (e = t < 0 ? 0 : 1 <= t ? c - 1 : c * t >> 0) * (1 / c)) * c;
                for (i = 1 - s, w = this._props.length; - 1 < --w;) n = this._props[w], a = (s * s * (r = this._beziers[n][e]).da + 3 * i * (s * r.ca + i * r.ba)) * s + r.a, this._round[n] && (a = Math.round(a)), u[n] ? d[n](a) : d[n] = a;
                if (this._autoRotate)
                    for (var f, m, g, v, _, y, x, b = this._autoRotate, w = b.length; - 1 < --w;) n = b[w][2], y = b[w][3] || 0, x = !0 === b[w][4] ? 1 : T, r = this._beziers[b[w][0]], f = this._beziers[b[w][1]], r && f && (r = r[e], f = f[e], m = r.a + (r.b - r.a) * s, m += ((v = r.b + (r.c - r.b) * s) - m) * s, v += (r.c + (r.d - r.c) * s - v) * s, g = f.a + (f.b - f.a) * s, g += ((_ = f.b + (f.c - f.b) * s) - g) * s, _ += (f.c + (f.d - f.c) * s - _) * s, a = p ? Math.atan2(_ - g, v - m) * x + y : this._initialRotations[w], u[n] ? d[n](a) : d[n] = a)
            }
        }), t = g.prototype, g.bezierThrough = d, g.cubicToQuadratic = y, g._autoCSS = !0, g.quadraticToCubic = function(t, e, i) {
            return new _(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
        }, g._cssRegister = function() {
            var p, f, m, t = e.CSSPlugin;
            t && (t = t._internals, p = t._parseToProxy, f = t._setPluginRatio, m = t.CSSPropTween, t._registerComplexSpecialProp("bezier", {
                parser: function(t, e, i, n, r, s) {
                    e instanceof Array && (e = {
                        values: e
                    }), s = new g;
                    var a, o, l, h = e.values,
                        c = h.length - 1,
                        u = [],
                        d = {};
                    if (c < 0) return r;
                    for (a = 0; a <= c; a++) l = p(t, h[a], n, r, s, c !== a), u[a] = l.end;
                    for (o in e) d[o] = e[o];
                    return d.values = u, (r = new m(t, "bezier", 0, 0, l.pt, 2)).data = l, r.plugin = s, r.setRatio = f, 0 === d.autoRotate && (d.autoRotate = !0), !d.autoRotate || d.autoRotate instanceof Array || (a = !0 === d.autoRotate ? 0 : Number(d.autoRotate), d.autoRotate = null != l.end.left ? [
                        ["left", "top", "rotation", a, !1]
                    ] : null != l.end.x && [
                        ["x", "y", "rotation", a, !1]
                    ]), d.autoRotate && (n._transform || n._enableTransforms(!1), l.autoRotate = n._target._gsTransform), s._onInitTween(l.proxy, d, n._tween), r
                }
            }))
        }, t._roundProps = function(t, e) {
            for (var i = this._overwriteProps, n = i.length; - 1 < --n;)(t[i[n]] || t.bezier || t.bezierThrough) && (this._round[i[n]] = e)
        }, t._kill = function(t) {
            var e, i, n = this._props;
            for (e in this._beziers)
                if (e in t)
                    for (delete this._beziers[e], delete this._func[e], i = n.length; - 1 < --i;) n[i] === e && n.splice(i, 1);
            return this._super._kill.call(this, t)
        }, _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(s, L) {
            var d, w, O, u, D = function() {
                    s.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = D.prototype.setRatio
                },
                h = _gsScope._gsDefine.globals,
                p = {},
                t = D.prototype = new s("css");
            (t.constructor = D).version = "1.18.0", D.API = 2, D.defaultTransformPerspective = 0, D.defaultSkewType = "compensated", D.defaultSmoothOrigin = !0, t = "px", D.suffixMap = {
                top: t,
                right: t,
                bottom: t,
                left: t,
                width: t,
                height: t,
                fontSize: t,
                padding: t,
                margin: t,
                perspective: t,
                lineHeight: ""
            };

            function a(t, e) {
                return e.toUpperCase()
            }

            function o(t) {
                return z.test("string" == typeof t ? t : (t.currentStyle || t.style).filter || "") ? parseFloat(RegExp.$1) / 100 : 1
            }

            function f(t) {
                window.console && console.log(t)
            }

            function T(t, e) {
                var i, n, r = (e = e || J).style;
                if (void 0 !== r[t]) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; - 1 < --n && void 0 === r[i[n] + t];);
                return 0 <= n ? (tt = "-" + (et = 3 === n ? "ms" : i[n]).toLowerCase() + "-", et + t) : null
            }

            function m(t, e) {
                var i, n, r = {};
                if (e = e || it(t, null))
                    if (i = e.length)
                        for (; - 1 < --i;) - 1 !== (n = e[i]).indexOf("-transform") && Pt !== n || (r[n.replace(F, a)] = e.getPropertyValue(n));
                    else
                        for (i in e) - 1 !== i.indexOf("Transform") && At !== i || (r[i] = e[i]);
                else if (e = t.currentStyle || t.style)
                    for (i in e) "string" == typeof i && void 0 === r[i] && (r[i.replace(F, a)] = e[i]);
                return $ || (r.opacity = o(t)), t = zt(t, e, !1), r.rotation = t.rotation, r.skewX = t.skewX, r.scaleX = t.scaleX, r.scaleY = t.scaleY, r.x = t.x, r.y = t.y, Rt && (r.z = t.z, r.rotationX = t.rotationX, r.rotationY = t.rotationY, r.scaleZ = t.scaleZ), r.filters && delete r.filters, r
            }

            function g(t, e, i, n, r) {
                var s, a, o, l = {},
                    h = t.style;
                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (s = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof s && "string" != typeof s || (l[a] = "auto" !== s || "left" !== a && "top" !== a ? "" !== s && "auto" !== s && "none" !== s || "string" != typeof e[a] || "" === e[a].replace(I, "") ? s : 0 : st(t, a), void 0 !== h[a] && (o = new ft(h, a, h[a], o))));
                if (n)
                    for (a in n) "className" !== a && (l[a] = n[a]);
                return {
                    difs: l,
                    firstMPT: o
                }
            }

            function b(t, e) {
                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                null != t && "" !== t || (t = "0 0");
                var i = t.split(" "),
                    n = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0],
                    r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1];
                return null == r ? r = "center" === n ? "50%" : "0" : "center" === r && (r = "50%"), ("center" === n || isNaN(parseFloat(n)) && -1 === (n + "").indexOf("=")) && (n = "50%"), t = n + " " + r + (2 < i.length ? " " + i[2] : ""), e && (e.oxp = -1 !== n.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === n.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(n.replace(I, "")), e.oy = parseFloat(r.replace(I, "")), e.v = t), e || t
            }

            function S(t, e) {
                return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e)
            }

            function M(t, e) {
                return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t)
            }

            function E(t, e, i, n) {
                var r, s = null == t ? e : "number" == typeof t ? t : (r = t.split("_"), s = ((s = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(r[0].substr(2)) : parseFloat(r[0])) * (-1 === t.indexOf("rad") ? 1 : q) - (s ? 0 : e), r.length && (n && (n[i] = e + s), -1 !== t.indexOf("short") && (s %= 360) !== s % 180 && (s = s < 0 ? s + 360 : s - 360), -1 !== t.indexOf("_cw") && s < 0 ? s = (s + 3599999999640) % 360 - 360 * (s / 360 | 0) : -1 !== t.indexOf("ccw") && 0 < s && (s = (s - 3599999999640) % 360 - 360 * (s / 360 | 0))), e + s);
                return s < 1e-6 && -1e-6 < s && (s = 0), s
            }

            function c(t, e, i) {
                return 255 * (6 * (t = t < 0 ? t + 1 : 1 < t ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            }

            function i(t, e) {
                for (var i, n, r = t.match(ct) || [], s = 0, a = r.length ? "" : t, o = 0; o < r.length; o++) i = r[o], s += (n = t.substr(s, t.indexOf(i, s) - s)).length + i.length, 3 === (i = ht(i, e)).length && i.push(1), a += n + (e ? "hsla(" + i[0] + "," + i[1] + "%," + i[2] + "%," + i[3] : "rgba(" + i.join(",")) + ")";
                return a
            }
            var A, v, _, k, y, P, C = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
                R = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                I = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                N = /(?:\d|\-|\+|=|#|\.)*/g,
                z = /opacity *= *([^)]*)/i,
                B = /opacity:([^;]*)/i,
                r = /alpha\(opacity *=.+?\)/i,
                U = /^(rgb|hsl)/,
                l = /([A-Z])/g,
                F = /-([a-z])/gi,
                H = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                G = /(?:Left|Right|Width)/i,
                V = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                j = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                W = /,(?=[^\)]*(?:\(|$))/gi,
                X = Math.PI / 180,
                q = 180 / Math.PI,
                Y = {},
                Z = document,
                e = function(t) {
                    return Z.createElementNS ? Z.createElementNS("http://www.w3.org/1999/xhtml", t) : Z.createElement(t)
                },
                J = e("div"),
                Q = e("img"),
                n = D._internals = {
                    _specialProps: p
                },
                K = navigator.userAgent,
                $ = (Et = K.indexOf("Android"), Mt = e("a"), _ = -1 !== K.indexOf("Safari") && -1 === K.indexOf("Chrome") && (-1 === Et || 3 < Number(K.substr(Et + 8, 1))), y = _ && Number(K.substr(K.indexOf("Version/") + 8, 1)) < 6, k = -1 !== K.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(K) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(K)) && (P = parseFloat(RegExp.$1)), !!Mt && (Mt.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(Mt.style.opacity))),
                tt = "",
                et = "",
                it = Z.defaultView ? Z.defaultView.getComputedStyle : function() {},
                nt = D.getStyle = function(t, e, i, n, r) {
                    var s;
                    return $ || "opacity" !== e ? (!n && t.style[e] ? s = t.style[e] : (i = i || it(t)) ? s = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(l, "-$1").toLowerCase()) : t.currentStyle && (s = t.currentStyle[e]), null == r || s && "none" !== s && "auto" !== s && "auto auto" !== s ? s : r) : o(t)
                },
                rt = n.convertToPixels = function(t, e, i, n, r) {
                    if ("px" === n || !n) return i;
                    if ("auto" === n || !i) return 0;
                    var s, a, o, l = G.test(e),
                        h = t,
                        c = J.style,
                        u = i < 0;
                    if (u && (i = -i), "%" === n && -1 !== e.indexOf("border")) s = i / 100 * (l ? t.clientWidth : t.clientHeight);
                    else {
                        if (c.cssText = "border:0 solid red;position:" + nt(t, "position") + ";line-height:0;", "%" !== n && h.appendChild && "v" !== n.charAt(0) && "rem" !== n) c[l ? "borderLeftWidth" : "borderTopWidth"] = i + n;
                        else {
                            if (a = (h = t.parentNode || Z.body)._gsCache, o = L.ticker.frame, a && l && a.time === o) return a.width * i / 100;
                            c[l ? "width" : "height"] = i + n
                        }
                        h.appendChild(J), s = parseFloat(J[l ? "offsetWidth" : "offsetHeight"]), h.removeChild(J), l && "%" === n && !1 !== D.cacheWidths && ((a = h._gsCache = h._gsCache || {}).time = o, a.width = s / i * 100), 0 !== s || r || (s = rt(t, e, i, n, !0))
                    }
                    return u ? -s : s
                },
                st = n.calculateOffset = function(t, e, i) {
                    if ("absolute" !== nt(t, "position", i)) return 0;
                    var n = "left" === e ? "Left" : "Top",
                        i = nt(t, "margin" + n, i);
                    return t["offset" + n] - (rt(t, e, parseFloat(i), i.replace(N, "")) || 0)
                },
                at = {
                    width: ["Left", "Right"],
                    height: ["Top", "Bottom"]
                },
                ot = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                lt = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    fuchsia: [255, 0, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                },
                ht = D.parseColor = function(t, e) {
                    var i, n, r, s, a, o, l, h;
                    if (t)
                        if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                        else {
                            if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), lt[t]) i = lt[t];
                            else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (s = t.charAt(3)) + s), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                            else if ("hsl" === t.substr(0, 3))
                                if (i = h = t.match(C), e) {
                                    if (-1 !== t.indexOf("=")) return t.match(R)
                                } else a = Number(i[0]) % 360 / 360, o = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), 3 < i.length && (i[3] = Number(t[3])), i[0] = c(a + 1 / 3, n, r), i[1] = c(a, n, r), i[2] = c(a - 1 / 3, n, r);
                            else i = t.match(C) || lt.transparent;
                            i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), 3 < i.length && (i[3] = Number(i[3]))
                        }
                    else i = lt.black;
                    return e && !h && (n = i[0] / 255, r = i[1] / 255, s = i[2] / 255, l = ((t = Math.max(n, r, s)) + (e = Math.min(n, r, s))) / 2, t === e ? a = o = 0 : (h = t - e, o = .5 < l ? h / (2 - t - e) : h / (t + e), a = t === n ? (r - s) / h + (r < s ? 6 : 0) : t === r ? (s - n) / h + 2 : (n - r) / h + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * o + .5 | 0, i[2] = 100 * l + .5 | 0), i
                },
                ct = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
            for (t in lt) ct += "|" + t + "\\b";
            ct = new RegExp(ct + ")", "gi"), D.colorStringFilter = function(t) {
                var e = t[0] + t[1];
                ct.lastIndex = 0, ct.test(e) && (e = -1 !== e.indexOf("hsl(") || -1 !== e.indexOf("hsla("), t[0] = i(t[0], e), t[1] = i(t[1], e))
            }, L.defaultStringFilter || (L.defaultStringFilter = D.colorStringFilter);

            function ut(t, e, s, a) {
                if (null == t) return function(t) {
                    return t
                };
                var o, l = e ? (t.match(ct) || [""])[0] : "",
                    h = t.split(l).join("").match(x) || [],
                    c = t.substr(0, t.indexOf(h[0])),
                    u = ")" === t.charAt(t.length - 1) ? ")" : "",
                    d = -1 !== t.indexOf(" ") ? " " : ",",
                    p = h.length,
                    f = 0 < p ? h[0].replace(C, "") : "";
                return p ? o = e ? function(t) {
                    var e, i, n, r;
                    if ("number" == typeof t) t += f;
                    else if (a && W.test(t)) {
                        for (r = t.replace(W, "|").split("|"), n = 0; n < r.length; n++) r[n] = o(r[n]);
                        return r.join(",")
                    }
                    if (e = (t.match(ct) || [l])[0], n = (i = t.split(e).join("").match(x) || []).length, p > n--)
                        for (; ++n < p;) i[n] = s ? i[(n - 1) / 2 | 0] : h[n];
                    return c + i.join(d) + d + e + u + (-1 !== t.indexOf("inset") ? " inset" : "")
                } : function(t) {
                    var e, i, n;
                    if ("number" == typeof t) t += f;
                    else if (a && W.test(t)) {
                        for (i = t.replace(W, "|").split("|"), n = 0; n < i.length; n++) i[n] = o(i[n]);
                        return i.join(",")
                    }
                    if (n = (e = t.match(x) || []).length, p > n--)
                        for (; ++n < p;) e[n] = s ? e[(n - 1) / 2 | 0] : h[n];
                    return c + e.join(d) + u
                } : function(t) {
                    return t
                }
            }

            function dt(h) {
                return h = h.split(","),
                    function(t, e, i, n, r, s, a) {
                        var o, l = (e + "").split(" ");
                        for (a = {}, o = 0; o < 4; o++) a[h[o]] = l[o] = l[o] || l[(o - 1) / 2 >> 0];
                        return n.parse(t, a, r, s)
                    }
            }
            n._setPluginRatio = function(t) {
                this.plugin.setRatio(t);
                for (var e, i, n, r, s = this.data, a = s.proxy, o = s.firstMPT; o;) e = a[o.v], o.r ? e = Math.round(e) : e < 1e-6 && -1e-6 < e && (e = 0), o.t[o.p] = e, o = o._next;
                if (s.autoRotate && (s.autoRotate.rotation = a.rotation), 1 === t)
                    for (o = s.firstMPT; o;) {
                        if ((i = o.t).type) {
                            if (1 === i.type) {
                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                i.e = r
                            }
                        } else i.e = i.s + i.xs0;
                        o = o._next
                    }
            };

            function pt(t, e, i, n, r, s) {
                return (s = new mt(t, e, i, n - i, r, -1, s)).b = i, s.e = s.xs0 = n, s
            }
            var ft = function(t, e, i, n, r) {
                    this.t = t, this.p = e, this.v = i, this.r = r, n && ((n._prev = this)._next = n)
                },
                mt = (n._parseToProxy = function(t, e, i, n, r, s) {
                    var a, o, l, h, c = n,
                        u = {},
                        d = {},
                        p = i._transform,
                        f = Y;
                    for (i._transform = null, Y = e, n = r = i.parse(t, e, n, r), Y = f, s && (i._transform = p, c && (c._prev = null, c._prev && (c._prev._next = null))); n && n !== c;) {
                        if (n.type <= 1 && (d[o = n.p] = n.s + n.c, u[o] = n.s, s || (h = new ft(n, "s", o, h, n.r), n.c = 0), 1 === n.type))
                            for (a = n.l; 0 < --a;) l = "xn" + a, d[o = n.p + "_" + l] = n.data[l], u[o] = n[l], s || (h = new ft(n, l, o, h, n.rxp[l]));
                        n = n._next
                    }
                    return {
                        proxy: u,
                        end: d,
                        firstMPT: h,
                        pt: r
                    }
                }, n.CSSPropTween = function(t, e, i, n, r, s, a, o, l, h, c) {
                    this.t = t, this.p = e, this.s = i, this.c = n, this.n = a || e, t instanceof mt || u.push(this.n), this.r = o, this.type = s || 0, l && (this.pr = l, d = !0), this.b = void 0 === h ? i : h, this.e = void 0 === c ? i + n : c, r && ((this._next = r)._prev = this)
                }),
                gt = D.parseComplex = function(t, e, i, n, r, s, a, o, l, h) {
                    a = new mt(t, e, 0, 0, a, h ? 2 : 1, null, !1, o, i = i || s || "", n), n += "";
                    var c, u, d, p, f, m, g, v, _, y, x, b, w = i.split(", ").join(",").split(" "),
                        T = n.split(", ").join(",").split(" "),
                        M = w.length,
                        E = !1 !== A;
                    for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (w = w.join(" ").replace(W, ", ").split(" "), T = T.join(" ").replace(W, ", ").split(" "), M = w.length), M !== T.length && (M = (w = (s || "").split(" ")).length), a.plugin = l, a.setRatio = h, c = ct.lastIndex = 0; c < M; c++)
                        if (p = w[c], f = T[c], (v = parseFloat(p)) || 0 === v) a.appendXtra("", v, S(f, v), f.replace(R, ""), E && -1 !== f.indexOf("px"), !0);
                        else if (r && ct.test(p)) x = "," === f.charAt(f.length - 1) ? ")," : ")", b = -1 !== f.indexOf("hsl") && $, p = ht(p, b), f = ht(f, b), (v = 6 < p.length + f.length) && !$ && 0 === f[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(T[c]).join("transparent")) : ($ || (v = !1), b ? a.appendXtra(v ? "hsla(" : "hsl(", p[0], S(f[0], p[0]), ",", !1, !0).appendXtra("", p[1], S(f[1], p[1]), "%,", !1).appendXtra("", p[2], S(f[2], p[2]), v ? "%," : "%" + x, !1) : a.appendXtra(v ? "rgba(" : "rgb(", p[0], f[0] - p[0], ",", !0, !0).appendXtra("", p[1], f[1] - p[1], ",", !0).appendXtra("", p[2], f[2] - p[2], v ? "," : x, !0), v && (p = p.length < 4 ? 1 : p[3], a.appendXtra("", p, (f.length < 4 ? 1 : f[3]) - p, x, !1))), ct.lastIndex = 0;
                    else if (m = p.match(C)) {
                        if (!(g = f.match(R)) || g.length !== m.length) return a;
                        for (u = d = 0; u < m.length; u++) y = m[u], _ = p.indexOf(y, d), a.appendXtra(p.substr(d, _ - d), Number(y), S(g[u], y), "", E && "px" === p.substr(_ + y.length, 2), 0 === u), d = _ + y.length;
                        a["xs" + a.l] += p.substr(d)
                    } else a["xs" + a.l] += a.l ? " " + p : p;
                    if (-1 !== n.indexOf("=") && a.data) {
                        for (x = a.xs0 + a.data.s, c = 1; c < a.l; c++) x += a["xs" + c] + a.data["xn" + c];
                        a.e = x + a["xs" + c]
                    }
                    return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                },
                vt = 9;
            for ((t = mt.prototype).l = t.pr = 0; 0 < --vt;) t["xn" + vt] = 0, t["xs" + vt] = "";
            t.xs0 = "", t._next = t._prev = t.xfirst = t.data = t.plugin = t.setRatio = t.rxp = null, t.appendXtra = function(t, e, i, n, r, s) {
                var a = this,
                    o = a.l;
                return a["xs" + o] += s && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", 0 < o ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new mt(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0)) : (a.data = {
                    s: e + i
                }, a.rxp = {}, a.s = e, a.c = i, a.r = r), a) : (a["xs" + o] += e + (n || ""), a)
            };

            function _t(t, e) {
                e = e || {}, this.p = e.prefix && T(t) || t, (p[t] = p[this.p] = this).format = e.formatter || ut(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
            }
            var yt = n._registerComplexSpecialProp = function(t, e, i) {
                "object" != typeof e && (e = {
                    parser: i
                });
                var n, r = t.split(","),
                    s = e.defaultValue;
                for (i = i || [s], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || s, new _t(r[n], e)
            };
            (t = _t.prototype).parseComplex = function(t, e, i, n, r, s) {
                var a, o, l, h, c, u, d = this.keyword;
                if (this.multi && (W.test(i) || W.test(e) ? (o = e.replace(W, "|").split("|"), l = i.replace(W, "|").split("|")) : d && (o = [e], l = [i])), l) {
                    for (h = (l.length > o.length ? l : o).length, a = 0; a < h; a++) e = o[a] = o[a] || this.dflt, i = l[a] = l[a] || this.dflt, d && (c = e.indexOf(d)) !== (u = i.indexOf(d)) && (-1 === u ? o[a] = o[a].split(d).join("") : -1 === c && (o[a] += " " + d));
                    e = o.join(", "), i = l.join(", ")
                }
                return gt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, s)
            }, t.parse = function(t, e, i, n, r, s, a) {
                return this.parseComplex(t.style, this.format(nt(t, this.p, O, !1, this.dflt)), this.format(e), r, s)
            }, D.registerSpecialProp = function(t, o, l) {
                yt(t, {
                    parser: function(t, e, i, n, r, s, a) {
                        r = new mt(t, i, 0, 0, r, 2, i, !1, l);
                        return r.plugin = s, r.setRatio = o(t, e, n._tween, i), r
                    },
                    priority: l
                })
            }, D.useSVGTransformAttr = _ || k;

            function xt(t, e, i, n, r) {
                var s, a, o, l, h, c, u, d, p, f = t._gsTransform,
                    m = Nt(t, !0);
                f && (d = f.xOrigin, p = f.yOrigin), (!n || (s = n.split(" ")).length < 2) && (h = t.getBBox(), s = [(-1 !== (e = b(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * h.width : parseFloat(e[0])) + h.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * h.height : parseFloat(e[1])) + h.y]), i.xOrigin = a = parseFloat(s[0]), i.yOrigin = o = parseFloat(s[1]), n && m !== It && (l = m[0], h = m[1], e = m[2], c = m[3], n = m[4], c = a * (c / (u = l * c - h * e)) + o * (-e / u) + (e * (e = m[5]) - c * n) / u, u = a * (-h / u) + o * (l / u) - (l * e - h * n) / u, a = i.xOrigin = s[0] = c, o = i.yOrigin = s[1] = u), f && (r || !1 !== r && !1 !== D.defaultSmoothOrigin ? (c = a - d, u = o - p, f.xOffset += c * m[0] + u * m[2] - c, f.yOffset += c * m[1] + u * m[3] - u) : f.xOffset = f.yOffset = 0), t.setAttribute("data-svg-origin", s.join(" "))
            }

            function bt(t) {
                return !!(Ot && "function" == typeof t.getBBox && t.getCTM && (!t.parentNode || t.parentNode.getBBox && t.parentNode.getCTM))
            }

            function wt(t) {
                var e, i, n = this.data,
                    r = (m = -n.rotation * X) + n.skewX * X,
                    s = (Math.cos(m) * n.scaleX * 1e5 | 0) / 1e5,
                    a = (Math.sin(m) * n.scaleX * 1e5 | 0) / 1e5,
                    o = (Math.sin(r) * -n.scaleY * 1e5 | 0) / 1e5,
                    l = (Math.cos(r) * n.scaleY * 1e5 | 0) / 1e5,
                    h = this.t.style,
                    c = this.t.currentStyle;
                if (c) {
                    i = a, a = -o, o = -i, e = c.filter, h.filter = "";
                    var u = this.t.offsetWidth,
                        d = this.t.offsetHeight,
                        p = "absolute" !== c.position,
                        f = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + a + ", M21=" + o + ", M22=" + l,
                        m = n.x + u * n.xPercent / 100,
                        r = n.y + d * n.yPercent / 100;
                    if (null != n.ox && (m += (y = (n.oxp ? u * n.ox * .01 : n.ox) - u / 2) - (y * s + (x = (n.oyp ? d * n.oy * .01 : n.oy) - d / 2) * a), r += x - (y * o + x * l)), f += p ? ", Dx=" + ((y = u / 2) - (y * s + (x = d / 2) * a) + m) + ", Dy=" + (x - (y * o + x * l) + r) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? h.filter = e.replace(j, f) : h.filter = f + " " + e, 0 !== t && 1 !== t || 1 == s && 0 == a && 0 == o && 1 == l && (p && -1 === f.indexOf("Dx=0, Dy=0") || z.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && h.removeAttribute("filter")), !p) {
                        var g, v, _ = P < 8 ? 1 : -1,
                            y = n.ieOffsetX || 0,
                            x = n.ieOffsetY || 0;
                        for (n.ieOffsetX = Math.round((u - ((s < 0 ? -s : s) * u + (a < 0 ? -a : a) * d)) / 2 + m), n.ieOffsetY = Math.round((d - ((l < 0 ? -l : l) * d + (o < 0 ? -o : o) * u)) / 2 + r), vt = 0; vt < 4; vt++) v = (i = -1 !== (v = c[g = ot[vt]]).indexOf("px") ? parseFloat(v) : rt(this.t, g, parseFloat(v), v.replace(N, "")) || 0) !== n[g] ? vt < 2 ? -n.ieOffsetX : -n.ieOffsetY : vt < 2 ? y - n.ieOffsetX : x - n.ieOffsetY, h[g] = (n[g] = Math.round(i - v * (0 === vt || 2 === vt ? 1 : _))) + "px"
                    }
                }
            }
            var Tt, Mt, Et, St = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                At = T("transform"),
                Pt = tt + "transform",
                Ct = T("transformOrigin"),
                Rt = null !== T("perspective"),
                Lt = n.Transform = function() {
                    this.perspective = parseFloat(D.defaultTransformPerspective) || 0, this.force3D = !(!1 === D.defaultForce3D || !Rt) && (D.defaultForce3D || "auto")
                },
                Ot = window.SVGElement,
                Dt = function(t, e, i) {
                    var n, r = Z.createElementNS("http://www.w3.org/2000/svg", t),
                        s = /([a-z])([A-Z])/g;
                    for (n in i) r.setAttributeNS(null, n.replace(s, "$1-$2").toLowerCase(), i[n]);
                    return e.appendChild(r), r
                },
                e = Z.documentElement,
                kt = (Et = P || /Android/i.test(K) && !window.chrome, Z.createElementNS && !Et && (Mt = Dt("svg", e), Dt = (K = Dt("rect", Mt, {
                    width: 100,
                    height: 50,
                    x: 100
                })).getBoundingClientRect().width, K.style[Ct] = "50% 50%", K.style[At] = "scaleX(0.5)", Et = Dt === K.getBoundingClientRect().width && !(k && Rt), e.removeChild(Mt)), Et),
                It = [1, 0, 0, 1, 0, 0],
                Nt = function(t, e) {
                    var i, n, r, s, a, o = t._gsTransform || new Lt;
                    if (At ? n = nt(t, Pt, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(V)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), o.x || 0, o.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, (o.svg || t.getBBox && bt(t)) && (i && -1 !== (t.style[At] + "").indexOf("matrix") && (n = t.style[At], i = 0), r = t.getAttribute("transform"), i && r && (-1 !== r.indexOf("matrix") ? (n = r, i = 0) : -1 !== r.indexOf("translate") && (n = "matrix(1,0,0,1," + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", i = 0))), i) return It;
                    for (r = (n || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], vt = r.length; - 1 < --vt;) s = Number(r[vt]), r[vt] = (a = s - (s |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + s : s;
                    return e && 6 < r.length ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                },
                zt = n.getTransform = function(t, e, i, n) {
                    if (t._gsTransform && i && !n) return t._gsTransform;
                    var r, s, a, o, l, h, c, u, d, p, f, m, g, v, _, y, x, b, w, T, M, E, S, A = i && t._gsTransform || new Lt,
                        P = A.scaleX < 0,
                        C = Rt && (parseFloat(nt(t, Ct, e, !1, "0 0 0").split(" ")[2]) || A.zOrigin) || 0,
                        R = parseFloat(D.defaultTransformPerspective) || 0;
                    if (A.svg = !(!t.getBBox || !bt(t)), A.svg && (xt(t, nt(t, Ct, O, !1, "50% 50%") + "", A, t.getAttribute("data-svg-origin")), Tt = D.useSVGTransformAttr || kt), s = Nt(t), s !== It)
                        for (r in 16 === s.length ? (T = s[0], E = s[1], a = s[2], o = s[3], M = s[4], S = s[5], l = s[6], h = s[7], c = s[8], u = s[9], d = s[10], p = s[12], f = s[13], w = s[14], m = s[11], g = Math.atan2(l, d), A.zOrigin && (p = c * (w = -A.zOrigin) - s[12], f = u * w - s[13], w = d * w + A.zOrigin - s[14]), A.rotationX = g * q, g && (v = M * (x = Math.cos(-g)) + c * (b = Math.sin(-g)), _ = S * x + u * b, y = l * x + d * b, c = M * -b + c * x, u = S * -b + u * x, d = l * -b + d * x, m = h * -b + m * x, M = v, S = _, l = y), g = Math.atan2(c, d), A.rotationY = g * q, g && (_ = E * (x = Math.cos(-g)) - u * (b = Math.sin(-g)), y = a * x - d * b, u = E * b + u * x, d = a * b + d * x, m = o * b + m * x, T = v = T * x - c * b, E = _, a = y), g = Math.atan2(E, T), A.rotation = g * q, g && (T = T * (x = Math.cos(-g)) + M * (b = Math.sin(-g)), _ = E * x + S * b, S = E * -b + S * x, l = a * -b + l * x, E = _), A.rotationX && 359.9 < Math.abs(A.rotationX) + Math.abs(A.rotation) && (A.rotationX = A.rotation = 0, A.rotationY += 180), A.scaleX = (1e5 * Math.sqrt(T * T + E * E) + .5 | 0) / 1e5, A.scaleY = (1e5 * Math.sqrt(S * S + u * u) + .5 | 0) / 1e5, A.scaleZ = (1e5 * Math.sqrt(l * l + d * d) + .5 | 0) / 1e5, A.skewX = 0, A.perspective = m ? 1 / (m < 0 ? -m : m) : 0, A.x = p, A.y = f, A.z = w, A.svg && (A.x -= A.xOrigin - (A.xOrigin * T - A.yOrigin * M), A.y -= A.yOrigin - (A.yOrigin * E - A.xOrigin * S))) : Rt && !n && s.length && A.x === s[4] && A.y === s[5] && (A.rotationX || A.rotationY) || void 0 !== A.x && "none" === nt(t, "display", e) || (T = (w = 6 <= s.length) ? s[0] : 1, M = s[1] || 0, E = s[2] || 0, S = w ? s[3] : 1, A.x = s[4] || 0, A.y = s[5] || 0, n = Math.sqrt(T * T + M * M), e = Math.sqrt(S * S + E * E), w = T || M ? Math.atan2(M, T) * q : A.rotation || 0, s = E || S ? Math.atan2(E, S) * q + w : A.skewX || 0, 90 < Math.abs(s) && Math.abs(s) < 270 && (P ? (n *= -1, s += w <= 0 ? 180 : -180, w += w <= 0 ? 180 : -180) : (e *= -1, s += s <= 0 ? 180 : -180)), A.scaleX = n, A.scaleY = e, A.rotation = w, A.skewX = s, Rt && (A.rotationX = A.rotationY = A.z = 0, A.perspective = R, A.scaleZ = 1), A.svg && (A.x -= A.xOrigin - (A.xOrigin * T + A.yOrigin * E), A.y -= A.yOrigin - (A.xOrigin * M + A.yOrigin * S))), A.zOrigin = C, A) A[r] < 2e-5 && -2e-5 < A[r] && (A[r] = 0);
                    return i && (t._gsTransform = A).svg && (Tt && t.style[At] ? L.delayedCall(.001, function() {
                        Ht(t.style, At)
                    }) : !Tt && t.getAttribute("transform") && L.delayedCall(.001, function() {
                        t.removeAttribute("transform")
                    })), A
                },
                Bt = n.set3DTransformRatio = n.setTransformRatio = function(t) {
                    var e, i, n, r, s, a, o, l, h, c, u, d, p, f, m, g, v = this.data,
                        _ = this.t.style,
                        y = v.rotation,
                        x = v.rotationX,
                        b = v.rotationY,
                        w = v.scaleX,
                        T = v.scaleY,
                        M = v.scaleZ,
                        E = v.x,
                        S = v.y,
                        A = v.z,
                        P = v.svg,
                        C = v.perspective,
                        R = v.force3D;
                    if (!((1 !== t && 0 !== t || "auto" !== R || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && R || A || C || b || x) || Tt && P || !Rt) y || v.skewX || P ? (y *= X, g = v.skewX * X, e = Math.cos(y) * w, n = Math.sin(y) * w, i = Math.sin(y - g) * -T, r = Math.cos(y - g) * T, g && "simple" === v.skewType && (f = Math.tan(g), i *= f = Math.sqrt(1 + f * f), r *= f, v.skewY && (e *= f, n *= f)), P && (E += v.xOrigin - (v.xOrigin * e + v.yOrigin * i) + v.xOffset, S += v.yOrigin - (v.xOrigin * n + v.yOrigin * r) + v.yOffset, Tt && (v.xPercent || v.yPercent) && (u = this.t.getBBox(), E += .01 * v.xPercent * u.width, S += .01 * v.yPercent * u.height), E < (u = 1e-6) && -u < E && (E = 0), S < u && -u < S && (S = 0)), m = (1e5 * e | 0) / 1e5 + "," + (1e5 * n | 0) / 1e5 + "," + (1e5 * i | 0) / 1e5 + "," + (1e5 * r | 0) / 1e5 + "," + E + "," + S + ")", P && Tt ? this.t.setAttribute("transform", "matrix(" + m) : _[At] = (v.xPercent || v.yPercent ? "translate(" + v.xPercent + "%," + v.yPercent + "%) matrix(" : "matrix(") + m) : _[At] = (v.xPercent || v.yPercent ? "translate(" + v.xPercent + "%," + v.yPercent + "%) matrix(" : "matrix(") + w + ",0,0," + T + "," + E + "," + S + ")";
                    else {
                        if (k && (w < (u = 1e-4) && -u < w && (w = M = 2e-5), T < u && -u < T && (T = M = 2e-5), !C || v.z || v.rotationX || v.rotationY || (C = 0)), y || v.skewX) y *= X, d = e = Math.cos(y), p = n = Math.sin(y), v.skewX && (y -= v.skewX * X, d = Math.cos(y), p = Math.sin(y), "simple" === v.skewType && (f = Math.tan(v.skewX * X), d *= f = Math.sqrt(1 + f * f), p *= f, v.skewY && (e *= f, n *= f))), i = -p, r = d;
                        else {
                            if (!(b || x || 1 !== M || C || P)) return void(_[At] = (v.xPercent || v.yPercent ? "translate(" + v.xPercent + "%," + v.yPercent + "%) translate3d(" : "translate3d(") + E + "px," + S + "px," + A + "px)" + (1 !== w || 1 !== T ? " scale(" + w + "," + T + ")" : ""));
                            e = r = 1, i = n = 0
                        }
                        l = 1, t = s = a = o = h = c = 0, R = C ? -1 / C : 0, g = v.zOrigin, u = 1e-6, (y = b * X) && (d = Math.cos(y), h = R * (a = -(p = Math.sin(y))), t = e * p, s = n * p, R *= l = d, e *= d, n *= d), (y = x * X) && (f = i * (d = Math.cos(y)) + t * (p = Math.sin(y)), y = r * d + s * p, o = l * p, c = R * p, t = i * -p + t * d, s = r * -p + s * d, l *= d, R *= d, i = f, r = y), 1 !== M && (t *= M, s *= M, l *= M, R *= M), 1 !== T && (i *= T, r *= T, o *= T, c *= T), 1 !== w && (e *= w, n *= w, a *= w, h *= w), (g || P) && (g && (E += t * -g, S += s * -g, A += l * -g + g), P && (E += v.xOrigin - (v.xOrigin * e + v.yOrigin * i) + v.xOffset, S += v.yOrigin - (v.xOrigin * n + v.yOrigin * r) + v.yOffset), E < u && -u < E && (E = "0"), S < u && -u < S && (S = "0"), A < u && -u < A && (A = 0)), m = v.xPercent || v.yPercent ? "translate(" + v.xPercent + "%," + v.yPercent + "%) matrix3d(" : "matrix3d(", m += (e < u && -u < e ? "0" : e) + "," + (n < u && -u < n ? "0" : n) + "," + (a < u && -u < a ? "0" : a), m += "," + (h < u && -u < h ? "0" : h) + "," + (i < u && -u < i ? "0" : i) + "," + (r < u && -u < r ? "0" : r), x || b ? (m += "," + (o < u && -u < o ? "0" : o) + "," + (c < u && -u < c ? "0" : c) + "," + (t < u && -u < t ? "0" : t), m += "," + (s < u && -u < s ? "0" : s) + "," + (l < u && -u < l ? "0" : l) + "," + (R < u && -u < R ? "0" : R) + ",") : m += ",0,0,0,0,1,0,", m += E + "," + S + "," + A + "," + (C ? 1 + -A / C : 1) + ")", _[At] = m
                    }
                };
            (t = Lt.prototype).x = t.y = t.z = t.skewX = t.skewY = t.rotation = t.rotationX = t.rotationY = t.zOrigin = t.xPercent = t.yPercent = t.xOffset = t.yOffset = 0, t.scaleX = t.scaleY = t.scaleZ = 1, yt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                parser: function(t, e, i, n, r, s, a) {
                    if (n._lastParsedTransform === a) return r;
                    n._lastParsedTransform = a;
                    var o, l, h, c, u, d, p, f, m = t._gsTransform,
                        g = t.style,
                        v = St.length,
                        _ = a,
                        y = {},
                        x = "transformOrigin";
                    if (a.display ? (h = nt(t, "display"), g.display = "block", o = zt(t, O, !0, a.parseTransform), g.display = h) : o = zt(t, O, !0, a.parseTransform), n._transform = o, "string" == typeof _.transform && At)(h = J.style)[At] = _.transform, h.display = "block", h.position = "absolute", Z.body.appendChild(J), l = zt(J, null, !1), Z.body.removeChild(J), l.perspective || (l.perspective = o.perspective), null != _.xPercent && (l.xPercent = M(_.xPercent, o.xPercent)), null != _.yPercent && (l.yPercent = M(_.yPercent, o.yPercent));
                    else if ("object" == typeof _) {
                        if (l = {
                                scaleX: M(null != _.scaleX ? _.scaleX : _.scale, o.scaleX),
                                scaleY: M(null != _.scaleY ? _.scaleY : _.scale, o.scaleY),
                                scaleZ: M(_.scaleZ, o.scaleZ),
                                x: M(_.x, o.x),
                                y: M(_.y, o.y),
                                z: M(_.z, o.z),
                                xPercent: M(_.xPercent, o.xPercent),
                                yPercent: M(_.yPercent, o.yPercent),
                                perspective: M(_.transformPerspective, o.perspective)
                            }, null != (p = _.directionalRotation))
                            if ("object" == typeof p)
                                for (h in p) _[h] = p[h];
                            else _.rotation = p;
                        "string" == typeof _.x && -1 !== _.x.indexOf("%") && (l.x = 0, l.xPercent = M(_.x, o.xPercent)), "string" == typeof _.y && -1 !== _.y.indexOf("%") && (l.y = 0, l.yPercent = M(_.y, o.yPercent)), l.rotation = E("rotation" in _ ? _.rotation : "shortRotation" in _ ? _.shortRotation + "_short" : "rotationZ" in _ ? _.rotationZ : o.rotation, o.rotation, "rotation", y), Rt && (l.rotationX = E("rotationX" in _ ? _.rotationX : "shortRotationX" in _ ? _.shortRotationX + "_short" : o.rotationX || 0, o.rotationX, "rotationX", y), l.rotationY = E("rotationY" in _ ? _.rotationY : "shortRotationY" in _ ? _.shortRotationY + "_short" : o.rotationY || 0, o.rotationY, "rotationY", y)), l.skewX = null == _.skewX ? o.skewX : E(_.skewX, o.skewX), l.skewY = null == _.skewY ? o.skewY : E(_.skewY, o.skewY), (f = l.skewY - o.skewY) && (l.skewX += f, l.rotation += f)
                    }
                    for (Rt && null != _.force3D && (o.force3D = _.force3D, d = !0), o.skewType = _.skewType || o.skewType || D.defaultSkewType, (u = o.force3D || o.z || o.rotationX || o.rotationY || l.z || l.rotationX || l.rotationY || l.perspective) || null == _.scale || (l.scaleZ = 1); - 1 < --v;)(1e-6 < (c = l[i = St[v]] - o[i]) || c < -1e-6 || null != _[i] || null != Y[i]) && (d = !0, r = new mt(o, i, o[i], c, r), i in y && (r.e = y[i]), r.xs0 = 0, r.plugin = s, n._overwriteProps.push(r.n));
                    return c = _.transformOrigin, o.svg && (c || _.svgOrigin) && (a = o.xOffset, f = o.yOffset, xt(t, b(c), l, _.svgOrigin, _.smoothOrigin), r = pt(o, "xOrigin", (m ? o : l).xOrigin, l.xOrigin, r, x), r = pt(o, "yOrigin", (m ? o : l).yOrigin, l.yOrigin, r, x), a === o.xOffset && f === o.yOffset || (r = pt(o, "xOffset", m ? a : o.xOffset, o.xOffset, r, x), r = pt(o, "yOffset", m ? f : o.yOffset, o.yOffset, r, x)), c = Tt ? null : "0px 0px"), (c || Rt && u && o.zOrigin) && (At ? (d = !0, i = Ct, c = (c || nt(t, i, O, !1, "50% 50%")) + "", (r = new mt(g, i, 0, 0, r, -1, x)).b = g[i], r.plugin = s, Rt ? (h = o.zOrigin, c = c.split(" "), o.zOrigin = (2 < c.length && (0 === h || "0px" !== c[2]) ? parseFloat(c[2]) : h) || 0, r.xs0 = r.e = c[0] + " " + (c[1] || "50%") + " 0px", (r = new mt(o, "zOrigin", 0, 0, r, -1, r.n)).b = h, r.xs0 = r.e = o.zOrigin) : r.xs0 = r.e = c) : b(c + "", o)), d && (n._transformType = o.svg && Tt || !u && 3 !== this._transformType ? 2 : 3), r
                },
                prefix: !0
            }), yt("boxShadow", {
                defaultValue: "0px 0px 0px 0px #999",
                prefix: !0,
                color: !0,
                multi: !0,
                keyword: "inset"
            }), yt("borderRadius", {
                defaultValue: "0px",
                parser: function(t, e, i, n, r, s) {
                    e = this.format(e);
                    for (var a, o, l, h, c, u, d, p, f, m, g = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], v = t.style, _ = parseFloat(t.offsetWidth), y = parseFloat(t.offsetHeight), x = e.split(" "), b = 0; b < g.length; b++) this.p.indexOf("border") && (g[b] = T(g[b])), -1 !== (l = o = nt(t, g[b], O, !1, "0px")).indexOf(" ") && (l = (o = l.split(" "))[0], o = o[1]), h = a = x[b], f = parseFloat(l), m = l.substr((f + "").length), "" === (u = (d = "=" === h.charAt(1)) ? (c = parseInt(h.charAt(0) + "1", 10), h = h.substr(2), c *= parseFloat(h), h.substr((c + "").length - (c < 0 ? 1 : 0)) || "") : (c = parseFloat(h), h.substr((c + "").length))) && (u = w[i] || m), u !== m && (p = rt(t, "borderLeft", f, m), f = rt(t, "borderTop", f, m), o = "%" === u ? (l = p / _ * 100 + "%", f / y * 100 + "%") : "em" === u ? (l = p / (m = rt(t, "borderLeft", 1, "em")) + "em", f / m + "em") : (l = p + "px", f + "px"), d && (h = parseFloat(l) + c + u, a = parseFloat(o) + c + u)), r = gt(v, g[b], l + " " + o, h + " " + a, !1, "0px", r);
                    return r
                },
                prefix: !0,
                formatter: ut("0px 0px 0px 0px", !1, !0)
            }), yt("backgroundPosition", {
                defaultValue: "0 0",
                parser: function(t, e, i, n, r, s) {
                    var a, o, l, h, c, u, d = "background-position",
                        p = O || it(t, null),
                        f = this.format((p ? P ? p.getPropertyValue(d + "-x") + " " + p.getPropertyValue(d + "-y") : p.getPropertyValue(d) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                        e = this.format(e);
                    if (-1 !== f.indexOf("%") != (-1 !== e.indexOf("%")) && (u = nt(t, "backgroundImage").replace(H, "")) && "none" !== u) {
                        for (a = f.split(" "), o = e.split(" "), Q.setAttribute("src", u), l = 2; - 1 < --l;)(h = -1 !== (f = a[l]).indexOf("%")) != (-1 !== o[l].indexOf("%")) && (c = 0 === l ? t.offsetWidth - Q.width : t.offsetHeight - Q.height, a[l] = h ? parseFloat(f) / 100 * c + "px" : parseFloat(f) / c * 100 + "%");
                        f = a.join(" ")
                    }
                    return this.parseComplex(t.style, f, e, r, s)
                },
                formatter: b
            }), yt("backgroundSize", {
                defaultValue: "0 0",
                formatter: b
            }), yt("perspective", {
                defaultValue: "0px",
                prefix: !0
            }), yt("perspectiveOrigin", {
                defaultValue: "50% 50%",
                prefix: !0
            }), yt("transformStyle", {
                prefix: !0
            }), yt("backfaceVisibility", {
                prefix: !0
            }), yt("userSelect", {
                prefix: !0
            }), yt("margin", {
                parser: dt("marginTop,marginRight,marginBottom,marginLeft")
            }), yt("padding", {
                parser: dt("paddingTop,paddingRight,paddingBottom,paddingLeft")
            }), yt("clip", {
                defaultValue: "rect(0px,0px,0px,0px)",
                parser: function(t, e, i, n, r, s) {
                    var a, o;
                    return e = P < 9 ? (a = t.currentStyle, o = P < 8 ? " " : ",", a = "rect(" + a.clipTop + o + a.clipRight + o + a.clipBottom + o + a.clipLeft + ")", this.format(e).split(",").join(o)) : (a = this.format(nt(t, this.p, O, !1, this.dflt)), this.format(e)), this.parseComplex(t.style, a, e, r, s)
                }
            }), yt("textShadow", {
                defaultValue: "0px 0px 0px #999",
                color: !0,
                multi: !0
            }), yt("autoRound,strictUnits", {
                parser: function(t, e, i, n, r) {
                    return r
                }
            }), yt("border", {
                defaultValue: "0px solid #000",
                parser: function(t, e, i, n, r, s) {
                    return this.parseComplex(t.style, this.format(nt(t, "borderTopWidth", O, !1, "0px") + " " + nt(t, "borderTopStyle", O, !1, "solid") + " " + nt(t, "borderTopColor", O, !1, "#000")), this.format(e), r, s)
                },
                color: !0,
                formatter: function(t) {
                    var e = t.split(" ");
                    return e[0] + " " + (e[1] || "solid") + " " + (t.match(ct) || ["#000"])[0]
                }
            }), yt("borderWidth", {
                parser: dt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
            }), yt("float,cssFloat,styleFloat", {
                parser: function(t, e, i, n, r, s) {
                    var a = t.style,
                        t = "cssFloat" in a ? "cssFloat" : "styleFloat";
                    return new mt(a, t, 0, 0, r, -1, i, !1, 0, a[t], e)
                }
            });

            function Ut(t) {
                var e, i = this.t,
                    n = i.filter || nt(this.data, "filter") || "";
                100 == (t = this.s + this.c * t | 0) && (e = -1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), !nt(this.data, "filter")) : (i.filter = n.replace(r, ""), !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + t + ")"), -1 === n.indexOf("pacity") ? 0 == t && this.xn1 || (i.filter = n + " alpha(opacity=" + t + ")") : i.filter = n.replace(z, "opacity=" + t))
            }
            yt("opacity,alpha,autoAlpha", {
                defaultValue: "1",
                parser: function(t, e, i, n, r, s) {
                    var a = parseFloat(nt(t, "opacity", O, !1, "1")),
                        o = t.style,
                        l = "autoAlpha" === i;
                    return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + a), l && 1 === a && "hidden" === nt(t, "visibility", O) && 0 !== e && (a = 0), $ ? r = new mt(o, "opacity", a, e - a, r) : ((r = new mt(o, "opacity", 100 * a, 100 * (e - a), r)).xn1 = l ? 1 : 0, o.zoom = 1, r.type = 2, r.b = "alpha(opacity=" + r.s + ")", r.e = "alpha(opacity=" + (r.s + r.c) + ")", r.data = t, r.plugin = s, r.setRatio = Ut), l && ((r = new mt(o, "visibility", 0, 0, r, -1, null, !1, 0, 0 !== a ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", n._overwriteProps.push(r.n), n._overwriteProps.push(i)), r
                }
            });

            function Ft(t) {
                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Ht(i, e.p), e = e._next;
                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
            }
            var Ht = function(t, e) {
                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(l, "-$1").toLowerCase())) : t.removeAttribute(e))
            };
            yt("className", {
                parser: function(t, e, i, n, r, s, a) {
                    var o, l, h, c = t.getAttribute("class") || "",
                        u = t.style.cssText;
                    if ((r = n._classNamePT = new mt(t, i, 0, 0, r, 2)).setRatio = Ft, r.pr = -11, d = !0, r.b = c, o = m(t, O), i = t._gsClassPT) {
                        for (l = {}, h = i.data; h;) l[h.p] = 1, h = h._next;
                        i.setRatio(1)
                    }
                    return (t._gsClassPT = r).e = "=" !== e.charAt(1) ? e : c.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", r.e), a = g(t, o, m(t), a, l), t.setAttribute("class", c), r.data = a.firstMPT, t.style.cssText = u, r = r.xfirst = n.parse(t, a.difs, r, s)
                }
            });

            function Gt(t) {
                if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                    var e, i, n, r, s = this.t.style,
                        a = p.transform.parse;
                    if ("all" === this.e) r = !(s.cssText = "");
                    else
                        for (n = (e = this.e.split(" ").join("").split(",")).length; - 1 < --n;) i = e[n], p[i] && (p[i].parse === a ? r = !0 : i = "transformOrigin" === i ? Ct : p[i].p), Ht(s, i);
                    r && (Ht(s, At), (t = this.t._gsTransform) && (t.svg && this.t.removeAttribute("data-svg-origin"), delete this.t._gsTransform))
                }
            }
            for (yt("clearProps", {
                    parser: function(t, e, i, n, r) {
                        return (r = new mt(t, i, 0, 0, r, 2)).setRatio = Gt, r.e = e, r.pr = -10, r.data = n._tween, d = !0, r
                    }
                }), t = "bezier,throwProps,physicsProps,physics2D".split(","), vt = t.length; vt--;) ! function(t) {
                var l;
                p[t] || (l = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin", yt(t, {
                    parser: function(t, e, i, n, r, s, a) {
                        var o = h.com.greensock.plugins[l];
                        return o ? (o._cssRegister(), p[i].parse(t, e, i, n, r, s, a)) : (f("Error: " + l + " js file not loaded."), r)
                    }
                }))
            }(t[vt]);
            (t = D.prototype)._firstPT = t._lastParsedTransform = t._transform = null, t._onInitTween = function(t, e, i) {
                if (!t.nodeType) return !1;
                this._target = t, this._tween = i, this._vars = e, A = e.autoRound, d = !1, w = e.suffixMap || D.suffixMap, O = it(t, ""), u = this._overwriteProps;
                var n, r, s, a, o, l, h = t.style;
                if (v && "" === h.zIndex && ("auto" !== (l = nt(t, "zIndex", O)) && "" !== l || this._addLazySet(h, "zIndex", 0)), "string" == typeof e && (s = h.cssText, l = m(t, O), h.cssText = s + ";" + e, l = g(t, l, m(t)).difs, !$ && B.test(e) && (l.opacity = parseFloat(RegExp.$1)), e = l, h.cssText = s), e.className ? this._firstPT = n = p.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = n = this.parse(t, e, null), this._transformType) {
                    for (l = 3 === this._transformType, At ? _ && (v = !0, "" === h.zIndex && ("auto" !== (e = nt(t, "zIndex", O)) && "" !== e || this._addLazySet(h, "zIndex", 0)), y && this._addLazySet(h, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (l ? "visible" : "hidden"))) : h.zoom = 1, r = n; r && r._next;) r = r._next;
                    h = new mt(t, "transform", 0, 0, null, 2), this._linkCSSP(h, null, r), h.setRatio = At ? Bt : wt, h.data = this._transform || zt(t, O, !0), h.tween = i, h.pr = -1, u.pop()
                }
                if (d) {
                    for (; n;) {
                        for (o = n._next, r = s; r && r.pr > n.pr;) r = r._next;
                        (n._prev = r ? r._prev : a) ? n._prev._next = n: s = n, (n._next = r) ? r._prev = n : a = n, n = o
                    }
                    this._firstPT = s
                }
                return !0
            }, t.parse = function(t, e, i, n) {
                var r, s, a, o, l, h, c, u, d = t.style;
                for (r in e) l = e[r], (u = p[r]) ? i = u.parse(t, l, r, this, i, n, e) : (o = nt(t, r, O) + "", c = "string" == typeof l, "color" === r || "fill" === r || "stroke" === r || -1 !== r.indexOf("Color") || c && U.test(l) ? (c || (l = (3 < (l = ht(l)).length ? "rgba(" : "rgb(") + l.join(",") + ")"), i = gt(d, r, o, l, !0, "transparent", i, 0, n)) : !c || -1 === l.indexOf(" ") && -1 === l.indexOf(",") ? (h = (s = parseFloat(o)) || 0 === s ? o.substr((s + "").length) : "", "" !== o && "auto" !== o || (h = "width" === r || "height" === r ? (s = function(t, e, i) {
                    var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                        r = at[e],
                        s = r.length;
                    for (i = i || it(t, null); - 1 < --s;) n -= parseFloat(nt(t, "padding" + r[s], i, !0)) || 0, n -= parseFloat(nt(t, "border" + r[s] + "Width", i, !0)) || 0;
                    return n
                }(t, r, O), "px") : "left" === r || "top" === r ? (s = st(t, r, O), "px") : (s = "opacity" !== r ? 0 : 1, "")), "" === (c = (u = c && "=" === l.charAt(1)) ? (a = parseInt(l.charAt(0) + "1", 10), l = l.substr(2), a *= parseFloat(l), l.replace(N, "")) : (a = parseFloat(l), c ? l.replace(N, "") : "")) && (c = r in w ? w[r] : h), l = a || 0 === a ? (u ? a + s : a) + c : e[r], h !== c && "" !== c && (a || 0 === a) && s && (s = rt(t, r, s, h), "%" === c ? (s /= rt(t, r, 100, "%") / 100, !0 !== e.strictUnits && (o = s + "%")) : "em" === c || "rem" === c ? s /= rt(t, r, 1, c) : "px" !== c && (a = rt(t, r, a, c), c = "px"), u && (!a && 0 !== a || (l = a + s + c))), u && (a += s), !s && 0 !== s || !a && 0 !== a ? void 0 !== d[r] && (l || l + "" != "NaN" && null != l) ? (i = new mt(d, r, a || s || 0, 0, i, -1, r, !1, 0, o, l)).xs0 = "none" !== l || "display" !== r && -1 === r.indexOf("Style") ? l : o : f("invalid " + r + " tween value: " + e[r]) : (i = new mt(d, r, s, a - s, i, 0, r, !1 !== A && ("px" === c || "zIndex" === r), 0, o, l)).xs0 = c) : i = gt(d, r, o, l, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n);
                return i
            }, t.setRatio = function(t) {
                var e, i, n, r = this._firstPT;
                if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                    if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                        for (; r;) {
                            if (e = r.c * t + r.s, r.r ? e = Math.round(e) : e < 1e-6 && -1e-6 < e && (e = 0), r.type)
                                if (1 === r.type)
                                    if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                    else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                            else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                            else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                            else {
                                for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                r.t[r.p] = i
                            } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                            else r.t[r.p] = e + r.xs0;
                            r = r._next
                        } else
                            for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                    else
                        for (; r;) {
                            if (2 !== r.type)
                                if (r.r && -1 !== r.type)
                                    if (e = Math.round(r.s + r.c), r.type) {
                                        if (1 === r.type) {
                                            for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                            r.t[r.p] = i
                                        }
                                    } else r.t[r.p] = e + r.xs0;
                            else r.t[r.p] = r.e;
                            else r.setRatio(t);
                            r = r._next
                        }
            }, t._enableTransforms = function(t) {
                this._transform = this._transform || zt(this._target, O, !0), this._transformType = this._transform.svg && Tt || !t && 3 !== this._transformType ? 2 : 3
            };

            function Vt(t) {
                this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
            }
            t._addLazySet = function(t, e, i) {
                e = this._firstPT = new mt(t, e, 0, 0, this._firstPT, 2);
                e.e = i, e.setRatio = Vt, e.data = this
            }, t._linkCSSP = function(t, e, i, n) {
                return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
            }, t._kill = function(t) {
                var e, i, n, r = t;
                if (t.autoAlpha || t.alpha) {
                    for (i in r = {}, t) r[i] = t[i];
                    r.opacity = 1, r.autoAlpha && (r.visibility = 1)
                }
                return t.className && (e = this._classNamePT) && ((n = e.xfirst) && n._prev ? this._linkCSSP(n._prev, e._next, n._prev._prev) : n === this._firstPT && (this._firstPT = e._next), e._next && this._linkCSSP(e._next, e._next._next, n._prev), this._classNamePT = null), s.prototype._kill.call(this, r)
            };
            var jt = function(t, e, i) {
                var n, r, s, a;
                if (t.slice)
                    for (r = t.length; - 1 < --r;) jt(t[r], e, i);
                else
                    for (r = (n = t.childNodes).length; - 1 < --r;) a = (s = n[r]).type, s.style && (e.push(m(s)), i && i.push(s)), 1 !== a && 9 !== a && 11 !== a || !s.childNodes.length || jt(s, e, i)
            };
            return D.cascadeTo = function(t, e, i) {
                var n, r, s, a, o = L.to(t, e, i),
                    l = [o],
                    h = [],
                    c = [],
                    u = [],
                    d = L._internals.reservedProps;
                for (t = o._targets || o.target, jt(t, h, u), o.render(e, !0, !0), jt(t, c), o.render(0, !0, !0), o._enabled(!0), n = u.length; - 1 < --n;)
                    if ((r = g(u[n], h[n], c[n])).firstMPT) {
                        for (s in r = r.difs, i) d[s] && (r[s] = i[s]);
                        for (s in a = {}, r) a[s] = h[n][s];
                        l.push(L.fromTo(u[n], e, a, r))
                    }
                return l
            }, s.activate([D]), D
        }, !0), (t = (t = _gsScope._gsDefine.plugin({
            propName: "roundProps",
            version: "1.5",
            priority: -1,
            API: 2,
            init: function(t, e, i) {
                return this._tween = i, !0
            }
        })).prototype)._onInitAllProps = function() {
            for (var t, e, i, n = this._tween, r = n.vars.roundProps.join ? n.vars.roundProps : n.vars.roundProps.split(","), s = r.length, a = {}, o = n._propLookup.roundProps; - 1 < --s;) a[r[s]] = 1;
            for (s = r.length; - 1 < --s;)
                for (t = r[s], e = n._firstPT; e;) i = e._next, e.pg ? e.t._roundProps(a, !0) : e.n === t && (2 === e.f && e.t ? function(t) {
                    for (; t;) t.f || t.blob || (t.r = 1), t = t._next
                }(e.t._firstPT) : (this._add(e.t, t, e.s, e.c), i && (i._prev = e._prev), e._prev ? e._prev._next = i : n._firstPT === e && (n._firstPT = i), e._next = e._prev = null, n._propLookup[t] = o)), e = i;
            return !1
        }, t._add = function(t, e, i, n) {
            this._addTween(t, e, i, i + n, e, !0), this._overwriteProps.push(e)
        }, _gsScope._gsDefine.plugin({
            propName: "attr",
            API: 2,
            version: "0.5.0",
            init: function(t, e, i) {
                if ("function" != typeof t.setAttribute) return !1;
                for (var n in e) this._addTween(t, "setAttribute", t.getAttribute(n) + "", e[n] + "", n, !1, n), this._overwriteProps.push(n);
                return !0
            }
        }), _gsScope._gsDefine.plugin({
            propName: "directionalRotation",
            version: "0.2.1",
            API: 2,
            init: function(t, e, i) {
                "object" != typeof e && (e = {
                    rotation: e
                }), this.finals = {};
                var n, r, s, a, o, l = !0 === e.useRadians ? 2 * Math.PI : 360;
                for (n in e) "useRadians" !== n && (r = (o = (e[n] + "").split("_"))[0], s = parseFloat("function" != typeof t[n] ? t[n] : t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]()), a = (this.finals[n] = "string" == typeof r && "=" === r.charAt(1) ? s + parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2)) : Number(r) || 0) - s, o.length && (-1 !== (r = o.join("_")).indexOf("short") && (a %= l) !== a % (l / 2) && (a = a < 0 ? a + l : a - l), -1 !== r.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * l) % l - (a / l | 0) * l : -1 !== r.indexOf("ccw") && 0 < a && (a = (a - 9999999999 * l) % l - (a / l | 0) * l)), (1e-6 < a || a < -1e-6) && (this._addTween(t, n, s, s + a, n), this._overwriteProps.push(n)));
                return !0
            },
            set: function(t) {
                var e;
                if (1 !== t) this._super.setRatio.call(this, t);
                else
                    for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
            }
        })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(g) {
            function t(t, e) {
                var i = l("easing." + t, function() {}, !0);
                return (t = i.prototype = new g).constructor = i, t.getRatio = e, i
            }

            function e(t, e, i, n, r) {
                return n = l("easing." + t, {
                    easeOut: new e,
                    easeIn: new i,
                    easeInOut: new n
                }, !0), h(n, t), n
            }

            function v(t, e, i) {
                this.t = t, this.v = e, i && (((this.next = i).prev = this).c = i.v - e, this.gap = i.t - t)
            }
            var i, n, r = _gsScope.GreenSockGlobals || _gsScope,
                s = r.com.greensock,
                a = 2 * Math.PI,
                o = Math.PI / 2,
                l = s._class,
                h = g.register || function() {},
                c = function(t, e) {
                    var i = l("easing." + t, function(t) {
                            this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                        }, !0),
                        t = i.prototype = new g;
                    return t.constructor = i, t.getRatio = e, t.config = function(t) {
                        return new i(t)
                    }, i
                },
                s = e("Back", c("BackOut", function(t) {
                    return --t * t * ((this._p1 + 1) * t + this._p1) + 1
                }), c("BackIn", function(t) {
                    return t * t * ((this._p1 + 1) * t - this._p1)
                }), c("BackInOut", function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                })),
                u = l("easing.SlowMo", function(t, e, i) {
                    e = e || 0 === e ? e : .7, null == t ? t = .7 : 1 < t && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                }, !0),
                c = u.prototype = new g;
            return c.constructor = u, c.getRatio = function(t) {
                var e = t + (.5 - t) * this._p;
                return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
            }, u.ease = new u(.7, .7), c.config = u.config = function(t, e, i) {
                return new u(t, e, i)
            }, (c = (i = l("easing.SteppedEase", function(t) {
                t = t || 1, this._p1 = 1 / t, this._p2 = t + 1
            }, !0)).prototype = new g).constructor = i, c.getRatio = function(t) {
                return t < 0 ? t = 0 : 1 <= t && (t = .999999999), (this._p2 * t >> 0) * this._p1
            }, c.config = i.config = function(t) {
                return new i(t)
            }, (c = (n = l("easing.RoughEase", function(t) {
                for (var e, i, n, r, s, a, o = (t = t || {}).taper || "none", l = [], h = 0, c = 0 | (t.points || 20), u = c, d = !1 !== t.randomize, p = !0 === t.clamp, f = t.template instanceof g ? t.template : null, m = "number" == typeof t.strength ? .4 * t.strength : .4; - 1 < --u;) e = d ? Math.random() : 1 / c * u, i = f ? f.getRatio(e) : e, n = "none" === o ? m : "out" === o ? (r = 1 - e) * r * m : "in" === o ? e * e * m : e < .5 ? (r = 2 * e) * r * .5 * m : (r = 2 * (1 - e)) * r * .5 * m, d ? i += Math.random() * n - .5 * n : u % 2 ? i += .5 * n : i -= .5 * n, p && (1 < i ? i = 1 : i < 0 && (i = 0)), l[h++] = {
                    x: e,
                    y: i
                };
                for (l.sort(function(t, e) {
                        return t.x - e.x
                    }), a = new v(1, 1, null), u = c; - 1 < --u;) s = l[u], a = new v(s.x, s.y, a);
                this._prev = new v(0, 0, 0 !== a.t ? a : a.next)
            }, !0)).prototype = new g).constructor = n, c.getRatio = function(t) {
                var e = this._prev;
                if (t > e.t) {
                    for (; e.next && t >= e.t;) e = e.next;
                    e = e.prev
                } else
                    for (; e.prev && t <= e.t;) e = e.prev;
                return (this._prev = e).v + (t - e.t) / e.gap * e.c
            }, c.config = function(t) {
                return new n(t)
            }, n.ease = new n, e("Bounce", t("BounceOut", function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }), t("BounceIn", function(t) {
                return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
            }), t("BounceInOut", function(t) {
                var e = t < .5;
                return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
            })), e("Circ", t("CircOut", function(t) {
                return Math.sqrt(1 - --t * t)
            }), t("CircIn", function(t) {
                return -(Math.sqrt(1 - t * t) - 1)
            }), t("CircInOut", function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            })), e("Elastic", (c = function(t, e, i) {
                var n = l("easing." + t, function(t, e) {
                        this._p1 = 1 <= t ? t : 1, this._p2 = (e || i) / (t < 1 ? t : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2
                    }, !0),
                    t = n.prototype = new g;
                return t.constructor = n, t.getRatio = e, t.config = function(t, e) {
                    return new n(t, e)
                }, n
            })("ElasticOut", function(t) {
                return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
            }, .3), c("ElasticIn", function(t) {
                return -(this._p1 * Math.pow(2, 10 * --t) * Math.sin((t - this._p3) * this._p2))
            }, .3), c("ElasticInOut", function(t) {
                return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * --t) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * --t) * Math.sin((t - this._p3) * this._p2) * .5 + 1
            }, .45)), e("Expo", t("ExpoOut", function(t) {
                return 1 - Math.pow(2, -10 * t)
            }), t("ExpoIn", function(t) {
                return Math.pow(2, 10 * (t - 1)) - .001
            }), t("ExpoInOut", function(t) {
                return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            })), e("Sine", t("SineOut", function(t) {
                return Math.sin(t * o)
            }), t("SineIn", function(t) {
                return 1 - Math.cos(t * o)
            }), t("SineInOut", function(t) {
                return -.5 * (Math.cos(Math.PI * t) - 1)
            })), l("easing.EaseLookup", {
                find: function(t) {
                    return g.map[t]
                }
            }, !0), h(r.SlowMo, "SlowMo", "ease,"), h(n, "RoughEase", "ease,"), h(i, "SteppedEase", "ease,"), s
        }, !0)
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function(d) {
        "use strict";
        var p = d.GreenSockGlobals = d.GreenSockGlobals || d;
        if (!p.TweenLite) {
            var f, e, i, m = function(t) {
                    for (var e = t.split("."), i = p, n = 0; n < e.length; n++) i[e[n]] = i = i[e[n]] || {};
                    return i
                },
                u = m("com.greensock"),
                g = 1e-10,
                o = function(t) {
                    for (var e = [], i = t.length, n = 0; n !== i; e.push(t[n++]));
                    return e
                },
                v = function() {},
                _ = (e = Object.prototype.toString, i = e.call([]), function(t) {
                    return null != t && (t instanceof Array || "object" == typeof t && !!t.push && e.call(t) === i)
                }),
                y = {},
                x = function(o, l, h, c) {
                    this.sc = y[o] ? y[o].sc : [], (y[o] = this).gsClass = null, this.func = h;
                    var u = [];
                    this.check = function(t) {
                        for (var e, i, n, r, s = l.length, a = s; - 1 < --s;)(e = y[l[s]] || new x(l[s], [])).gsClass ? (u[s] = e.gsClass, a--) : t && e.sc.push(this);
                        if (0 === a && h)
                            for (r = (i = ("com.greensock." + o).split(".")).pop(), n = m(i.join("."))[r] = this.gsClass = h.apply(h, u), c && (p[r] = n, !(r = "undefined" != typeof module && module.exports) && "function" == typeof define && define.amd ? define((d.GreenSockAMDPath ? d.GreenSockAMDPath + "/" : "") + o.split(".").pop(), [], function() {
                                    return n
                                }) : "TweenMax" === o && r && (module.exports = n)), s = 0; s < this.sc.length; s++) this.sc[s].check()
                    }, this.check(!0)
                },
                n = d._gsDefine = function(t, e, i, n) {
                    return new x(t, e, i, n)
                },
                b = u._class = function(t, e, i) {
                    return e = e || function() {}, n(t, [], function() {
                        return e
                    }, i), e
                };
            n.globals = p;
            var t, r = [0, 0, 1, 1],
                s = [],
                c = b("easing.Ease", function(t, e, i, n) {
                    this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? r.concat(e) : r
                }, !0),
                w = c.map = {},
                a = c.register = function(t, e, i, n) {
                    for (var r, s, a, o, l = e.split(","), h = l.length, c = (i || "easeIn,easeOut,easeInOut").split(","); - 1 < --h;)
                        for (s = l[h], r = n ? b("easing." + s, null, !0) : u.easing[s] || {}, a = c.length; - 1 < --a;) o = c[a], w[s + "." + o] = w[o + s] = r[o] = t.getRatio ? t : t[o] || new t
                };
            for ((t = c.prototype)._calcEnd = !1, t.getRatio = function(t) {
                    if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                    var e = this._type,
                        i = this._power,
                        n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                    return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                }, h = (l = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; - 1 < --h;) t = l[h] + ",Power" + h, a(new c(null, null, 1, h), t, "easeOut", !0), a(new c(null, null, 2, h), t, "easeIn" + (0 === h ? ",easeNone" : "")), a(new c(null, null, 3, h), t, "easeInOut");
            w.linear = u.easing.Linear.easeIn, w.swing = u.easing.Quad.easeInOut;
            var T = b("events.EventDispatcher", function(t) {
                this._listeners = {}, this._eventTarget = t || this
            });
            (t = T.prototype).addEventListener = function(t, e, i, n, r) {
                r = r || 0;
                var s, a, o = this._listeners[t],
                    l = 0;
                for (null == o && (this._listeners[t] = o = []), a = o.length; - 1 < --a;)(s = o[a]).c === e && s.s === i ? o.splice(a, 1) : 0 === l && s.pr < r && (l = a + 1);
                o.splice(l, 0, {
                    c: e,
                    s: i,
                    up: n,
                    pr: r
                }), this !== C || f || C.wake()
            }, t.removeEventListener = function(t, e) {
                var i, n = this._listeners[t];
                if (n)
                    for (i = n.length; - 1 < --i;)
                        if (n[i].c === e) return void n.splice(i, 1)
            }, t.dispatchEvent = function(t) {
                var e, i, n, r = this._listeners[t];
                if (r)
                    for (e = r.length, i = this._eventTarget; - 1 < --e;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                        type: t,
                        target: i
                    }) : n.c.call(n.s || i))
            };
            for (var l, M = d.requestAnimationFrame, E = d.cancelAnimationFrame, S = Date.now || function() {
                    return (new Date).getTime()
                }, A = S(), h = (l = ["ms", "moz", "webkit", "o"]).length; - 1 < --h && !M;) M = d[l[h] + "RequestAnimationFrame"], E = d[l[h] + "CancelAnimationFrame"] || d[l[h] + "CancelRequestAnimationFrame"];
            b("Ticker", function(t, e) {
                var n, r, s, a, o, l = this,
                    h = S(),
                    i = !1 !== e && M,
                    c = 500,
                    u = 33,
                    d = function(t) {
                        var e, i = S() - A;
                        c < i && (h += i - u), A += i, l.time = (A - h) / 1e3, i = l.time - o, (!n || 0 < i || !0 === t) && (l.frame++, o += i + (a <= i ? .004 : a - i), e = !0), !0 !== t && (s = r(d)), e && l.dispatchEvent("tick")
                    };
                T.call(l), l.time = l.frame = 0, l.tick = function() {
                    d(!0)
                }, l.lagSmoothing = function(t, e) {
                    c = t || 1e10, u = Math.min(e, c, 0)
                }, l.sleep = function() {
                    null != s && ((i && E ? E : clearTimeout)(s), r = v, s = null, l === C && (f = !1))
                }, l.wake = function() {
                    null !== s ? l.sleep() : 10 < l.frame && (A = S() - c + 5), r = 0 === n ? v : i && M ? M : function(t) {
                        return setTimeout(t, 1e3 * (o - l.time) + 1 | 0)
                    }, l === C && (f = !0), d(2)
                }, l.fps = function(t) {
                    if (!arguments.length) return n;
                    a = 1 / ((n = t) || 60), o = this.time + a, l.wake()
                }, l.useRAF = function(t) {
                    if (!arguments.length) return i;
                    l.sleep(), i = t, l.fps(n)
                }, l.fps(t), setTimeout(function() {
                    i && l.frame < 5 && l.useRAF(!1)
                }, 1500)
            }), (t = u.Ticker.prototype = new u.events.EventDispatcher).constructor = u.Ticker;
            var P = b("core.Animation", function(t, e) {
                    this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, q && (f || C.wake(), (e = this.vars.useFrames ? X : q).add(this, e._time), this.vars.paused && this.paused(!0))
                }),
                C = P.ticker = new u.Ticker;
            (t = P.prototype)._dirty = t._gc = t._initted = t._paused = !1, t._totalTime = t._time = 0, t._rawPrevTime = -1, t._next = t._last = t._onUpdate = t._timeline = t.timeline = null, t._paused = !1;
            var R = function() {
                f && 2e3 < S() - A && C.wake(), setTimeout(R, 2e3)
            };
            R(), t.play = function(t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, t.pause = function(t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, t.resume = function(t, e) {
                return null != t && this.seek(t, e), this.paused(!1)
            }, t.seek = function(t, e) {
                return this.totalTime(Number(t), !1 !== e)
            }, t.restart = function(t, e) {
                return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
            }, t.reverse = function(t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, t.render = function(t, e, i) {}, t.invalidate = function() {
                return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
            }, t.isActive = function() {
                var t, e = this._timeline,
                    i = this._startTime;
                return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime()) >= i && t < i + this.totalDuration() / this._timeScale
            }, t._enabled = function(t, e) {
                return f || C.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
            }, t._kill = function(t, e) {
                return this._enabled(!1, !1)
            }, t.kill = function(t, e) {
                return this._kill(t, e), this
            }, t._uncache = function(t) {
                for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                return this
            }, t._swapSelfInParams = function(t) {
                for (var e = t.length, i = t.concat(); - 1 < --e;) "{self}" === t[e] && (i[e] = this);
                return i
            }, t._callback = function(t) {
                var e = this.vars;
                e[t].apply(e[t + "Scope"] || e.callbackScope || this, e[t + "Params"] || s)
            }, t.eventCallback = function(t, e, i, n) {
                if ("on" === (t || "").substr(0, 2)) {
                    var r = this.vars;
                    if (1 === arguments.length) return r[t];
                    null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = _(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                }
                return this
            }, t.delay = function(t) {
                return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
            }, t.duration = function(t) {
                return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && 0 < this._time && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
            }, t.totalDuration = function(t) {
                return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
            }, t.time = function(t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
            }, t.totalTime = function(t, e, i) {
                if (f || C.wake(), !arguments.length) return this._totalTime;
                if (this._timeline) {
                    if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                        this._dirty && this.totalDuration();
                        var n = this._totalDuration,
                            r = this._timeline;
                        if (n < t && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                            for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                    }
                    this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (k.length && Z(), this.render(t, e, !1), k.length && Z())
                }
                return this
            }, t.progress = t.totalProgress = function(t, e) {
                var i = this.duration();
                return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
            }, t.startTime = function(t) {
                return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
            }, t.endTime = function(t) {
                return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
            }, t.timeScale = function(t) {
                return arguments.length ? (t = t || g, this._timeline && this._timeline.smoothChildTiming && (e = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = e - (e - this._startTime) * this._timeScale / t), this._timeScale = t, this._uncache(!1)) : this._timeScale;
                var e
            }, t.reversed = function(t) {
                return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
            }, t.paused = function(t) {
                if (!arguments.length) return this._paused;
                var e, i, n = this._timeline;
                return t != this._paused && n && (f || t || C.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 != i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
            };
            var L = b("core.SimpleTimeline", function(t) {
                P.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            (t = L.prototype = new P).constructor = L, t.kill()._gc = !1, t._first = t._last = t._recent = null, t._sortChildren = !1, t.add = t.insert = function(t, e, i, n) {
                var r, s;
                if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                    for (s = t._startTime; r && r._startTime > s;) r = r._prev;
                return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
            }, t._remove = function(t, e) {
                return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
            }, t.render = function(t, e, i) {
                var n, r = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
            }, t.rawTime = function() {
                return f || C.wake(), this._totalTime
            };
            var O = b("TweenLite", function(t, e, i) {
                    if (P.call(this, e, i), this.render = O.prototype.render, null == t) throw "Cannot tween a null target.";
                    this.target = t = "string" == typeof t && O.selector(t) || t;
                    var n, r, s, i = t.jquery || t.length && t !== d && t[0] && (t[0] === d || t[0].nodeType && t[0].style && !t.nodeType),
                        a = this.vars.overwrite;
                    if (this._overwrite = a = null == a ? W[O.defaultOverwrite] : "number" == typeof a ? a >> 0 : W[a], (i || t instanceof Array || t.push && _(t)) && "number" != typeof t[0])
                        for (this._targets = s = o(t), this._propLookup = [], this._siblings = [], n = 0; n < s.length; n++)(r = s[n]) ? "string" != typeof r ? r.length && r !== d && r[0] && (r[0] === d || r[0].nodeType && r[0].style && !r.nodeType) ? (s.splice(n--, 1), this._targets = s = s.concat(o(r))) : (this._siblings[n] = J(r, this, !1), 1 === a && 1 < this._siblings[n].length && K(r, this, null, 1, this._siblings[n])) : "string" == typeof(r = s[n--] = O.selector(r)) && s.splice(n + 1, 1) : s.splice(n--, 1);
                    else this._propLookup = {}, this._siblings = J(t, this, !1), 1 === a && 1 < this._siblings.length && K(t, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -g, this.render(-this._delay))
                }, !0),
                D = function(t) {
                    return t && t.length && t !== d && t[0] && (t[0] === d || t[0].nodeType && t[0].style && !t.nodeType)
                };
            (t = O.prototype = new P).constructor = O, t.kill()._gc = !1, t.ratio = 0, t._firstPT = t._targets = t._overwrittenProps = t._startAt = null, t._notifyPluginsOfEnabled = t._lazy = !1, O.version = "1.18.0", O.defaultEase = t._ease = new c(null, null, 1, 1), O.defaultOverwrite = "auto", O.ticker = C, O.autoSleep = 120, O.lagSmoothing = function(t, e) {
                C.lagSmoothing(t, e)
            }, O.selector = d.$ || d.jQuery || function(t) {
                var e = d.$ || d.jQuery;
                return e ? (O.selector = e)(t) : "undefined" == typeof document ? t : document.querySelectorAll ? document.querySelectorAll(t) : document.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
            };
            var k = [],
                I = {},
                N = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                z = function(t) {
                    for (var e, i = this._firstPT; i;) e = i.blob ? t ? this.join("") : this.start : i.c * t + i.s, i.r ? e = Math.round(e) : e < 1e-6 && -1e-6 < e && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                },
                B = function(t, e, i, n) {
                    var r, s, a, o, l, h, c = [t, e],
                        u = 0,
                        d = "",
                        p = 0;
                    for (c.start = t, i && (i(c), t = c[0], e = c[1]), c.length = 0, r = t.match(N) || [], s = e.match(N) || [], n && (n._next = null, n.blob = 1, c._firstPT = n), o = s.length, a = 0; a < o; a++) h = s[a], d += (l = e.substr(u, e.indexOf(h, u) - u)) || !a ? l : ",", u += l.length, p ? p = (p + 1) % 5 : "rgba(" === l.substr(-5) && (p = 1), h === r[a] || r.length <= a ? d += h : (d && (c.push(d), d = ""), l = parseFloat(r[a]), c.push(l), c._firstPT = {
                        _next: c._firstPT,
                        t: c,
                        p: c.length - 1,
                        s: l,
                        c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - l) || 0,
                        f: 0,
                        r: p && p < 4
                    }), u += h.length;
                    return (d += e.substr(u)) && c.push(d), c.setRatio = z, c
                },
                U = function(t, e, i, n, r, s, a, o) {
                    var l = "get" === i ? t[e] : i,
                        h = typeof t[e],
                        c = "string" == typeof n && "=" === n.charAt(1),
                        s = {
                            t: t,
                            p: e,
                            s: l,
                            f: "function" == h,
                            pg: 0,
                            n: r || e,
                            r: s,
                            pr: 0,
                            c: c ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - l || 0
                        };
                    if ("number" != h && ("function" == h && "get" === i && (i = e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3), s.s = l = a ? t[i](a) : t[i]()), "string" == typeof l && (a || isNaN(l)) ? (s.fp = a, s = {
                            t: B(l, n, o || O.defaultStringFilter, s),
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 2,
                            pg: 0,
                            n: r || e,
                            pr: 0
                        }) : c || (s.c = parseFloat(n) - parseFloat(l) || 0)), s.c) return (s._next = this._firstPT) && (s._next._prev = s), this._firstPT = s
                },
                F = O._internals = {
                    isArray: _,
                    isSelector: D,
                    lazyTweens: k,
                    blobDif: B
                },
                H = O._plugins = {},
                G = F.tweenLookup = {},
                V = 0,
                j = F.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1,
                    stringFilter: 1
                },
                W = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    true: 1,
                    false: 0
                },
                X = P._rootFramesTimeline = new L,
                q = P._rootTimeline = new L,
                Y = 30,
                Z = F.lazyRender = function() {
                    var t, e = k.length;
                    for (I = {}; - 1 < --e;)(t = k[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                    k.length = 0
                };
            q._startTime = C.time, X._startTime = C.frame, q._active = X._active = !0, setTimeout(Z, 1), P._updateRoot = O.render = function() {
                var t, e, i;
                if (k.length && Z(), q.render((C.time - q._startTime) * q._timeScale, !1, !1), X.render((C.frame - X._startTime) * X._timeScale, !1, !1), k.length && Z(), C.frame >= Y) {
                    for (i in Y = C.frame + (parseInt(O.autoSleep, 10) || 120), G) {
                        for (t = (e = G[i].tweens).length; - 1 < --t;) e[t]._gc && e.splice(t, 1);
                        0 === e.length && delete G[i]
                    }
                    if (i = q._first, (!i || i._paused) && O.autoSleep && !X._first && 1 === C._listeners.tick.length) {
                        for (; i && i._paused;) i = i._next;
                        i || C.sleep()
                    }
                }
            }, C.addEventListener("tick", P._updateRoot);
            var J = function(t, e, i) {
                    var n, r, s = t._gsTweenID;
                    if (G[s || (t._gsTweenID = s = "t" + V++)] || (G[s] = {
                            target: t,
                            tweens: []
                        }), e && ((n = G[s].tweens)[r = n.length] = e, i))
                        for (; - 1 < --r;) n[r] === e && n.splice(r, 1);
                    return G[s].tweens
                },
                Q = function(t, e, i, n) {
                    var r, s, a = t.vars.onOverwrite;
                    return a && (r = a(t, e, i, n)), (a = O.onOverwrite) && (s = a(t, e, i, n)), !1 !== r && !1 !== s
                },
                K = function(t, e, i, n, r) {
                    var s, a, o;
                    if (1 === n || 4 <= n) {
                        for (o = r.length, p = 0; p < o; p++)
                            if ((a = r[p]) !== e) a._gc || a._kill(null, t, e) && (s = !0);
                            else if (5 === n) break;
                        return s
                    }
                    for (var l, h = e._startTime + g, c = [], u = 0, d = 0 === e._duration, p = r.length; - 1 < --p;)(a = r[p]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (l = l || $(e, 0, d), 0 === $(a, l, d) && (c[u++] = a)) : a._startTime <= h && a._startTime + a.totalDuration() / a._timeScale > h && ((d || !a._initted) && h - a._startTime <= 2e-10 || (c[u++] = a)));
                    for (p = u; - 1 < --p;) a = c[p], 2 === n && a._kill(i, t, e) && (s = !0), (2 !== n || !a._firstPT && a._initted) && (2 === n || Q(a, e)) && a._enabled(!1, !1) && (s = !0);
                    return s
                },
                $ = function(t, e, i) {
                    for (var n = t._timeline, r = n._timeScale, s = t._startTime; n._timeline;) {
                        if (s += n._startTime, r *= n._timeScale, n._paused) return -100;
                        n = n._timeline
                    }
                    return e < (s /= r) ? s - e : i && s === e || !t._initted && s - e < 2e-10 ? g : (s += t.totalDuration() / t._timeScale / r) > e + g ? 0 : s - e - g
                };
            t._init = function() {
                var t, e, i, n, r, s = this.vars,
                    a = this._overwrittenProps,
                    o = this._duration,
                    l = !!s.immediateRender,
                    h = s.ease;
                if (s.startAt) {
                    for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, s.startAt) r[n] = s.startAt[n];
                    if (r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== s.lazy, r.startAt = r.delay = null, this._startAt = O.to(this.target, 0, r), l)
                        if (0 < this._time) this._startAt = null;
                        else if (0 !== o) return
                } else if (s.runBackwards && 0 !== o)
                    if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                    else {
                        for (n in 0 !== this._time && (l = !1), i = {}, s) j[n] && "autoCSS" !== n || (i[n] = s[n]);
                        if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && !1 !== s.lazy, i.immediateRender = l, this._startAt = O.to(this.target, 0, i), l) {
                            if (0 === this._time) return
                        } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                    }
                if (this._ease = h = h ? h instanceof c ? h : "function" == typeof h ? new c(h, s.easeParams) : w[h] || O.defaultEase : O.defaultEase, s.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                    for (t = this._targets.length; - 1 < --t;) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null) && (e = !0);
                else e = this._initProps(this.target, this._propLookup, this._siblings, a);
                if (e && O._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards)
                    for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                this._onUpdate = s.onUpdate, this._initted = !0
            }, t._initProps = function(t, e, i, n) {
                var r, s, a, o, l, h;
                if (null == t) return !1;
                for (r in I[t._gsTweenID] && Z(), this.vars.css || t.style && t !== d && t.nodeType && H.css && !1 !== this.vars.autoCSS && function(t, e) {
                        var i, n = {};
                        for (i in t) j[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!H[i] || H[i] && H[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                        t.css = n
                    }(this.vars, t), this.vars)
                    if (h = this.vars[r], j[r]) h && (h instanceof Array || h.push && _(h)) && -1 !== h.join("").indexOf("{self}") && (this.vars[r] = h = this._swapSelfInParams(h, this));
                    else if (H[r] && (o = new H[r])._onInitTween(t, this.vars[r], this)) {
                    for (this._firstPT = l = {
                            _next: this._firstPT,
                            t: o,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 1,
                            n: r,
                            pg: 1,
                            pr: o._priority
                        }, s = o._overwriteProps.length; - 1 < --s;) e[o._overwriteProps[s]] = this._firstPT;
                    (o._priority || o._onInitAllProps) && (a = !0), (o._onDisable || o._onEnable) && (this._notifyPluginsOfEnabled = !0), l._next && (l._next._prev = l)
                } else e[r] = U.call(this, t, r, "get", h, r, 0, null, this.vars.stringFilter);
                return n && this._kill(n, t) ? this._initProps(t, e, i, n) : 1 < this._overwrite && this._firstPT && 1 < i.length && K(t, this, e, this._overwrite, i) ? (this._kill(e, t), this._initProps(t, e, i, n)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (I[t._gsTweenID] = !0), a)
            }, t.render = function(t, e, i) {
                var n, r, s, a, o, l, h, c = this._time,
                    u = this._duration,
                    d = this._rawPrevTime;
                if (u <= t ? (this._totalTime = this._time = u, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === u && (!this._initted && this.vars.lazy && !i || (this._startTime === this._timeline._duration && (t = 0), (0 === t || d < 0 || d === g && "isPause" !== this.data) && d !== t && (i = !0, g < d && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || d === t ? t : g))) : t < 1e-7 ? (this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== c || 0 === u && 0 < d) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === u && (!this._initted && this.vars.lazy && !i || (0 <= d && (d !== g || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || d === t ? t : g))), this._initted || (i = !0)) : (this._totalTime = this._time = t, this._easeType ? (o = t / u, (1 === (l = this._easeType) || 3 === l && .5 <= o) && (o = 1 - o), 3 === l && (o *= 2), 1 === (h = this._easePower) ? o *= o : 2 === h ? o *= o * o : 3 === h ? o *= o * o * o : 4 === h && (o *= o * o * o * o), this.ratio = 1 === l ? 1 - o : 2 === l ? o : t / u < .5 ? o / 2 : 1 - o / 2) : this.ratio = this._ease.getRatio(t / u)), this._time !== c || i) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = c, this._rawPrevTime = d, k.push(this), void(this._lazy = [t, e]);
                        this._time && !n ? this.ratio = this._ease.getRatio(this._time / u) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== c && 0 <= t && (this._active = !0), 0 === c && (this._startAt && (0 <= t ? this._startAt.render(t, e, i) : r = r || "_dummyGS"), this.vars.onStart && (0 === this._time && 0 !== u || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                    this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, e, i), e || this._time === c && !n || this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, e, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === u && this._rawPrevTime === g && a !== g && (this._rawPrevTime = 0)))
                }
            }, t._kill = function(t, e, i) {
                if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                e = "string" != typeof e ? e || this._targets || this.target : O.selector(e) || e;
                var n, r, s, a, o, l, h, c, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                if ((_(e) || D(e)) && "number" != typeof e[0])
                    for (n = e.length; - 1 < --n;) this._kill(t, e[n], i) && (l = !0);
                else {
                    if (this._targets) {
                        for (n = this._targets.length; - 1 < --n;)
                            if (e === this._targets[n]) {
                                o = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                break
                            }
                    } else {
                        if (e !== this.target) return !1;
                        o = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                    }
                    if (o) {
                        if (h = t || o, c = t !== r && "all" !== r && t !== o && ("object" != typeof t || !t._tempKill), i && (O.onOverwrite || this.vars.onOverwrite)) {
                            for (s in h) o[s] && (u = u || []).push(s);
                            if ((u || !t) && !Q(this, i, e, u)) return !1
                        }
                        for (s in h)(a = o[s]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(h) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete o[s]), c && (r[s] = 1);
                        !this._firstPT && this._initted && this._enabled(!1, !1)
                    }
                }
                return l
            }, t.invalidate = function() {
                return this._notifyPluginsOfEnabled && O._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], P.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -g, this.render(-this._delay)), this
            }, t._enabled = function(t, e) {
                if (f || C.wake(), t && this._gc) {
                    var i, n = this._targets;
                    if (n)
                        for (i = n.length; - 1 < --i;) this._siblings[i] = J(n[i], this, !0);
                    else this._siblings = J(this.target, this, !0)
                }
                return P.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && O._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
            }, O.to = function(t, e, i) {
                return new O(t, e, i)
            }, O.from = function(t, e, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new O(t, e, i)
            }, O.fromTo = function(t, e, i, n) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new O(t, e, n)
            }, O.delayedCall = function(t, e, i, n, r) {
                return new O(e, 0, {
                    delay: t,
                    onComplete: e,
                    onCompleteParams: i,
                    callbackScope: n,
                    onReverseComplete: e,
                    onReverseCompleteParams: i,
                    immediateRender: !1,
                    lazy: !1,
                    useFrames: r,
                    overwrite: 0
                })
            }, O.set = function(t, e) {
                return new O(t, 0, e)
            }, O.getTweensOf = function(t, e) {
                if (null == t) return [];
                var i, n, r, s;
                if (t = "string" == typeof t && O.selector(t) || t, (_(t) || D(t)) && "number" != typeof t[0]) {
                    for (i = t.length, n = []; - 1 < --i;) n = n.concat(O.getTweensOf(t[i], e));
                    for (i = n.length; - 1 < --i;)
                        for (s = n[i], r = i; - 1 < --r;) s === n[r] && n.splice(i, 1)
                } else
                    for (i = (n = J(t).concat()).length; - 1 < --i;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                return n
            }, O.killTweensOf = O.killDelayedCallsTo = function(t, e, i) {
                "object" == typeof e && (i = e, e = !1);
                for (var n = O.getTweensOf(t, e), r = n.length; - 1 < --r;) n[r]._kill(i, t)
            };
            var tt = b("plugins.TweenPlugin", function(t, e) {
                this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = tt.prototype
            }, !0);
            if (t = tt.prototype, tt.version = "1.18.0", tt.API = 2, t._firstPT = null, t._addTween = U, t.setRatio = z, t._kill = function(t) {
                    var e, i = this._overwriteProps,
                        n = this._firstPT;
                    if (null != t[this._propName]) this._overwriteProps = [];
                    else
                        for (e = i.length; - 1 < --e;) null != t[i[e]] && i.splice(e, 1);
                    for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                    return !1
                }, t._roundProps = function(t, e) {
                    for (var i = this._firstPT; i;)(t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next
                }, O._onPluginEvent = function(t, e) {
                    var i, n, r, s, a, o = e._firstPT;
                    if ("_onInitAllProps" === t) {
                        for (; o;) {
                            for (a = o._next, n = r; n && n.pr > o.pr;) n = n._next;
                            (o._prev = n ? n._prev : s) ? o._prev._next = o: r = o, (o._next = n) ? n._prev = o : s = o, o = a
                        }
                        o = e._firstPT = r
                    }
                    for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;
                    return i
                }, tt.activate = function(t) {
                    for (var e = t.length; - 1 < --e;) t[e].API === tt.API && (H[(new t[e])._propName] = t[e]);
                    return !0
                }, n.plugin = function(t) {
                    if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                    var e, i = t.propName,
                        n = t.priority || 0,
                        r = t.overwriteProps,
                        s = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_roundProps",
                            initAll: "_onInitAllProps"
                        },
                        a = b("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                            tt.call(this, i, n), this._overwriteProps = r || []
                        }, !0 === t.global),
                        o = a.prototype = new tt(i);
                    for (e in (o.constructor = a).API = t.API, s) "function" == typeof t[e] && (o[s[e]] = t[e]);
                    return a.version = t.version, tt.activate([a]), a
                }, l = d._gsQueue) {
                for (h = 0; h < l.length; h++) l[h]();
                for (t in y) y[t].func || d.console.log("GSAP encountered missing dependency: com.greensock." + t)
            }
            f = !1
        }
    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window), define("../libs/TweenMax", function() {});
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";
        var t = _gsScope.document,
            c = t.defaultView ? t.defaultView.getComputedStyle : function() {},
            h = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
            u = -1 !== ((_gsScope.navigator || {}).userAgent || "").indexOf("Edge");

        function d(t, e, i, n, r, s) {
            return i = (parseFloat(i || 0) - parseFloat(t || 0)) * r, n = (parseFloat(n || 0) - parseFloat(e || 0)) * s, Math.sqrt(i * i + n * n)
        }

        function p(t) {
            return "string" != typeof t && t.nodeType || (t = _gsScope.TweenLite.selector(t)).length && (t = t[0]), t
        }

        function f(t) {
            if (!t) return 0;
            var e, i, n, r, s, a = (t = p(t)).tagName.toLowerCase(),
                o = 1,
                l = 1;
            "non-scaling-stroke" === t.getAttribute("vector-effect") && (o = (l = t.getScreenCTM()).a, l = l.d);
            try {
                i = t.getBBox()
            } catch (t) {
                console.log("Error: Some browsers like Firefox won't report measurements of invisible elements (like display:none).")
            }
            if (i && (i.width || i.height) || "rect" !== a && "circle" !== a && "ellipse" !== a || (i = {
                    width: parseFloat(t.getAttribute("rect" === a ? "width" : "circle" === a ? "r" : "rx")),
                    height: parseFloat(t.getAttribute("rect" === a ? "height" : "circle" === a ? "r" : "ry"))
                }, "rect" !== a && (i.width *= 2, i.height *= 2)), "path" === a) s = t.style.strokeDasharray, t.style.strokeDasharray = "none", e = t.getTotalLength() || 0, o !== l && console.log("Warning: <path> length cannot be measured accurately when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), e *= (o + l) / 2, t.style.strokeDasharray = s;
            else if ("rect" === a) e = 2 * i.width * o + 2 * i.height * l;
            else if ("line" === a) e = d(i.x, i.y, i.x + i.width, i.y + i.height, o, l);
            else if ("polyline" === a || "polygon" === a)
                for (n = t.getAttribute("points").match(h) || [], "polygon" === a && n.push(n[0], n[1]), e = 0, r = 2; r < n.length; r += 2) e += d(n[r - 2], n[r - 1], n[r], n[r + 1], o, l) || 0;
            else "circle" !== a && "ellipse" !== a || (s = i.width / 2 * o, a = i.height / 2 * l, e = Math.PI * (3 * (s + a) - Math.sqrt((3 * s + a) * (s + 3 * a))));
            return e || 0
        }

        function m(t, e) {
            if (!t) return [0, 0];
            t = p(t), e = e || f(t) + 1;
            var i = c(t),
                n = i.strokeDasharray || "",
                t = parseFloat(i.strokeDashoffset),
                i = n.indexOf(",");
            return i < 0 && (i = n.indexOf(" ")), e < (n = i < 0 ? e : parseFloat(n.substr(0, i)) || 1e-5) && (n = e), [Math.max(0, -t), Math.max(0, n - t)]
        }(t = _gsScope._gsDefine.plugin({
            propName: "drawSVG",
            API: 2,
            version: "0.1.5",
            global: !0,
            overwriteProps: ["drawSVG"],
            init: function(t, e, i, n) {
                if (!t.getBBox) return !1;
                var r, s, a, o, l, h = f(t) + 1;
                return this._style = t.style, "function" == typeof e && (e = e(n, t)), !0 === e || "true" === e ? e = "0 100%" : e ? -1 === (e + "").indexOf(" ") && (e = "0 " + e) : e = "0 0", r = m(t, h), a = e, o = h, n = r[0], e = -1 === (e = a.indexOf(" ")) ? (l = void 0 !== n ? n + "" : a, a) : (l = a.substr(0, e), a.substr(e + 1)), l = -1 !== l.indexOf("%") ? parseFloat(l) / 100 * o : parseFloat(l), l = (e = -1 !== e.indexOf("%") ? parseFloat(e) / 100 * o : parseFloat(e)) < l ? [e, l] : [l, e], this._length = h + 10, 0 === r[0] && 0 === l[0] ? (e = Math.max(1e-5, l[1] - h), this._dash = h + e, this._offset = h - r[1] + e, this._addTween(this, "_offset", this._offset, h - l[1] + e, "drawSVG")) : (this._dash = r[1] - r[0] || 1e-6, this._offset = -r[0], this._addTween(this, "_dash", this._dash, l[1] - l[0] || 1e-5, "drawSVG"), this._addTween(this, "_offset", this._offset, -l[0], "drawSVG")), u && "butt" !== (l = (s = c(t)).strokeLinecap) && l !== s.strokeLinejoin && (l = parseFloat(s.strokeMiterlimit), this._addTween(t.style, "strokeMiterlimit", l, l + 1e-4, "strokeMiterlimit")), !0
            },
            set: function(t) {
                this._firstPT && (this._super.setRatio.call(this, t), this._style.strokeDashoffset = this._offset, this._style.strokeDasharray = 1 === t || 0 === t ? this._offset < .001 && this._length - this._dash <= 10 ? "none" : this._offset === this._dash ? "0px, 999999px" : this._dash + "px," + this._length + "px" : this._dash + "px," + this._length + "px")
            }
        })).getLength = f, t.getPosition = m
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function() {
        "use strict";

        function t() {
            return (_gsScope.GreenSockGlobals || _gsScope).DrawSVGPlugin
        }
        "undefined" != typeof module && module.exports ? (require("../libs/TweenMax"), module.exports = t()) : "function" == typeof define && define.amd && define("DrawSVGPlugin", ["../libs/TweenMax"], t)
    }(), define("svg/svg-slider.decorator", ["dispatcher", "slide-scroll/slide-scroll.store", "resize/resize.store", "TweenMax", "DrawSVGPlugin"], function(t, a, o, l, e) {
        "use strict";
        var h = "svg-slider";
        if (window._registeredDecorators || (window._registeredDecorators = []), -1 === window._registeredDecorators.indexOf(h)) {
            window._registeredDecorators.push(h);
            return {
                attach: function(t) {
                    var e = {};
                    if (t._decorators || (t._decorators = {}), (t._decorators[h] = e).handleResize = function() {
                            var t = this._decorators[h],
                                e = this._svg.getBoundingClientRect();
                            t._slider && t._slider.element && (t._slider.element.style.width = e.width + "px", t._slider.element.style.height = e.height + "px")
                        }.bind(t), t.sliderShow = function() {
                            var r = this._decorators[h],
                                t = a.getData().items[this._slideId];
                            r._slider.element.style.opacity = 1, r._sliderShift = 0, t.active && r._slider.inner && (r._sliderIv = setInterval(function() {
                                for (var t = r._slider.groups[r._sliderShift].children, e = Array.prototype.slice.call(t), i = 0; i < e.length; i++) {
                                    var n = e[i];
                                    l.to(n, 1.2, {
                                        drawSVG: "0 100%",
                                        opacity: 1,
                                        ease: l._easings.basic
                                    }), r._sliderShift !== r._slider.groups.length - 1 && l.to(n, .4, {
                                        delay: 1.4,
                                        opacity: 0,
                                        ease: l._easings.basic
                                    })
                                }
                                r._sliderShift++, r._sliderShift >= r._slider.groups.length && clearInterval(r._sliderIv)
                            }, 2300))
                        }.bind(t), t.sliderHide = function() {
                            var t = this._decorators[h];
                            if (t._slider.element.style.opacity = 0, t._slider.groups && 0 < t._slider.groups.length)
                                for (var e = 0; e < t._slider.groups.length; e++)
                                    for (var i = t._slider.groups[e].children, n = Array.prototype.slice.call(i), r = 0; r < n.length; r++) {
                                        var s = n[r];
                                        l.to(s, 0, {
                                            drawSVG: "0%"
                                        })
                                    }
                            t._slider.inner && setTimeout(function() {
                                t._slider.inner.style = ""
                            }, 1e3), clearInterval(t._sliderIv)
                        }.bind(t), e._sliderElement = t.getElementsByClassName("svg-slider")[0], e._sliderElement && (e._slider = {
                            element: e._sliderElement,
                            inner: t.getElementsByClassName("svg-slider-inner")[0],
                            groups: e._sliderElement.getElementsByTagName("g")
                        }), e.handleResize(), o.subscribe(e.handleResize), e._slider.groups)
                        for (var i = 0; i < e._slider.groups.length; i++)
                            for (var n = Array.prototype.slice.call(e._slider.groups[i].children), r = 0; r < n.length; r++) {
                                var s = n[r];
                                l.to(s, 0, {
                                    drawSVG: "0%"
                                })
                            }
                },
                detach: function(t) {
                    t._decorators && (t = t._decorators[h], o.unsubscribe(t.handleResize))
                }
            }
        }
        console.warn('error. decorator with name "' + h + '" already registered')
    }), define("svg/big-svg.component", ["dispatcher", "resize/resize.store", "slide-scroll/slide-scroll.store", "page-load/page-load.store", "svg/svg-slider.decorator", "TweenMax", "utils"], function(t, s, a, e, o, l, n) {
        "use strict";
        var i = Object.create(HTMLElement.prototype);
        return i.createdCallback = function() {
            this._slideId = "main-scroll", this._sliderShift = 0, this.trigger = function(t) {
                var e, i, n, r = this,
                    s = a.getData().appearDelay;
                a.getData().items[this._slideId];
                "function" == typeof this.onTrigger && this.onTrigger(), "function" == typeof this.sliderShow && this.sliderShow(), s = Math.abs(s), void 0 === t && (t = 1), this._sliderInner && (e = this._sliderInner, n = i = 0, e && e.style && (e.style.transition = e.style.webkitTransition = "transform " + n + "s ease", e.style.transform = e.style.webkitTransform = "translateX(" + i + "%)"), this._sliderShift = 0), setTimeout(function() {
                    r._triggered = !0, r._elements.forEach(function(t) {
                        t.style.strokeDashoffset = 0
                    })
                }, s), l.to(this._svg, .8 * t, {
                    x: 0,
                    y: 0,
                    delay: (.8 + s / 1e3) * t,
                    ease: Power2.easeInOut,
                    onComplete: function() {
                        r.onSliderInit && r.onSliderInit(), r._glow && (r._glow.style.opacity = 1)
                    }
                })
            }.bind(this), this.untrigger = function() {
                var t = a.getData().items[this._slideId];
                this._triggered = !1, "function" == typeof this.sliderHide && this.sliderHide(), t.active && (this._elements.forEach(function(t) {
                    t.style.strokeDashoffset = t._totalLength
                }), l.killTweensOf(this._svg), l.to(this._svg, 0, {
                    x: -this._centerOffset.x,
                    y: -this._centerOffset.y,
                    delay: .6
                }), this._glow && (this._glow.style.opacity = 0), this._slider && (this._slider.element.style.opacity = 0), clearInterval(this._sliderIv))
            }.bind(this), this.handleResize = function() {
                var t = this.closest(".s-slide"),
                    e = a.getData().items[this._slideId],
                    i = this._svg.getBoundingClientRect();
                if (this._scale = i.width / this._svg.viewBox.baseVal.width || 1, this.build(), !e) return this._resizeSubscribed = !0, void a.subscribe(this.handleResize);
                this._resizeSubscribed && a.unsubscribe(this.handleResize), e = e.active, this._offset = n.offsetFrom(this, this.closest(".s-slide")), this._w = this.clientWidth, this._h = this.clientHeight, this._centerOffset = {
                    x: this._offset.left - t.clientWidth / 2 + this._w / 2,
                    y: 0
                }, !this._triggered && e ? l.to(this._svg, 0, {
                    x: -this._centerOffset.x,
                    y: -this._centerOffset.y
                }) : l.set(this._svg, {
                    x: 0,
                    y: 0
                }), this._slider && this._slider.element && (this._slider.element.style.width = i.width + "px", this._slider.element.style.height = i.height + "px")
            }.bind(this), this.build = function() {
                var i = this,
                    n = a.getData().items[this._slideId];
                this._elements.forEach(function(t) {
                    var e = (e = t.getTotalLength()) * i._scale + 100;
                    t._totalLength = e, t.style.strokeDasharray = e, !i._triggered && n && n.active && (t.style.strokeDashoffset = e)
                })
            }.bind(this)
        }, i.attachedCallback = function() {
            var t = this.getElementsByTagName("svg")[0],
                e = Array.prototype.slice.call(t.getElementsByTagName("path")),
                i = Array.prototype.slice.call(t.getElementsByTagName("rect")),
                n = Array.prototype.slice.call(t.getElementsByTagName("circle")),
                r = Array.prototype.slice.call(t.getElementsByTagName("polyline"));
            this._svg = t, this._fake = this.getElementsByClassName("fake")[0], this._glow = this.getElementsByClassName("glow")[0], this._sliderElement = this.getElementsByClassName("svg-slider")[0], this._mask = this.getAttribute("data-mask"), this._elements = [], this._elements = this._elements.concat(e), this._elements = this._elements.concat(i), this._elements = this._elements.concat(n), this._elements = this._elements.concat(r), this.handleResize(), this.build(), this._sliderElement && a.getData().items["main-scroll"].active && o.attach(this), s.subscribe(this.handleResize)
        }, i.detachedCallback = function() {
            s.unsubscribe(this.handleResize), this._sliderElement && o.detach(this), this._mask && t.dispatch({
                type: "stage:hide-mask",
                mask: this._mask
            })
        }, document.registerElement("big-svg", {
            prototype: i
        }), i
    }), define("text", ["module"], function(t) {
        "use strict";
        var l, r, a, o, h, n = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"],
            i = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
            s = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
            c = "undefined" != typeof location && location.href,
            u = c && location.protocol && location.protocol.replace(/\:/, ""),
            d = c && location.hostname,
            p = c && (location.port || void 0),
            f = {},
            m = t.config && t.config() || {};

        function g(t, e) {
            return void 0 === t || "" === t ? e : t
        }
        return l = {
            version: "2.0.15",
            strip: function(t) {
                var e;
                return t ? (e = (t = t.replace(i, "")).match(s)) && (t = e[1]) : t = "", t
            },
            jsEscape: function(t) {
                return t.replace(/(['\\])/g, "\\$1").replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r").replace(/[\u2028]/g, "\\u2028").replace(/[\u2029]/g, "\\u2029")
            },
            createXhr: m.createXhr || function() {
                var t, e, i;
                if ("undefined" != typeof XMLHttpRequest) return new XMLHttpRequest;
                if ("undefined" != typeof ActiveXObject)
                    for (e = 0; e < 3; e += 1) {
                        i = n[e];
                        try {
                            t = new ActiveXObject(i)
                        } catch (t) {}
                        if (t) {
                            n = [i];
                            break
                        }
                    }
                return t
            },
            parseName: function(t) {
                var e, i, n = !1,
                    r = t.lastIndexOf("."),
                    s = 0 === t.indexOf("./") || 0 === t.indexOf("../");
                return -1 !== r && (!s || 1 < r) ? (e = t.substring(0, r), i = t.substring(r + 1)) : e = t, -1 !== (r = (t = i || e).indexOf("!")) && (n = "strip" === t.substring(r + 1), t = t.substring(0, r), i ? i = t : e = t), {
                    moduleName: e,
                    ext: i,
                    strip: n
                }
            },
            xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,
            useXhr: function(t, e, i, n) {
                var r, s = l.xdRegExp.exec(t);
                return !s || (r = s[2], s = (t = (t = s[3]).split(":"))[1], t = t[0], (!r || r === e) && (!t || t.toLowerCase() === i.toLowerCase()) && (!s && !t || function(t, e, i, n) {
                    if (e === n) return !0;
                    if (t === i) {
                        if ("http" === t) return g(e, "80") === g(n, "80");
                        if ("https" === t) return g(e, "443") === g(n, "443")
                    }
                    return !1
                }(r, s, e, n)))
            },
            finishLoad: function(t, e, i, n) {
                i = e ? l.strip(i) : i, m.isBuild && (f[t] = i), n(i)
            },
            load: function(e, t, i, n) {
                var r, s, a;
                n && n.isBuild && !n.inlineText ? i() : (m.isBuild = n && n.isBuild, s = (r = l.parseName(e)).moduleName + (r.ext ? "." + r.ext : ""), a = t.toUrl(s), n = m.useXhr || l.useXhr, 0 !== a.indexOf("empty:") ? !c || n(a, u, d, p) ? l.get(a, function(t) {
                    l.finishLoad(e, r.strip, t, i)
                }, function(t) {
                    i.error && i.error(t)
                }) : t([s], function(t) {
                    l.finishLoad(r.moduleName + "." + r.ext, r.strip, t, i)
                }) : i())
            },
            write: function(t, e, i, n) {
                var r;
                f.hasOwnProperty(e) && (r = l.jsEscape(f[e]), i.asModule(t + "!" + e, "define(function () { return '" + r + "';});\n"))
            },
            writeFile: function(i, t, e, n, r) {
                var s = l.parseName(t),
                    t = s.ext ? "." + s.ext : "",
                    a = s.moduleName + t,
                    o = e.toUrl(s.moduleName + t) + ".js";
                l.load(a, e, function(t) {
                    function e(t) {
                        return n(o, t)
                    }
                    e.asModule = function(t, e) {
                        return n.asModule(t, o, e)
                    }, l.write(i, a, e, r)
                }, r)
            }
        }, "node" === m.env || !m.env && "undefined" != typeof process && process.versions && process.versions.node && !process.versions["node-webkit"] && !process.versions["atom-shell"] ? (r = require.nodeRequire("fs"), l.get = function(t, e, i) {
            try {
                var n = r.readFileSync(t, "utf8");
                "\ufeff" === n[0] && (n = n.substring(1)), e(n)
            } catch (t) {
                i && i(t)
            }
        }) : "xhr" === m.env || !m.env && l.createXhr() ? l.get = function(i, n, r, t) {
            var e, s = l.createXhr();
            if (s.open("GET", i, !0), t)
                for (e in t) t.hasOwnProperty(e) && s.setRequestHeader(e.toLowerCase(), t[e]);
            m.onXhr && m.onXhr(s, i), s.onreadystatechange = function(t) {
                var e;
                4 === s.readyState && (399 < (e = s.status || 0) && e < 600 ? ((e = new Error(i + " HTTP status: " + e)).xhr = s, r && r(e)) : n(s.responseText), m.onXhrComplete && m.onXhrComplete(s, i))
            }, s.send(null)
        } : "rhino" === m.env || !m.env && "undefined" != typeof Packages && "undefined" != typeof java ? l.get = function(t, e) {
            var i, n, t = new java.io.File(t),
                r = java.lang.System.getProperty("line.separator"),
                s = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(t), "utf-8")),
                a = "";
            try {
                for (i = new java.lang.StringBuffer, (n = s.readLine()) && n.length() && 65279 === n.charAt(0) && (n = n.substring(1)), null !== n && i.append(n); null !== (n = s.readLine());) i.append(r), i.append(n);
                a = String(i.toString())
            } finally {
                s.close()
            }
            e(a)
        } : ("xpconnect" === m.env || !m.env && "undefined" != typeof Components && Components.classes && Components.interfaces) && (a = Components.classes, o = Components.interfaces, Components.utils.import("resource://gre/modules/FileUtils.jsm"), h = "@mozilla.org/windows-registry-key;1" in a, l.get = function(t, e) {
            var i, n, r, s = {};
            h && (t = t.replace(/\//g, "\\")), r = new FileUtils.File(t);
            try {
                (i = a["@mozilla.org/network/file-input-stream;1"].createInstance(o.nsIFileInputStream)).init(r, 1, 0, !1), (n = a["@mozilla.org/intl/converter-input-stream;1"].createInstance(o.nsIConverterInputStream)).init(i, "utf-8", i.available(), o.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER), n.readString(i.available(), s), n.close(), i.close(), e(s.value)
            } catch (t) {
                throw new Error((r && r.path || "") + ": " + t)
            }
        }), l
    }), define("text!glsl/simple.vertex.glsl", [], function() {
        return "varying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"
    }), define("text!glsl/simple.fragment.glsl", [], function() {
        return "varying vec2 vUv;\nuniform sampler2D tDiffuse;\n\nvoid main() {\n\tvec4 color = texture2D(tDiffuse, vUv.xy);\n    gl_FragColor = color;\n}\n"
    }), define("utils/Composer", ["THREE", "text!glsl/simple.vertex.glsl", "text!glsl/simple.fragment.glsl"], function(a, e, i) {
        "use strict";
        return function(t) {
            this.passes = [], this.renderer = t, this.renderPass = function(t, e) {
                var i = this.renderer.getSize(),
                    i = new a.WebGLRenderTarget(i.width, i.height, {
                        minFilter: a.LinearFilter,
                        magFilter: a.LinearFilter
                    });
                this.passes.push({
                    scene: t,
                    camera: e,
                    target: i
                })
            }, this.shaderPass = function(t, e) {
                var i, n = this.renderer.getSize(),
                    r = this.renderer.getPixelRatio(),
                    s = new a.ShaderMaterial(t),
                    t = new a.PlaneBufferGeometry(1, 1),
                    t = new a.Mesh(t, s);
                return n.width *= r, n.height *= r, r = new a.WebGLRenderTarget(n.width, n.height, {
                    minFilter: a.LinearFilter,
                    magFilter: a.LinearFilter
                }), "perspective" === (e = e || {}).camera ? (i = 90 * Math.atan(n.height / 2 / 1e3), (i = new a.PerspectiveCamera(i, n.width / n.height, 100, 1500)).userData.distance = 1e3, i.position.set(0, 0, 1e3), i.up = new a.Vector3(0, 1, 0), i.lookAt(0, 0, 0)) : i = new a.OrthographicCamera(n.width / -2, n.width / 2, n.height / 2, n.height / -2, -100, 100), t.scale.set(n.width, n.height, 1), (n = e.scene || new a.Scene).add(t), e.texture ? s.uniforms.tDiffuse = {
                    type: "t",
                    value: e.texture.texture
                } : s.uniforms.tDiffuse = {
                    type: "t",
                    value: this.passes[this.passes.length - 1].target.texture
                }, this.passes.push({
                    scene: n,
                    camera: i,
                    mesh: t,
                    target: r
                }), {
                    mesh: t,
                    scene: n,
                    camera: i
                }
            }, this.copyPass = function(t) {
                return this.shaderPass({
                    uniforms: {},
                    vertexShader: e,
                    fragmentShader: i
                }, t)
            }, this.render = function(i) {
                var n = this;
                this.passes.forEach(function(t, e) {
                    e === n.passes.length - 1 ? i ? n.renderer.render(t.scene, t.camera, i) : n.renderer.render(t.scene, t.camera) : n.renderer.render(t.scene, t.camera, t.target)
                })
            }, this.updateUniforms = function(n) {
                this.passes.forEach(function(t, e) {
                    if (t.mesh)
                        for (var i in n) t.mesh.material.uniforms.hasOwnProperty(i) && (t.mesh.material.uniforms[i].value = n[i])
                })
            }, this.resize = function() {
                var e = this.renderer.getSize(),
                    i = this.renderer.getPixelRatio();
                this.passes.forEach(function(t) {
                    "OrthographicCamera" === t.camera.type ? (t.camera.left = e.width / -2, t.camera.right = e.width / 2, t.camera.top = e.height / 2, t.camera.bottom = e.height / -2, t.camera.updateProjectionMatrix()) : "PerspectiveCamera" === t.camera.type && (t.camera.aspect = e.width / e.height, t.camera.updateProjectionMatrix()), t.target.setSize(e.width * i, e.height * i), t.mesh && (t.mesh.material.uniforms.resolution && (t.mesh.material.uniforms.resolution.value = [e.width, e.height]), t.mesh.scale.set(e.width, e.height, 1))
                })
            }
        }
    }), define("text!glsl/img.fragment.glsl", [], function() {
        return "varying vec2 vUv;\nuniform sampler2D activeMap;\nuniform sampler2D previousMap;\nuniform float activeZoom;\nuniform float previousZoom;\nuniform vec2 resolution;\nuniform vec2 textureSize;\n\n// uniform float appear;\nuniform vec2 cursor;\nuniform vec3 cursorData;\nuniform vec2 transitionCenter;\nuniform float mapTransition;\n\n#define appearCenter vec2(0.5, 0.5)\n\n#define MULTYPLY_DARK vec3(17.0 / 255.0, 46.0 / 255.0, 77.0 / 255.0)\n#define CLEAR_DARK vec3(9.0 / 255.0, 12.0 / 255.0, 15.0 / 255.0)\n#define BG_DARK vec3(37.0 / 255.0, 40.0 / 255.0, 43.0 / 255.0)\n#define BURN_DARK vec3(49.0 / 255.0, 55.0 / 255.0, 61.0 / 255.0)\n#define HARD_LIGHT vec3(172.0 / 255.0, 167.0 / 255.0, 207.0 / 255.0)\n\n#define WHITE vec3(1.0, 1.0, 1.0)\n#define BG_BLUE vec3(26.0 / 255.0, 82.0 / 255.0, 211.0 / 255.0)\n#define BURN_BLUE vec3(10.0 / 255.0, 30.0 / 255.0, 174.0 / 255.0)\n#define BURN_WHITE vec3(20.0 / 255.0, 41.0 / 255.0, 224.0 / 255.0)\n\n// cover\nvec2 getPictureCoordinates(vec2 p, vec2 resolution, vec2 textureSize) {\n\tfloat rs = resolution.x / resolution.y;\n\tfloat ri = textureSize.x / textureSize.y;\n\n\tvec2 new = rs < ri ? \n\t\tvec2(textureSize.x * resolution.y / textureSize.y, resolution.y):\n\t\tvec2(resolution.x, textureSize.y * resolution.x / textureSize.x);\n\n\tvec2 offset = (rs < ri ? \n\t\tvec2((new.x - resolution.x) / 2.0, 0.0):\n\t \tvec2(0.0, (new.y - resolution.y) / 2.0)) / new;\n\n\treturn p * resolution / new + offset;\n}\n\nfloat circle(vec2 p, vec2 center, float radius, float threshold) {\n    float ratio = resolution.x / resolution.y;\n    vec2 scaledP = step(resolution.x, resolution.y) * vec2(p.x * ratio, p.y) + \n        (1.0 - step(resolution.x, resolution.y)) * vec2(p.x, p.y / ratio);\n    vec2 scaledC = step(resolution.x, resolution.y) * vec2(center.x * ratio, center.y) + \n        (1.0 - step(resolution.x, resolution.y)) * vec2(center.x, center.y / ratio);\n\n    vec2 corner = step(center, 1.0 - center);\n    float cornerDistance = distance(center, corner);\n    float cornerRadius = radius * cornerDistance;\n\n    float mappedRadius = cornerRadius * (1.0 + threshold * 2.0) - threshold;\n    float distance = distance(scaledP, scaledC);\n\n    return 1.0 - smoothstep(mappedRadius - threshold, mappedRadius + threshold, distance);\n}\n\n// noise\nfloat hash(float n, float t) { return fract(sin(n + t) * 1e4); }\nfloat hash(vec2 p, float t) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1 + t) * (0.1 + abs(sin(p.y * 13.0 + p.x + t)))); }\n\nfloat hnoise(vec2 x, float t) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat a = hash(i, t);\n\tfloat b = hash(i + vec2(1.0, 0.0), t);\n\tfloat c = hash(i + vec2(0.0, 1.0), t);\n\tfloat d = hash(i + vec2(1.0, 1.0), t);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvoid main() {\n\t// vec2 dVec = appearCenter - vUv.xy;\n\t// float r = appear;\n    float ratio = resolution.x / resolution.y;\n\n\t// dVec.x *= resolution.x / resolution.y;\n\t// float d = length(dVec);\n\n\t// float appearCircle = smoothstep(r - 0.3, r + 0.1, d);\n    float glowWave = circle(vUv.xy, vec2(0.5), 1.0 - mapTransition, 0.05) \n        - circle(vUv.xy, vec2(0.5), 1.0 - mapTransition - 0.1, 0.4);\n\t// float noiseAppearCircle = smoothstep(r - 2.7, r, d);\n\t// float noiseAppearShift = (1.0 - hnoise(vUv.xy * resolution.xy / 2.0, appear)) / 1.0 * noiseAppearCircle;\n\t// vec2 nUv = (vUv.xy - appearCenter) * (1.0 + noiseAppearShift) + appearCenter;\n\n    vec2 nUv = vUv.xy;\n\n    float noiseShift = (hnoise(vUv.xy * resolution.xy / 2.0, mapTransition)) / 1.0 * glowWave;\n    nUv = (nUv.xy - vec2(0.5)) * (1.0 + noiseShift / 7.0) + vec2(0.5);\n\n    vec2 textureUv = getPictureCoordinates(nUv.xy, resolution, textureSize);\n\n    // transition\n    float transitionCircle = circle(vUv.xy, vec2(0.5), 1.0 - mapTransition, 0.05);\n\n    vec4 resultActive = texture2D(activeMap, (textureUv - 0.5) * activeZoom + 0.5);\n    vec4 resultPrevious = texture2D(previousMap, (textureUv - 0.5) * previousZoom + 0.5);\n\n    vec4 result = mix(resultPrevious, resultActive, transitionCircle);\n\n    // collor correctin\n    vec4 original = result;\n    vec4 resultBlueOverlay = result;\n\n    vec3 burnColor = vec3(1.0) - ((vec3(1.0) - original.rgb) / BURN_DARK);\n\n    result.rgb = mix(burnColor, BG_DARK, 0.8);\n    result.rgb = mix(result.rgb, result.rgb * MULTYPLY_DARK, 1.0);\n\n    // cursor\n    float cursorCircle = circle(nUv.xy, cursor.xy, cursorData.y, cursorData.z);\n    float roadMask = smoothstep(0.9, 1.0, original.r);\n\n    resultBlueOverlay.rgb = mix(result.rgb, original.rgb * BG_BLUE, roadMask);\n    result = mix(result, resultBlueOverlay, cursorCircle * cursorData.x);\n\n    vec3 hardLightResult = step(result.rgb, vec3(0.5)) * 2.0 * result.rgb * HARD_LIGHT\n        + (1.0 - step(result.rgb, vec3(0.5))) * (1.0 - 2.0 * (1.0 - result.rgb) * (1.0 - HARD_LIGHT));\n\n\tresult.rgb = mix(result.rgb, hardLightResult, (glowWave * mapTransition / 1.3 + cursorCircle * cursorData.x * 3.0 * (1.0 - MOBILE)));\n\n    gl_FragColor = result;\n}\n"
    }), define("stage/mesh/mesh.decorator", ["dispatcher", "TweenMax", "resize/resize.store", "slide-scroll/slide-scroll.store", "events/cursor.store", "stage/stage.store", "stage/mesh/mesh.store", "page-load/page-load.store", "popup/popup.store", "THREE", "text!glsl/simple.vertex.glsl", "text!glsl/img.fragment.glsl", "utils"], function(s, l, a, t, h, c, u, d, e, p, f, m, i) {
        "use strict";
        var g = "mesh-decorator",
            v = new p.TextureLoader,
            _ = window.devicePixelRatio;
        if (window._registeredDecorators || (window._registeredDecorators = []), -1 === window._registeredDecorators.indexOf(g)) {
            window._registeredDecorators.push(g);
            var o = function() {
                var r, t, s = this._decorators[g],
                    e = this._renderer.getSize(),
                    i = e.width,
                    n = e.height,
                    a = [2048, 1024],
                    o = this._scale,
                    l = [],
                    h = Modernizr.mobile;
                for (t in h = h ? "1.0" : "0.0", e = Math.max(i * o / a[0], n * o / a[1]), this._meshScale = e, h = "#define MOBILE " + h + " \n#define DPR " + _ + " \n" + m, r = new p.ShaderMaterial({
                        uniforms: {
                            activeMap: {
                                type: "t",
                                value: s._textures["map-1"]
                            },
                            previousMap: {
                                type: "t",
                                value: s._textures["map-2"]
                            },
                            resolution: {
                                type: "v2",
                                value: [i * o, n * o]
                            },
                            activeZoom: {
                                type: "f",
                                value: 1
                            },
                            previousZoom: {
                                type: "f",
                                value: 1
                            },
                            appear: {
                                type: "f",
                                value: 0
                            },
                            cursor: {
                                type: "v2",
                                value: [.5, .5]
                            },
                            cursorData: {
                                type: "v3",
                                value: [0, .05, .05]
                            },
                            transitionCenter: {
                                type: "v2",
                                value: [.5, .5]
                            },
                            textureSize: {
                                type: "v2",
                                value: [a[0], a[1]]
                            },
                            mapTransition: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: f,
                        fragmentShader: h
                    }), h = new p.PlaneBufferGeometry(1, 1), (h = new p.Mesh(h, r)).scale.set(i * o, n * o, 1), h.userData.originalScale = [i * o, n * o], this._mainMesh = h, s._mesh = h, s._maps) l.push(function(n) {
                    return new Promise(function(e, t) {
                        var i = v.load(s._maps[n], function(t) {
                            i.premultiplyAlpha = !0, i.needsUpdate = !0, r.uniforms.activeMap.value = i, e()
                        });
                        s._textures[n] = i
                    })
                }(t));
                return r.uniforms.activeMap.value = s._textures["map-blank"], r.uniforms.previousMap.value = s._textures["map-blank"], Promise.all(l)
            };
            return {
                attach: function(t) {
                    var e, i, n, r = {};
                    t._decorators || (t._decorators = {}), t._decorators[g] = r, n = document.getElementById("map-blank").getAttribute("data-src"), e = document.getElementById("map-1").getAttribute("data-src"), i = document.getElementById("map-2").getAttribute("data-src"), r._maps = {
                        "map-blank": n,
                        "map-1": e,
                        "map-2": i
                    }, r._textures = {}, r._map = null, r._defs = {
                        cursorOpacity: .3,
                        cursorRadius: .15
                    }, r._cursor = new p.Vector2(.5), r._targetCursor = new p.Vector2(.5), r._cursorData = new p.Vector3(0, .05, .05), r._targetCursorData = new p.Vector3(.3, .15, .15), r._raycaster = new p.Raycaster, r.build = o.bind(t), r.handleResize = function() {}.bind(t), r.handleDispatcher = function(t) {
                        var e = this._decorators[g],
                            i = (e._mesh, this._renderer.getSize()),
                            n = i.width,
                            i = i.height;
                        "stage:reset" === t.type && (e._map = null), "cursor:force-position" === t.type && (t.x && t.y && (e._forcedCursor = new p.Vector2(t.x / n * 2 - 1, -t.y / i * 2 + 1)), clearTimeout(e._targetCursorTo), e._targetCursorData.set(.5, .03, .007)), "cursor:free-position" !== t.type && "slide-scroll" !== t.type || (e._forcedCursor = null, e._targetCursorTo = setTimeout(function() {
                            e._targetCursorData.set(e._defs.cursorOpacity, e._defs.cursorRadius, e._defs.cursorRadius)
                        }, 0)), "overlay:full-shown" === t.type && (e._targetCursorData.set(.4, 1, .3), e._cursorData.set(.4, 1, .3)), "overlay:hide" === t.type && e._targetCursorData.set(e._defs.cursorOpacity, e._defs.cursorRadius, e._defs.cursorRadius)
                    }.bind(t), r.handleMeshStore = function() {
                        var t = this._decorators[g],
                            e = t._map ? 1 : 0,
                            i = u.getData(),
                            n = h.getData().screenX,
                            r = (h.getData().screenY, t._mesh),
                            s = this._renderer.getSize(),
                            a = s.width,
                            o = s.height;
                        d.getData().loaded, c.getData().ready;
                        t._map !== i.map && ((s = new p.Vector2).x = n / a * 2 - 1, s.y = -n / o * 2 + 1, t._raycaster.setFromCamera(s, this._camera), (s = t._raycaster.intersectObjects([t._mesh])).length ? t._mesh.material.uniforms.transitionCenter.value = [s[0].uv.x, s[0].uv.y] : r.material.uniforms.transitionCenter.value = [.5, .5], t._textures[i.map] && ("map-1" === t._map && "map-2" === i.map ? (l.set(r.material.uniforms.activeZoom, {
                            value: .5,
                            ease: Power2.easeInOut
                        }), l.set(r.material.uniforms.previousZoom, {
                            value: 1,
                            ease: Power2.easeInOut
                        }), l.to(r.material.uniforms.activeZoom, 1.4, {
                            value: 1,
                            ease: Power2.easeInOut
                        }), l.to(r.material.uniforms.previousZoom, 1.4, {
                            value: 1.2,
                            ease: Power2.easeInOut
                        })) : "map-2" === t._map && "map-1" === i.map && (l.set(r.material.uniforms.activeZoom, {
                            value: 2,
                            ease: Power2.easeInOut
                        }), l.set(r.material.uniforms.previousZoom, {
                            value: 1,
                            ease: Power2.easeInOut
                        }), l.to(r.material.uniforms.activeZoom, 1.4, {
                            value: 1,
                            ease: Power2.easeInOut
                        }), l.to(r.material.uniforms.previousZoom, 1.4, {
                            value: .8,
                            ease: Power2.easeInOut
                        })), r.material.uniforms.previousMap.value = r.material.uniforms.activeMap.value, r.material.uniforms.activeMap.value = t._textures[i.map], l.killTweensOf(r.material.uniforms.mapTransition), l.set(r.material.uniforms.mapTransition, {
                            value: 1
                        }), l.to(r.material.uniforms.mapTransition, e, {
                            value: 0,
                            ease: Power2.easeIn
                        }), t._map = i.map))
                    }.bind(t), r.handleCursor = function() {
                        var t = this._decorators[g],
                            e = h.getData().screenX,
                            i = h.getData().screenY,
                            n = h.getData().speed,
                            r = this._renderer.getSize(),
                            s = r.width,
                            r = r.height;
                        new p.Vector2;
                        t._targetCursor.set(e / s * 2 - 1, -i / r * 2 + 1), n = Math.min(20, n), t._stageReady && t._cursorData.add(new p.Vector3(n / 1e4, n / 1e4, 0))
                    }.bind(t), r.handleLoad = function() {
                        var t = this._decorators[g],
                            e = c.getData().ready && d.getData().loaded;
                        t._stageReady || e && setTimeout(function() {
                            t._stageReady = !0
                        }, 1400)
                    }.bind(t), r.loop = function() {
                        var t = this._decorators[g],
                            e = this._renderer.getSize(),
                            i = (e.width, e.height, h.getData(), .04),
                            e = t._cursor.clone();
                        this.derstruct || (t._cursor ? t._forcedCursor ? t._cursor.add(t._forcedCursor.clone().sub(t._cursor).multiplyScalar(.08)) : t._cursor.add(t._targetCursor.clone().sub(t._cursor).multiplyScalar(.08)) : t._cursor = t._targetCursor.clone(), t._stageReady && (t._targetCursorData.x > t._cursorData.x && (i = .1), t._cursorData.add(t._targetCursorData.clone().sub(t._cursorData).multiplyScalar(i))), t._raycaster.setFromCamera(t._cursor, this._camera), (i = t._raycaster.intersectObjects([t._mesh])).length ? (t._mesh.material.uniforms.cursor.value = [i[0].uv.x, i[0].uv.y], this._meshCursor = i[0].point, this._meshCursor.speed = t._cursor.clone().sub(e).length()) : t._mesh.material.uniforms.cursor.value = [.5, .5], t._mesh.material.uniforms.cursorData.value = [t._cursorData.x, t._cursorData.y, t._cursorData.z], requestAnimationFrame(t.loop))
                    }.bind(t), r._transform = {
                        rotate: 0,
                        scale: 1
                    }, r.build().then(function() {
                        t._group.add(r._mesh), r.handleResize(), r.handleMeshStore(), a.subscribe(r.handleResize), s.subscribe(r.handleDispatcher), u.subscribe(r.handleMeshStore), d.subscribe(r.handleMeshStore), h.subscribe(r.handleCursor), c.subscribe(r.handleLoad), d.subscribe(r.handleLoad), r.loop(), s.dispatch({
                            type: "stage:ready"
                        })
                    })
                },
                detach: function(t) {
                    t = t._decorators[g];
                    a.unsubscribe(t.handleResize), s.unsubscribe(t.handleDispatcher), u.unsubscribe(t.handleMeshStore), d.unsubscribe(t.handleMeshStore), h.unsubscribe(t.handleCursor), c.unsubscribe(t.handleLoad), d.unsubscribe(t.handleLoad)
                }
            }
        }
        console.warn('error. decorator with name "' + g + '" already registered')
    }), define("text!glsl/particle.vertex.glsl", [], function() {
        return "// #define minDeviation <- defined in js\n\nattribute float opacity;\nattribute float rand;\n\nuniform float deviation;\nuniform float particleSize;\n\nvarying vec3 vecPos;\nvarying float vOpacity;\n\nvoid main() {\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n\tmvPosition.x += sin((rand + (deviation - minDeviation)) * 10.0) * 60.0 * (minDeviation + position.z / 500.0);\n\tmvPosition.y += cos((rand + (deviation - minDeviation)) * 10.0) * 60.0 * (minDeviation + position.z / 500.0);\n\n\tmvPosition.xy = mvPosition.xy * (1.0 + deviation * (rand + 1.0) * (deviation - minDeviation\n\t\t- minDeviation * 2.0) * 0.05);\n\n\tvOpacity = opacity * (1.0 - deviation * 0.9) * (rand / 2.0);\n\n\tgl_PointSize = 50.0 * particleSize;\n\tgl_Position = projectionMatrix * mvPosition;\n}"
    }), define("text!glsl/particle.fragment.glsl", [], function() {
        return "varying float vOpacity;\nuniform float particleIntencity;\n\nuniform float globalOpacity;\n\n#define bgColor vec3(4.0/255.0, 10.0/255.0, 20.0/255.0)\n\nvoid main() {\n\tvec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n\tvec4 color = vec4(1.0);\n\tvec2 cUv = uv * 2.0 - 1.0;\n\n\tcolor = vec4(0.08 / length(cUv.xy));\n\tcolor.rgb = min(vec3(60.0 * particleIntencity), color.rgb);\n\tcolor.rgb *= bgColor * particleIntencity * 2.0;\n\n\tcolor *= vOpacity;\n\tcolor.a = min(1.0, color.a) *  globalOpacity;\n\n    gl_FragColor = color;\n}\n"
    }), define("text!glsl/point.vertex.glsl", [], function() {
        return "uniform float globalSize;\n\nattribute float opacity;\nattribute float size;\n\nvarying vec3 vecPos;\nvarying float vOpacity;\n\nvoid main() {\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n\tvOpacity = opacity;\n\n\tgl_PointSize = 60.0 * size * globalSize;\n\tgl_Position = projectionMatrix * mvPosition;\n}"
    }), define("text!glsl/point.fragment.glsl", [], function() {
        return "varying vec2 vUv;\nvarying float vOpacity;\n\nuniform float globalOpacity;\n\n#define bgColor vec3(2.0/255.0, 5.0/255.0, 15.0/255.0)\n#define BG_BLUE vec3(26.0 / 255.0, 82.0 / 255.0, 211.0 / 255.0)\n\nvoid main() {\n\tvec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n\tvec2 cUv = uv * 2.0 - 1.0;\n\n\tvec4 color = vec4(1.0);\n\tcolor = vec4(pow(0.6 / length(cUv.xy), 1.3));\n\t\t// + (1.0 - smoothstep(0.0, 0.1, length(cUv.xy))) * 20.0);\n\t\t// + (1.0 - smoothstep(0.0, 1.0, length(cUv.xy))) * 10.0);\n\tcolor.a = (1.0 - smoothstep(0.3, 1.0, length(cUv.xy))) * vOpacity;\n\tcolor.rgb *= bgColor;\n\tcolor.a *= vOpacity;\n\tcolor.rgb = min(vec3(1.0), color.rgb) * vec3(219.0 / 255.0, 235.0 / 255.0, 253.0 / 255.0);\n\n\tcolor.a = min(color.a, 1.0) * globalOpacity * vOpacity;\n\n    gl_FragColor = color;\n}\n"
    }), define("stage/particles/particles.decorator", ["dispatcher", "THREE", "stage/particles/particles.store", "resize/resize.store", "events/cursor.store", "text!glsl/particle.vertex.glsl", "text!glsl/particle.fragment.glsl", "text!glsl/point.vertex.glsl", "text!glsl/point.fragment.glsl"], function(f, m, s, n, r, g, v, p, _) {
        "use strict";
        var y = "parcticles-decorator";
        if (window._registeredDecorators || (window._registeredDecorators = []), -1 === window._registeredDecorators.indexOf(y)) {
            window._registeredDecorators.push(y);
            window.devicePixelRatio;
            var a = function() {
                    function t(r, t) {
                        this.opacity = 0, this.position = new m.Vector3, this.size = 0, this.decorator = r, this.i = t, this.add = function(t) {
                            var e = this.decorator._pointsParticleSystem,
                                i = e.geometry.attributes.position.array,
                                n = (e.geometry.attributes.opacity.array, this),
                                r = this.i;
                            t && (i[3 * r] = t.x, i[3 * r + 1] = t.y, i[3 * r + 2] = 1, this.position.set(t.x, t.y, 1), this.reserved = !0, e.geometry.attributes.position.needsUpdate = !0, TweenMax.killTweensOf(this), TweenMax.to(this, .3, {
                                opacity: 1,
                                size: .5,
                                ease: Power2.easeInOut,
                                delay: .2,
                                onUpdate: function() {
                                    e.geometry.attributes.size.array[r] = n.size, e.geometry.attributes.opacity.array[r] = n.opacity, e.geometry.attributes.size.needsUpdate = !0, e.geometry.attributes.opacity.needsUpdate = !0
                                }
                            }), this._removeTo = setTimeout(n.remove, 1e3))
                        }.bind(this), this.remove = function(t) {
                            var e = this,
                                i = r._pointsParticleSystem,
                                n = this.i,
                                t = void 0 !== t ? t : 1;
                            clearTimeout(this._removeTo), TweenMax.killTweensOf(this), TweenMax.to(this, 1.1 * t, {
                                opacity: 0,
                                size: .3,
                                ease: Power2.easeIn,
                                onUpdate: function() {
                                    i.geometry.attributes.size.array[n] = e.size, i.geometry.attributes.opacity.array[n] = e.opacity, i.geometry.attributes.size.needsUpdate = !0, i.geometry.attributes.opacity.needsUpdate = !0
                                },
                                onComplete: function() {
                                    e.reserved = !1
                                }
                            })
                        }.bind(this)
                    }
                    var e, i = this._decorators[y],
                        n = new m.BufferGeometry,
                        r = new m.BufferGeometry,
                        s = this._renderer.getSize(),
                        a = s.width,
                        s = s.height,
                        o = [],
                        l = [],
                        h = [],
                        s = Math.max(1.1 * a / this._mainMesh.material.uniforms.textureSize.value[0], 1.1 * s / this._mainMesh.material.uniforms.textureSize.value[1]);

                    function c() {
                        return new m.ShaderMaterial({
                            uniforms: {
                                globalSize: {
                                    type: "f",
                                    value: 5
                                },
                                globalOpacity: {
                                    type: "f",
                                    value: 0
                                }
                            },
                            vertexShader: p,
                            fragmentShader: _,
                            blending: m.AdditiveBlending,
                            depthTest: !1,
                            depthWrite: !1,
                            transparent: !0
                        })
                    }

                    function u(t, e, i, n) {
                        t.addAttribute("position", new m.Float32BufferAttribute(e, 3).setDynamic(!0)), t.addAttribute("opacity", new m.Float32BufferAttribute(i, 1).setDynamic(!0)), t.addAttribute("size", new m.Float32BufferAttribute(n, 1).setDynamic(!0))
                    }
                    i._points = [];
                    for (var d = 0; d < i._maxPoints; d++) e = new m.Vector3(0, 0, 1), o.push(e.x, e.y, e.z), l.push(0), h.push(.5), e = new t(i, d), i._points.push(e);
                    u(n, o, l, h), u(r, [-134 * s, -18 * s, 1], [1], [2]), s = new m.Points(n, c()), r = new m.Points(r, c()), i._pointsGeometry = n, i._pointsParticleSystem = s, i._pointsMaterial = s.material, i._mainPoint = r, this._group.add(s), this._group.add(r)
                },
                o = function() {
                    var r, t, a = this._decorators[y],
                        e = a._maps[a._animationMap],
                        n = a._pointsParticleSystem,
                        o = a._geometry.getAttribute("opacity").array,
                        l = a._geometry.getAttribute("position").array,
                        h = a._geometry.getAttribute("rand").array,
                        c = a._trailLength,
                        u = 0,
                        d = this;

                    function p(t) {
                        var e, i, n = Math.floor(Math.random() * r.length);
                        t.path = r[n], t.startPosition = Math.random() * t.path.length * .3, t.position = t.startPosition, t.speed = Math.random() + .5 + a._additionalSpeed, t.active = !1, t.reachedEnd = !1, e = Math.min(t.path.total, Math.max(t.startPosition, t.position - c)), e = Math.floor(e), setTimeout(function() {
                            setTimeout(function() {
                                t.active = !0
                            }, 100), (i = function() {
                                var t = null;
                                if (!a._points) return null;
                                if (!a._spawnPoints) return null;
                                for (var e = a._points.length - 1; 0 <= e; e--)
                                    if (!a._points[e].reserved) {
                                        t = a._points[e];
                                        break
                                    }
                                return t
                            }()) && a._spawnPoints && i.add(t.path.positions[e])
                        }, 1e3 * Math.random())
                    }
                    if (e) {
                        for (t = 0; t < o.length; t++) o[t] = 0;
                        a._stopAnimation ? a._geometry.attributes.opacity.needsUpdate = !0 : (r = e.paths, a._resetAnimations && (a._resetAnimations = !1, a._lines.forEach(function(t) {
                            p(t)
                        })), a._lines.forEach(function(t) {
                            var e, i, n, r;
                            if (t.path || p(t), t.active && (n = t.path, t.position += t.speed, t.position >= n.total + c && p(t), t.position >= n.total && !t.reachedEnd && (t.reachedEnd = !0, a._mainPoint.material.uniforms.globalSize.value += .4, f.dispatch({
                                    type: "particles:path-reached"
                                })), e = Math.max(t.startPosition, t.position - c), i = Math.min(n.total, t.position), e = Math.floor(e), i = Math.floor(i), !(u + c >= a._totalParticles)))
                                for (var s = e; s < i; s++) l[3 * u] = n.positions[s].x, l[3 * u + 1] = n.positions[s].y, n.positions[s].z /= 1.025, r = a._cursor.clone().sub(n.positions[s]).length(), d._meshCursor && r < 100 && (n.positions[s].z += (100 - r) / 100 * 50 * n.rand[s] * d._meshCursor.speed), l[3 * u + 2] = n.positions[s].z, h[u] = n.rand[s], o[u] = Math.max(0, (s - t.position + c) / c), u++
                        }), a._points.forEach(function(t, e) {
                            var i = a._cursor.clone().sub(t.position).length();
                            t.position.z = t.position.z / 1.025, d._meshCursor && i < 100 && (t.position.z += (100 - i) * d._meshCursor.speed), n.geometry.attributes.position.array[3 * e + 2] = t.position.z
                        }), a._mainPoint.material.uniforms.globalSize.value += (3 - a._mainPoint.material.uniforms.globalSize.value) / 20, a._geometry.attributes.opacity.needsUpdate = !0, a._geometry.attributes.rand.needsUpdate = !0, n.geometry.attributes.position.needsUpdate = !0)
                    }
                };
            return {
                attach: function(t) {
                    var e = {},
                        i = t.getElementsByClassName("svg-map");
                    t._decorators || (t._decorators = {}), (t._decorators[y] = e)._map = null, e._hidden = !0, e._animationMap = e._map, e._svgs = i, e._paths = [], e._maps = {}, e._minDeviation = .01, e._sizeMultiplyer = 1, e._dencity = .3, e._systemSize = new m.Vector2(2048, 1024), e._loopIndex = 0, e._maxPoints = 50, e._activePoint = 0, e._cursorSpeed = 0, e._totalParticles = e._maxParticles, e._maxLines = 23, e._trailLength = 100, e._additionalSpeed = 0, e._maxParticles = e._maxLines * e._trailLength, e._cursor = new m.Vector3, e.addParticles = function() {
                        var t, e, i = this._decorators[y],
                            n = new m.BufferGeometry,
                            r = [],
                            s = [],
                            a = [],
                            o = this._renderer.getSize(),
                            l = "#define minDeviation " + i._minDeviation + "\n" + g;
                        i._particles = [];
                        for (var h, c, u, d, p = 0; p < i._maxParticles; p++) e = new m.Vector3(0, 0, 1), i._particles.push(e), r.push(e.x, e.y, e.z), s.push(0), a.push(5 * Math.random());
                        c = r, u = s, d = a, (h = n).addAttribute("position", new m.Float32BufferAttribute(c, 3).setDynamic(!0)), h.addAttribute("opacity", new m.Float32BufferAttribute(u, 1).setDynamic(!0)), h.addAttribute("rand", new m.Float32BufferAttribute(d, 1).setDynamic(!0)), t = new m.Points(n, new m.ShaderMaterial({
                            uniforms: {
                                deviation: {
                                    type: "f",
                                    value: 0
                                },
                                particleIntencity: {
                                    type: "f",
                                    value: 0
                                },
                                particleSize: {
                                    type: "f",
                                    value: 0
                                },
                                globalOpacity: {
                                    type: "f",
                                    value: 0
                                },
                                resolution: {
                                    type: "v2",
                                    value: [o.width, o.height]
                                }
                            },
                            vertexShader: l,
                            fragmentShader: v,
                            blending: m.AdditiveBlending,
                            depthTest: !1,
                            depthWrite: !1,
                            transparent: !0
                        })), i._geometry = n, i._particleSystem = t, i._material = t.material, this._group.add(t)
                    }.bind(t), e.addPoints = a.bind(t), e.buildArrays = function() {
                        var p = this._decorators[y],
                            i = (p._systemSize.x, p._systemSize.y, this._renderer.getSize()),
                            t = i.width,
                            e = i.height,
                            n = Math.max(1.1 * t / this._mainMesh.material.uniforms.textureSize.value[0], 1.1 * e / this._mainMesh.material.uniforms.textureSize.value[1]);
                        p._lines = [], p._scale = n, p._scale = n;
                        for (var r = 0; r < p._maxLines; r++) p._lines.push({
                            path: null,
                            position: 0
                        });
                        Array.prototype.forEach.call(p._svgs, function(t) {
                            var e = t.getAttribute("data-id"),
                                h = [],
                                c = parseInt(t.getAttribute("width")),
                                u = parseInt(t.getAttribute("height")),
                                d = n,
                                t = t.getElementsByTagName("path");
                            "map-vd" === e && (d = Math.min(i.width / c, i.height / u) / 2), Array.prototype.forEach.call(t, function(t) {
                                var e = t.getTotalLength();
                                t._length = e, 0
                            }), Array.prototype.forEach.call(t, function(t) {
                                t._length;
                                for (var e, i, n = t._length * p._dencity, r = [], s = [], a = t._length / n, o = 0, l = 0; l < n; l++) e = (i = t.getPointAtLength(o)).x - c / 2, i = -(i.y - u / 2), e *= d, i *= d, o += a, r.push(new m.Vector3(e, i, 0)), s.push(5 * Math.random());
                                h.push({
                                    svg: t,
                                    length: t._length,
                                    total: n,
                                    positions: r,
                                    rand: s
                                })
                            }), p._maps[e] = {
                                paths: h
                            }
                        })
                    }.bind(t), e.handleStore = function() {
                        var t = this._decorators[y],
                            e = s.getData();
                        e.map && t._map !== e.map && (t._map = e.map, t._animationMap || (t._animationMap = e.map), setTimeout(function() {
                            t.arrange()
                        }, 0))
                    }.bind(t), e.arrange = function() {
                        var t = this._decorators[y],
                            e = (t._geometry, s.getData().particleData),
                            i = t._pointsParticleSystem,
                            n = t._mainPoint,
                            r = s.getData().map;
                        t._sizeMultiplyer = e[1], t.hide(), clearTimeout(t._showTimeout), "map-2" === r ? TweenMax.to(n.material.uniforms.globalOpacity, 1.2, {
                            value: 1,
                            delay: 1,
                            ease: Power1.easeInOut
                        }) : TweenMax.to(n.material.uniforms.globalOpacity, .5, {
                            value: 0,
                            ease: Power1.easeInOut
                        }), e[2] ? TweenMax.to(i.material.uniforms.globalOpacity, 1.2, {
                            value: 1,
                            delay: 1,
                            ease: Power1.easeInOut
                        }) : (TweenMax.to(i.material.uniforms.globalOpacity, .2, {
                            value: 0
                        }), t._points.forEach(function(t) {
                            t.remove(.3)
                        })), t._showTimeout = setTimeout(function() {
                            t.show()
                        }, 400)
                    }.bind(t), e.handleCursor = function() {}.bind(t), e.handleDispatcher = function(t) {
                        var e = this._decorators[y],
                            i = e._pointsParticleSystem,
                            n = e._mainPoint,
                            r = s.getData().map;
                        "stage:particle-hide" === t.type && (clearTimeout(e._showTimeout), e.hide(), TweenMax.to(i.material.uniforms.globalOpacity, .2, {
                            value: 0
                        }), TweenMax.to(n.material.uniforms.globalOpacity, .4, {
                            value: 0
                        }), e._points.forEach(function(t) {
                            t.remove(.3)
                        })), "stage:particle-show" === t.type && (clearTimeout(e._showTimeout), e.show(), TweenMax.to(i.material.uniforms.globalOpacity, .2, {
                            value: 1,
                            delay: .4
                        }), "map-2" === r && TweenMax.to(n.material.uniforms.globalOpacity, .4, {
                            value: 1
                        }))
                    }.bind(t), e.animate = o.bind(t), e.loop = function() {
                        var t, e = this._decorators[y],
                            i = (e._geometry.getAttribute("position").array, n.getData().width, n.getData().height, this._mainMesh.scale, new m.Vector3(0, 0, -1));
                        this._destruct || (this._meshCursor && (t = this._meshCursor.clone(), e._cursor.set(t.x, t.y, 1), e._cursor.applyAxisAngle(i, this._group.rotation.z)), e.animate(), e._geometry.attributes.position.needsUpdate = !0, requestAnimationFrame(e.loop))
                    }.bind(t), e.hide = function() {
                        var t = this._decorators[y],
                            e = t._material;
                        s.getData().particleData;
                        t._hidden || (t._hidden = !0, TweenMax.to(e.uniforms.deviation, .4, {
                            value: 1,
                            ease: Power2.EaseInOut
                        }), TweenMax.to(e.uniforms.globalOpacity, .4, {
                            value: 0,
                            ease: Power2.EaseInOut
                        }))
                    }.bind(t), e.show = function() {
                        var t = this._decorators[y],
                            e = t._material,
                            i = s.getData().particleData;
                        t._hidden && (t._hidden = !1, t._particleSystem.material.uniforms.particleIntencity.value = i[0], t._particleSystem.material.uniforms.particleSize.value = i[1], t._spawnPoints = i[2], t._animationMap = t._map, t._resetAnimations = !0, TweenMax.to(e.uniforms.deviation, .4, {
                            value: t._minDeviation,
                            ease: Power2.EaseInOut
                        }), TweenMax.to(e.uniforms.globalOpacity, .4, {
                            value: 1
                        }))
                    }.bind(t), e.buildArrays(), e.addParticles(), e.addPoints(), e.handleStore(), e.loop(), s.subscribe(e.handleStore), f.subscribe(e.handleDispatcher), r.subscribe(e.handleCursor), f.dispatch({
                        type: "stage:particles-ready"
                    })
                },
                detach: function(t) {
                    t = t._decorators[y];
                    s.unsubscribe(t.handleStore), f.unsubscribe(t.handleDispatcher), r.unsubscribe(t.handleCursor)
                }
            }
        }
        console.warn('error. decorator with name "' + y + '" already registered')
    }), define("text!glsl/post.fragment.glsl", [], function() {
        return "varying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\n\n// uniform vec4 cursor;\n// uniform float hoverDisplacement;\n// uniform float hoverColor;\n\nuniform sampler2D noteMask;\nuniform sampler2D phoneMask;\nuniform float phoneMaskOpacity;\nuniform float noteMaskOpacity;\nuniform vec4 phonePos;\nuniform vec4 notePos;\n\nuniform float fillRadius;\nuniform float clearRadius;\nuniform vec2 fillCenter;\n\nuniform vec2 coverPosition;\nuniform float coverFillHeight;\nuniform float coverOverlayHeight;\n\nuniform float appearTransition;\nuniform vec2 maskTransform;\n// uniform vec2 noiseCenter;\n// uniform float noiseRadius;\n\n#define appearCenter vec2(0.5, 0.5)\n\n#define MULTYPLY_DARK vec3(54.0 / 255.0, 62.0 / 255.0, 69.0 / 255.0)\n#define CLEAR_DARK vec3(9.0 / 255.0, 12.0 / 255.0, 15.0 / 255.0)\n#define BG_DARK vec3(37.0 / 255.0, 40.0 / 255.0, 43.0 / 255.0)\n#define BURN_DARK vec3(49.0 / 255.0, 55.0 / 255.0, 61.0 / 255.0)\n#define HARD_LIGHT vec3(172.0 / 255.0, 167.0 / 255.0, 207.0 / 255.0)\n\n#define WHITE vec3(1.0, 1.0, 1.0)\n#define BG_BLUE vec3(26.0 / 255.0, 82.0 / 255.0, 211.0 / 255.0)\n#define BURN_BLUE vec3(10.0 / 255.0, 30.0 / 255.0, 174.0 / 255.0)\n#define BURN_WHITE vec3(20.0 / 255.0, 41.0 / 255.0, 224.0 / 255.0)\n\nfloat getMask(vec2 p, vec4 maskPos, sampler2D tex) {\n    vec2 tp = p + maskTransform;\n\tvec4 pos = vec4(maskPos.r, 1.0 - maskPos.g, maskPos.b, 1.0 - maskPos.a);\n    vec2 mp = clamp(vec2(0.0), vec2(1.0), (tp - pos.rg) * (1.0 / (pos.ba - pos.rg)));\n\treturn texture2D(tex, mp).r;\n}\n\nfloat circle(vec2 p, vec2 center, float radius, float threshold) {\n    float ratio = resolution.x / resolution.y;\n    vec2 scaledP = step(resolution.x, resolution.y) * vec2(p.x * ratio, p.y) + \n        (1.0 - step(resolution.x, resolution.y)) * vec2(p.x, p.y / ratio);\n    vec2 scaledC = step(resolution.x, resolution.y) * vec2(center.x * ratio, center.y) + \n        (1.0 - step(resolution.x, resolution.y)) * vec2(center.x, center.y / ratio);\n\n    vec2 corner = step(center, 1.0 - center);\n    float cornerDistance = distance(center, corner);\n    float cornerRadius = radius * cornerDistance;\n\n    float mappedRadius = cornerRadius * (1.0 + threshold * 2.0) - threshold;\n    float distance = distance(scaledP, scaledC);\n\n    return 1.0 - smoothstep(mappedRadius - threshold, mappedRadius + threshold, distance);\n}\n\nfloat rect(vec2 p, vec2 pos, float height) {\n    float y = dot(vec2(p.y, 1.0 - p.y), pos);\n    return step(y, height);\n}\n\n// noise\nfloat hash(float n, float t) { return fract(sin(n + t) * 1e4); }\nfloat hash(vec2 p, float t) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1 + t) * (0.1 + abs(sin(p.y * 13.0 + p.x + t)))); }\n\nfloat hnoise(vec2 x, float t) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    float a = hash(i, t);\n    float b = hash(i + vec2(1.0, 0.0), t);\n    float c = hash(i + vec2(0.0, 1.0), t);\n    float d = hash(i + vec2(1.0, 1.0), t);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvoid main() {    \n    float ratio = resolution.x / resolution.y;\n\n    float appearCircle = circle(vUv.xy, vec2(0.5), appearTransition, 0.1);\n    float glowWave = 1.0 - circle(vUv.xy, vec2(0.5), appearTransition - 0.2, 0.4);\n\n    // noise\n    vec2 nUv = vUv.xy;\n\n    // float noiseCircle = circle(vUv.xy, fillCenter, fillRadius, 0.2) -\n    //     circle(vUv.xy, fillCenter, clearRadius - 0.2, 0.2);\n    // float noiseShift1 = (hnoise(vUv.xy * resolution.xy / 2.0,\n    //      fillRadius + clearRadius)) * noiseCircle;\n\n    // glowWave += noiseCircle;\n    // vec2 noiseDVec = noiseCenter - vUv.xy;\n    // noiseDVec.x *= resolution.x / resolution.y;\n    // float noiseD = length(noiseDVec);\n\n    // vec2 nUv = (vUv.xy - noiseCenter) * (1.0 - noiseShift / 4.0) + noiseCenter;\n\n    float noiseShift2 = (hnoise(vUv.xy * resolution.xy / 3.0,\n         appearTransition)) / 1.0 * glowWave;\n    //nUv = (nUv.xy - fillCenter) * (1.0 - noiseShift1 / 6.0) + fillCenter;\n    nUv = (nUv.xy - vec2(0.5)) * (1.0 - noiseShift2 / 6.0) + vec2(0.5);\n\n    // mask\n    float phoneMaskResult = phoneMaskOpacity * (1.0 - getMask(vUv.xy, phonePos, phoneMask));\n    float noteMaskResult = noteMaskOpacity * (1.0 - getMask(vUv.xy, notePos, noteMask));\n    vec2 phoneCenter = phonePos.rg + (phonePos.ba - phonePos.rg) / 2.0;\n    vec2 noteCenter = notePos.rg + (notePos.ba - notePos.rg) / 2.0;\n    float maxMaskResult = max(noteMaskResult, phoneMaskResult);\n\n    vec2 vUvShifted = (nUv.xy - phoneCenter) * (1.0 + phoneMaskResult / 2.0) + phoneCenter;\n    vUvShifted = (vUvShifted.xy - noteCenter) * (1.0 + noteMaskResult / 2.0) + noteCenter;\n\n    vec4 result = texture2D(tDiffuse, vUvShifted.xy);\n    vec4 original = result;\n\n    // color correction\n\n    float fillCircle = circle(vUv.xy, fillCenter, fillRadius, 0.02)\n        - circle(vUv.xy, fillCenter, clearRadius, 0.02);\n    float fillRect = rect(vUv.xy, coverPosition, coverFillHeight);\n\n    vec3 hardLightResult = step(result.rgb, vec3(0.5)) * 2.0 * result.rgb * HARD_LIGHT\n        + (1.0 - step(result.rgb, vec3(0.5))) * (1.0 - 2.0 * (1.0 - result.rgb) * (1.0 - HARD_LIGHT));\n\n    float maskIntencity = max(phoneMaskResult, noteMaskResult);\n\n    result.rgb = mix(result.rgb, hardLightResult, maskIntencity);\n    result.rgb = mix(result.rgb, hardLightResult, glowWave / 1.9);\n\n    result.rgb = mix(result.rgb, WHITE, fillRect);\n    result.rgb = mix(result.rgb, BG_BLUE, fillCircle);\n    result.rgb = mix(result.rgb, CLEAR_DARK, (1.0 - appearCircle));\n\n    gl_FragColor = result;\n}\n"
    }), define("stage/post/post.decorator", ["dispatcher", "slide-scroll/slide-scroll.store", "popup/popup.store", "stage/post/post.store", "stage/stage.store", "resize/resize.store", "events/cursor.store", "page-load/page-load.store", "parallax/parallax.store", "THREE", "TweenMax", "text!glsl/simple.vertex.glsl", "text!glsl/post.fragment.glsl", "utils"], function(s, a, t, o, l, h, e, c, u, d, p, f, m, g) {
        "use strict";
        var v = "post-decorator",
            _ = new d.TextureLoader,
            y = window.devicePixelRatio;
        if (window._registeredDecorators || (window._registeredDecorators = []), -1 === window._registeredDecorators.indexOf(v)) {
            window._registeredDecorators.push(v);
            return {
                attach: function(t) {
                    var e, i, n = {},
                        r = Modernizr.mobile;
                    m = "#define MOBILE " + (r = r ? "1.0" : "0.0") + " \n#define DPR " + y + " \n" + m, t._decorators || (t._decorators = {}), t._decorators[v] = n, e = t._composer, n._maps = {
                        small: document.getElementById("map-1"),
                        big: document.getElementById("map-2")
                    }, n._masks = {
                        phone: document.getElementById("phone-mask"),
                        note: document.getElementById("note-mask")
                    }, n._containers = {
                        phone: document.getElementById("phone-container"),
                        note: document.getElementById("note-container")
                    }, n._slides = {}, n.handleStore = function() {
                        var t = this._decorators[v],
                            e = o.getData(),
                            i = 1,
                            n = a.getData(),
                            n = Math.abs(n.appearDelay);
                        e.scheme.color !== t._scheme && (t._scheme = e.scheme.color, "white" === e.scheme.color && ("up" === e.scheme.direction ? t._mesh.material.uniforms.coverPosition.value = [0, 1] : "down" === e.scheme.direction && (t._mesh.material.uniforms.coverPosition.value = [1, 0]), p.to(t._mesh.material.uniforms.coverFillHeight, .3 * i, {
                            value: 1,
                            delay: .4
                        })), "dark" === e.scheme.color && ("up" === e.scheme.direction ? t._mesh.material.uniforms.coverPosition.value = [1, 0] : "down" === e.scheme.direction && (t._mesh.material.uniforms.coverPosition.value = [0, 1]), p.to(t._mesh.material.uniforms.coverFillHeight, .3 * i, {
                            value: 0,
                            delay: .4
                        }))), t._visibleMask !== e.mask && (void 0 === t._visibleMask && (i = 0), p.killTweensOf(t._mesh.material.uniforms.phoneMaskOpacity), p.killTweensOf(t._mesh.material.uniforms.noteMaskOpacity), "phone-mask" === e.mask && (p.to(t._mesh.material.uniforms.phoneMaskOpacity, .45 * i, {
                            value: 1,
                            delay: (1.6 + n / 1e3) * i
                        }), "note-mask" === t._visibleMask && p.to(t._mesh.material.uniforms.noteMaskOpacity, .35 * i, {
                            value: 0
                        })), "note-mask" === e.mask && (p.to(t._mesh.material.uniforms.noteMaskOpacity, .45 * i, {
                            value: 1,
                            delay: (1.6 + n / 1e3) * i
                        }), "phone-mask" === t._visibleMask && p.to(t._mesh.material.uniforms.phoneMaskOpacity, .35 * i, {
                            value: 0
                        })), null === e.mask && ("phone-mask" === t._visibleMask ? p.to(t._mesh.material.uniforms.phoneMaskOpacity, .35 * i, {
                            value: 0
                        }) : "note-mask" === t._visibleMask && p.to(t._mesh.material.uniforms.noteMaskOpacity, .35 * i, {
                            value: 0
                        })), t._visibleMask = e.mask)
                    }.bind(t), n.handleParallax = function() {
                        var t = this._decorators[v],
                            e = this._renderer.getSize(),
                            i = e.width,
                            n = e.height,
                            r = 5 * u.getData().x,
                            e = 15 * u.getData().y;
                        t._mesh.material.uniforms.maskTransform.value = [-r / i, e / n]
                    }.bind(t), n.handleResize = function() {
                        var i, n, r, s, a, o = this._decorators[v],
                            l = this;
                        clearTimeout(o._resizeTimeout), o._resizeTimeout = setTimeout(function() {
                            var t = l._renderer.getSize(),
                                e = t.width,
                                t = t.height;
                            o._mesh && (o._slides.phone && (i = g.offsetFrom(o._containers.phone, o._slides.phone), n = i.left, r = i.top, s = o._containers.phone.clientWidth, a = o._containers.phone.clientHeight, o._mesh.material.uniforms.phonePos.value = [n / e, r / t, (s + n) / e, (a + r) / t]), o._slides.note && (i = g.offsetFrom(o._containers.note, o._slides.note), n = i.left, r = i.top, s = o._containers.note.clientWidth, a = o._containers.note.clientHeight, o._mesh.material.uniforms.notePos.value = [n / e, r / t, (s + n) / e, (a + r) / t]))
                        }, 30)
                    }.bind(t), n.handleDispatcher = function(t) {
                        var e = this._decorators[v],
                            i = this._renderer.getSize(),
                            n = i.width,
                            r = i.height,
                            i = 1;
                        a.getData().items["main-scroll"], l.getData().ready;
                        "content:replaced" === t.type && (e._containers = {
                            phone: document.getElementById("phone-container"),
                            note: document.getElementById("note-container")
                        }, e._slides = {}, e._containers.phone && (e._slides.phone = e._containers.phone.closest(".s-slide")), e._containers.note && (e._slides.note = e._containers.note.closest(".s-slide")), e.handleResize()), "overlay:show" === t.type && (t.hasOwnProperty("speed") && (i = t.speed), e._mesh.material.uniforms.fillCenter.value = [t.x / n, 1 - t.y / r], p.killTweensOf(e._mesh.material.uniforms.overlayIntencity), p.killTweensOf(e._mesh.material.uniforms.fillRadius), p.killTweensOf(e._mesh.material.uniforms.clearRadius), p.set(e._mesh.material.uniforms.fillRadius, {
                            value: 0
                        }), p.set(e._mesh.material.uniforms.clearRadius, {
                            value: 0
                        }), p.to(e._mesh.material.uniforms.fillRadius, .45 * i, {
                            value: 1,
                            ease: Power2.easeIn,
                            delay: .2 * i,
                            onComplete: function() {
                                s.dispatch({
                                    type: "overlay:full-shown"
                                })
                            }
                        }), e._visibleMask && (p.killTweensOf(e._mesh.material.uniforms.phoneMaskOpacity), p.killTweensOf(e._mesh.material.uniforms.noteMaskOpacity), "phone-mask" === e._visibleMask ? p.to(e._mesh.material.uniforms.phoneMaskOpacity, .45 * i, {
                            value: 0,
                            ease: new Ease(p._easings.strong)
                        }) : "note-mask" === e._visibleMask && p.to(e._mesh.material.uniforms.noteMaskOpacity, .45 * i, {
                            value: 0,
                            ease: new Ease(p._easings.strong)
                        }))), "overlay:hide" === t.type && (t.hasOwnProperty("speed") && (i = t.speed), e._mesh.material.uniforms.fillCenter.value = [t.x / n, 1 - t.y / r], p.killTweensOf(e._mesh.material.uniforms.fillRadius), p.killTweensOf(e._mesh.material.uniforms.clearRadius), p.to(e._mesh.material.uniforms.clearRadius, .7 * i, {
                            value: 1,
                            ease: Power2.easeInOut
                        }), e._visibleMask && (p.killTweensOf(e._mesh.material.uniforms.phoneMaskOpacity), p.killTweensOf(e._mesh.material.uniforms.noteMaskOpacity), "phone-mask" === e._visibleMask ? p.to(e._mesh.material.uniforms.phoneMaskOpacity, .7 * i, {
                            value: 1,
                            delay: 1.2 * i,
                            ease: new Ease(p._easings.basic)
                        }) : "note-mask" === e._visibleMask && p.to(e._mesh.material.uniforms.noteMaskOpacity, .7 * i, {
                            value: 1,
                            delay: 1.2 * i,
                            ease: new Ease(p._easings.basic)
                        }))), "stage:reset" === t.type && (p.killTweensOf(e._mesh.material.uniforms.phoneMaskOpacity), p.killTweensOf(e._mesh.material.uniforms.noteMaskOpacity), p.to(e._mesh.material.uniforms.phoneMaskOpacity, 0, {
                            value: 0
                        }), p.to(e._mesh.material.uniforms.noteMaskOpacity, 0, {
                            value: 0
                        }), e._visibleMask = null, p.to(e._mesh.material.uniforms.coverFillHeight, 0, {
                            value: 0
                        }))
                    }.bind(t), n.handleLoad = function() {
                        var t = this._decorators[v],
                            e = c.getData().loaded,
                            i = l.getData().ready,
                            n = this;
                        e && i && (setTimeout(function() {
                            n.style.opacity = 1
                        }, 50), p.to(t._mesh.material.uniforms.appearTransition, 2, {
                            value: 1.2,
                            ease: Power2.easeInOut
                        }))
                    }.bind(t), n._containers.phone && (n._slides.phone = n._containers.phone.closest(".s-slide")), n._containers.note && (n._slides.note = n._containers.note.closest(".s-slide")), n._colorMix = {
                        black: 1,
                        blue: 0,
                        white: 0
                    }, n._scheme = "dark", n._visibleMask = void 0, i = _.load(n._masks.note.src), r = _.load(n._masks.phone.src), i.minFilter = d.LinearFilter, i.magFilter = d.LinearFilter, r.minFilter = d.LinearFilter, r.magFilter = d.LinearFilter, t = t._renderer.getSize(), n._mesh = e.shaderPass({
                        vertexShader: f,
                        fragmentShader: m,
                        uniforms: {
                            noteMask: {
                                type: "t",
                                value: i
                            },
                            phoneMask: {
                                type: "t",
                                value: r
                            },
                            noteMaskOpacity: {
                                type: "f",
                                value: 0
                            },
                            phoneMaskOpacity: {
                                type: "f",
                                value: 0
                            },
                            notePos: {
                                type: "v4",
                                value: [0, 0, 0, 0]
                            },
                            phonePos: {
                                type: "v4",
                                value: [0, 0, 0, 0]
                            },
                            maskTransform: {
                                type: "v2",
                                value: [0, 0]
                            },
                            fillRadius: {
                                type: "f",
                                value: 0
                            },
                            clearRadius: {
                                type: "f",
                                value: 0
                            },
                            fillCenter: {
                                type: "v2",
                                value: [.5, .5]
                            },
                            coverPosition: {
                                type: "v2",
                                value: [1, 0]
                            },
                            coverOverlayHeight: {
                                type: "f",
                                value: 0
                            },
                            coverFillHeight: {
                                this: "f",
                                value: 0
                            },
                            appearTransition: {
                                this: "f",
                                value: 1.2
                            },
                            resolution: {
                                type: "v2",
                                value: [t.width, t.height]
                            }
                        }
                    }).mesh, n.handleStore(), n.handleResize(), n.handleLoad(), n.handleParallax(), o.subscribe(n.handleStore), h.subscribe(n.handleResize), s.subscribe(n.handleDispatcher), c.subscribe(n.handleLoad), l.subscribe(n.handleLoad), u.subscribe(n.handleParallax)
                },
                detach: function(t) {
                    t = t._decorators[v];
                    o.unsubscribe(t.handleStore), h.unsubscribe(t.handleResize), s.unsubscribe(t.handleDispatcher), c.unsubscribe(t.handleLoad), l.unsubscribe(t.handleLoad), u.unsubscribe(t.handleParallax)
                }
            }
        }
        console.warn('error. decorator with name "' + v + '" already registered')
    }), define("stage/stage.component", ["dispatcher", "THREE", "resize/resize.store", "scroll/scroll.store", "events/cursor.store", "popup/popup.store", "slide-scroll/slide-scroll.store", "stage/stage.store", "stage/stage-transform.store", "page-load/page-load.store", "TweenMax", "bezier", "utils/Composer", "utils", "stage/mesh/mesh.decorator", "stage/particles/particles.decorator", "stage/post/post.decorator"], function(n, a, s, r, o, e, t, l, h, c, u, i, d, p, f, m, g) {
        "use strict";
        var v = window.devicePixelRatio,
            _ = Object.create(HTMLElement.prototype);
        new a.TextureLoader;
        return _.createdCallback = function() {
            this._loopIndex = 0, this._destruct = !1, this._onScreen = !0, this._zoom = 0, this._transform = {
                rotate: 0,
                scale: 1
            }, this.buildStage = function(t) {
                var e, i, n = this.clientWidth,
                    r = this.clientHeight,
                    s = 90 * Math.atan(r / 2 / 1e3);
                return this._cameraDistance = 1e3, t = t || {}, (e = new a.PerspectiveCamera(s, n / r, 100, 2e3)).userData.distance = 1e3, e.userData.originalDistance = 1e3, e.userData.deviation = new a.Vector2(0, 0), e.userData.targetDeviation = new a.Vector2(0, 0), e.up = new a.Vector3(0, 1, 0), e.position.set(0, 0, 1e3), s = new a.Scene, t.renderer && ((i = new a.WebGLRenderer({
                    antialias: !0,
                    alpha: !0,
                    premultipliedAlpha: !1
                })).setPixelRatio(1), i.setSize(n, r), i.domElement.style.width = "100%", i.domElement.style.height = "100%", i.setClearColor(592911), this.appendChild(i.domElement), this._renderer = i), Promise.resolve({
                    scene: s,
                    camera: e,
                    renderer: i
                })
            }.bind(this), this.handleResize = function() {
                var t = this.clientWidth,
                    e = this.clientHeight;
                this._offsetTop = p.offset(this).top, this._offsetLeft = p.offset(this).left, this._renderer && (this._ww === t && this._wh === e || (this._ww = t, this._wh = e, this._renderer.setPixelRatio(v), this._renderer.setSize(t, e), this._composer.resize(), this.handleScroll()))
            }.bind(this), this.handleScroll = function() {}.bind(this), this.handleCursor = function() {
                var t = o.getData().screenX,
                    e = o.getData().screenY,
                    i = s.getData().width,
                    n = s.getData().height,
                    r = this._camera;
                c.getData().loaded && (t = 2 * -(t / i - .5) * 80, e = 2 * (e / n - .5) * 80, r.userData.targetDeviation.set(t, e))
            }.bind(this), this.handleDispatcher = function(t) {}.bind(this), this.handleStageTransform = function() {
                var e = this._camera,
                    i = this._group,
                    n = this,
                    t = h.getData().transform;
                c.getData().loaded, l.getData().ready;
                u.killTweensOf(n._transform), i.rotateZ(0), e.position.z = 0, u.to(n._transform, 1.4, {
                    rotate: t[0] / 360 * Math.PI,
                    scale: t[1],
                    ease: Power2.easeInOut,
                    onUpdate: function() {
                        var t = new a.Euler(0, 0, n._transform.rotate, "XYZ");
                        i.setRotationFromEuler(t), e.position.setComponent(2, 1e3 / n._transform.scale), e.userData.distance = 1e3 / n._transform.scale
                    }
                })
            }.bind(this), this.loop = function() {
                var t = this._camera;
                this._destruct || (this._onScreen && (t.position.set(0, 0, t.userData.distance), t.userData.deviation.add(t.userData.targetDeviation.clone().sub(t.userData.deviation).multiplyScalar(.05)), t.translateX(t.userData.deviation.x), t.translateY(t.userData.deviation.y), t.lookAt(0, 0, 0), this.render()), requestAnimationFrame(this.loop))
            }.bind(this), this.render = function() {
                var t = this._composer;
                this._loopIndex++, t.render()
            }.bind(this)
        }, _.attachedCallback = function() {
            var i = this;
            this.clisentWidth, this.clisentHeight;
            this._id = this.getAttribute("data-id"), this._touch = Modernizr.touchevents ? 1 : 0, this._scale = 1.1, Modernizr.webgl && this.buildStage({
                renderer: !0
            }).then(function(t) {
                i._renderer.getSize();
                var e = document.querySelector(".page-wrapper");
                i._scene = t.scene, i._camera = t.camera, i._composer = new d(i._renderer), i._composer.renderPass(i._scene, i._camera), i._group = new a.Group, i._scene.add(i._group), f.attach(i), m.attach(i), g.attach(i), i.handleResize(), i.handleScroll(), i.handleCursor(), i.handleStageTransform(), s.subscribe(i.handleResize), r.subscribe(i.handleScroll), n.subscribe(i.handleDispatcher), o.subscribe(i.handleCursor), h.subscribe(i.handleStageTransform), l.subscribe(i.handleStageTransform), c.subscribe(i.handleStageTransform), i.loop(), i.render(), e.classList.add("stage-active")
            })
        }, _.detachedCallback = function() {
            var t = document.querySelector(".page-wrapper");
            this._destruct = !0, f.detach(this), m.detach(self), g.detach(this), s.unsubscribe(this.handleResize), r.unsubscribe(this.handleScroll), n.unsubscribe(this.handleDispatcher), e.unsubscribe(this.handlePopup), l.unsubscribe(this.handleStageStore), this._renderer && (this._renderer.forceContextLoss(), this._renderer.context = null, this._renderer.domElement = null, this._renderer = null), t.classList.remove("stage-active")
        }, document.registerElement("stage-map", {
            prototype: _
        }), _
    }), define("parallax/parallax-wrapper.component", ["dispatcher", "parallax/parallax.store", "slide-scroll/slide-scroll.store", "THREE"], function(t, r, s, e) {
        "use strict";
        var i = Object.create(HTMLDivElement.prototype);
        i.createdCallback = function() {
            this.handleParallax = function() {
                var t = r.getData().transformationMatrix,
                    e = r.getData().x,
                    i = r.getData().y,
                    n = s.getData().items["main-scroll"];
                this._destruct || n && n.index === this._index && (this._rotated ? this.style.transform = "matrix3d(" + t.elements.join(",") + ")" : this._svgSlider || (this.style.transform = "translateX(" + 5 * e + "px) translateY(" + 15 * i + "px)"))
            }.bind(this)
        }, i.attachedCallback = function() {
            var t = document.getElementsByClassName("s-slide");
            this._rotated = this.classList.contains("parallax-3d"), this._svgSlider = this.classList.contains("svg-slider-parallax"), this._parent = this.closest(".s-slide"), this._index = Array.prototype.indexOf.call(t, this._parent), this.handleParallax(), r.subscribe(this.handleParallax)
        }, i.detachedCallback = function() {
            this._destruct = !0
        }, document.registerElement("parallax-wrapper", {
            prototype: i,
            extends: "div"
        })
    }), define("decor/svg-border.component", ["dispatcher"], function(t) {
        "use strict";
        var e = Object.create(HTMLDivElement.prototype),
            i = 0;
        e.createdCallback = function() {
            this.handleResize = function() {
                var t = this.clientWidth,
                    e = this.clientHeight;
                t === this._w && e === this._h || (this._w = t, this._h = e, this._path && this.draw())
            }.bind(this), this.handleMouseenter = function() {}.bind(this), this.handleMouseleave = function() {}.bind(this), this.draw = function() {
                var t, e, i, n = "http://www.w3.org/2000/svg",
                    r = this._h / 2 - 1,
                    s = this._w - 2,
                    a = this._h - 2,
                    o = "";
                this._path ? (t = this._path, i = this._svg) : (i = document.createElementNS(n, "svg"), (e = document.createElementNS(n, "defs")).innerHTML = '<linearGradient id="linear-' + this._id + '" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%"   stop-color="#004cf8"/><stop offset="100%" stop-color="#74b4f6"/></linearGradient>', (t = document.createElementNS(n, "path")).setAttribute("stroke", "url(#linear-" + this._id + ")"), i.appendChild(e), i.appendChild(t), this.appendChild(i), this._path = t, this._svg = i), i.setAttribute("width", this._w + 2), i.setAttribute("height", this._h + 2), i.setAttribute("viewBox", "0 0 " + (this._w + 2) + " " + (this._h + 2)), o += "M" + r + " 0", a < s && (o += "L" + (s - r) + " 0"), o += "A" + r + " " + r + " 0 0 1 " + (s - r) + " " + a, a < s && (o += "L" + r + " " + a), o += "A" + r + " " + r + " 0 0 1 " + r + " 0", o += "Z", t.setAttribute("d", o), t.setAttribute("transform", "translate(2, 2)"), this._path = t
            }.bind(this)
        }, e.attachedCallback = function() {
            this.closest(".fake") || (this._id = i++, this._button = this.closest(".arr-btn"), this._button && (this._button.addEventListener("mouseenter", this.handleMouseenter), this._button.addEventListener("mouseleave", this.handleMouseleave)), this.classList.add("svg-border"), this.handleResize(), this.draw())
        }, e.detachedCallback = function() {}, document.registerElement("svg-border", {
            prototype: e,
            extends: "div"
        })
    }), define("decor/link-interactive.component", ["dispatcher", "decor/cursor-interactive.component"], function(t, e) {
        "use strict";
        var i = Object.create(HTMLAnchorElement.prototype);
        i.createdCallback = function() {
            e.createdCallback.apply(this)
        }, i.attachedCallback = function() {
            e.attachedCallback.apply(this)
        }, i.detachedCallback = function() {
            e.detachedCallback.apply(this)
        }, document.registerElement("link-interactive", {
            prototype: i,
            extends: "a"
        })
    }), define("decor/basic-link.component", ["dispatcher", "router/inner-link.component", "decor/cursor-interactive.component"], function(t, e, i) {
        "use strict";
        var n = Object.create(HTMLAnchorElement.prototype);
        return n.createdCallback = function() {
            e.createdCallback.apply(this), i.createdCallback.apply(this)
        }, n.attachedCallback = function() {
            e.attachedCallback.apply(this), i.attachedCallback.apply(this)
        }, n.detachedCallback = function() {
            e.detachedCallback.apply(this), i.detachedCallback.apply(this)
        }, document.registerElement("basic-link", {
            prototype: n,
            extends: "a"
        }), n
    }), define("decor/logo-link.component", ["dispatcher", "decor/basic-link.component", "slide-scroll/slide-scroll.store", "popup/popup.store", "events/cursor.store"], function(r, t, e, s, a) {
        "use strict";
        var i = Object.create(HTMLAnchorElement.prototype);
        i.createdCallback = function() {
            t.createdCallback.apply(this), this.additionalClickHanlder = function() {
                var t = "main-scroll",
                    e = s.getData().active,
                    i = a.getData().screenX,
                    n = a.getData().screenY;
                this.classList.contains("active") && (clearTimeout(this._to), e ? (r.dispatch({
                    type: "popup:close-all",
                    userData: {
                        x: i,
                        y: n
                    }
                }), this._to = setTimeout(function() {
                    r.dispatch({
                        type: "slide-scroll:to",
                        id: t,
                        index: 0
                    })
                }, 300)) : r.dispatch({
                    type: "slide-scroll:to",
                    id: t,
                    index: 0
                }))
            }.bind(this), this.handleSlide = function() {
                var t = e.getData().items["main-scroll"];
                t && (clearTimeout(self._to), 0 === t.index && this._active ? this._disabled || (this._disabled = !0, this.classList.add("disabled")) : this._disabled && (this._disabled = !1, this.classList.remove("disabled")))
            }.bind(this), this._disabledClass = "disabled", this._disabled = !1
        }, i.attachedCallback = function() {
            this.addEventListener("click", this.additionalClickHanlder), t.attachedCallback.apply(this), this.handleSlide(), e.subscribe(this.handleSlide)
        }, i.detachedCallback = function() {
            t.detachedCallback.apply(this), e.unsubscribe(this.handleSlide)
        }, document.registerElement("logo-link", {
            prototype: i,
            extends: "a"
        })
    }), define("decor/menu-button.component", ["dispatcher", "popup/popup.store", "popup/popup-toggle.component", "decor/cursor-interactive.component"], function(t, e, i, n) {
        "use strict";
        var r = Object.create(HTMLButtonElement.prototype);
        return r.createdCallback = function() {
            i.createdCallback.apply(this), n.createdCallback.apply(this), this.handleStoreProto = this.handleStore, this.handleStore = function() {
                e.getData().active;
                var t = this.getBoundingClientRect();
                t.left, t.width, t.top, t.height;
                this.handleStoreProto(), this.classList.contains("close-all")
            }.bind(this)
        }, r.attachedCallback = function() {
            i.attachedCallback.apply(this), n.attachedCallback.apply(this)
        }, r.detachedCallback = function() {
            i.detachedCallback.apply(this), n.detachedCallback.apply(this)
        }, document.registerElement("menu-button", {
            extends: "button",
            prototype: r
        }), r
    }), define("decor/scroll-links.component", ["dispatcher"], function(t) {
        "use strict";
        var e = Object.create(HTMLElement.prototype);
        e.createdCallback = function() {
            this.handleMouseenter = function(t, e) {
                e -= (this._total - 1) / 2, e = "scaleX(1.03) scaleY(1.06) translateX(" + 5 * -e + "px) translateZ(-30px) rotateY(" + 7 * e + "deg)";
                this.classList.add("hover"), this._border.style.transform = e
            }.bind(this), this.handleMouseleave = function() {
                this.classList.remove("hover"), this._border.style.transform = "scale(1)"
            }.bind(this)
        }, e.attachedCallback = function() {
            var i = this;
            this._border = this.getElementsByClassName("border")[0], this._buttons = this.getElementsByTagName("button"), this._total = this._buttons.length, Array.prototype.forEach.call(this._buttons, function(t, e) {
                t.addEventListener("mouseenter", function() {
                    i.handleMouseenter(t, e)
                })
            }), this.addEventListener("mouseleave", this.handleMouseleave)
        }, e.detachedCallback = function() {}, document.registerElement("scroll-links", {
            prototype: e
        })
    }), define("decor/float-button.component", ["dispatcher", "decor/cursor-interactive.component"], function(t, e) {
        "use strict";
        var i = Object.create(HTMLButtonElement.prototype);
        i.createdCallback = function() {
            e.createdCallback.apply(this), this._targetX = 0, this._targetY = 0, this._targetZ = 0, this._targetScale = 1, this._x = 0, this._y = 0, this._z = 0, this._scale = 1, this.loop = function() {
                var t;
                this._destruct || ((.001 < Math.abs(this._targetX - this._x) || .001 < Math.abs(this._targetZ - this._z) || .001 < Math.abs(this._targetScale - this._scale)) && (this._x += (this._targetX - this._x) / 20, this._z += (this._targetZ - this._z) / 20, this._scale += (this._targetScale - this._scale) / 20, t = "scaleX(" + this._scale + ") scaleY(" + this._scale + ")translateX(" + -this._x / 40 + "px) translateZ(" + this._z + "px) rotateY(" + this._x / 25 + "deg)", this._border.style.webkitTransform = this._border.style.transform = t), requestAnimationFrame(this.loop))
            }.bind(this), this.handleResize = function() {
                this._w = this.clientWidth
            }.bind(this), this.additionalHandleMouseleave = function() {
                this._targetScale = 1, this._targetZ = 0, this._targetX = 0, this._targetY = 0
            }.bind(this), this.additionalHandleMouseenter = function() {
                this._targetScale = 1.07, this._targetZ = -30
            }.bind(this), this.additionalHandleMousemove = function(t) {
                var e = t.offsetX,
                    t = t.offsetY;
                e && t && (this._targetX = e - this._w / 2)
            }.bind(this)
        }, i.attachedCallback = function() {
            e.attachedCallback.apply(this), this._border = this.getElementsByClassName("border")[0], this.handleResize(), this.addEventListener("mouseenter", this.additionalHandleMouseenter), this.addEventListener("mousemove", this.additionalHandleMousemove), this.addEventListener("mouseleave", this.additionalHandleMouseleave), this.loop()
        }, i.detachedCallback = function() {
            e.detachedCallback.apply(this), this._destruct = !0
        }, document.registerElement("float-button", {
            prototype: i,
            extends: "button"
        })
    });
var __path = "resources",
    pathElements = document.getElementsByName("resources-path"),
    __path = pathElements && pathElements.length ? pathElements[0].content : document.getElementsByTagName("head")[0].getAttribute("data-path");
"/" !== __path.slice(-1) && (__path += "/"), require.config({
    urlArgs: "v0",
    baseUrl: "resources/js/modules",
    waitSeconds: 2e3,
    paths: {
        fastClick: "../libs/fstClick",
        text: "../libs/text",
        TweenMax: "../libs/TweenMax",
        DrawSVGPlugin: "../libs/DrawSVGPlugin",
        THREE: "../libs/THREE",
        bezier: "../libs/bezier-easing",
        SplitText: "../libs/SplitText"
    },
    shim: {
        THREE: {
            exports: "THREE"
        },
        bezier: {
            exports: "bezier"
        }
    }
}), require(["helpers", "dispatcher", "domReady", "page-load/preloader-simple.view", "page-helper/page-helper.view", "trigger/slide-trigger.view", "events/keyboard.view", "accessibility/outliner.view", "touch/touch.view", "scroll/synth-scroll.view", "page-load/preloader-full.component", "map/map-link.component", "slide-scroll/slide-scroll.component", "slide-scroll/slide-scroll-control.component", "slide-scroll/slide-scroll-wrapper.component", "slide-scroll/slide-transition.component", "slide-helper/slide-helper.component", "appear/content-appear.component", "drop-down/drop-down.component", "drop-down/accordeon.component", "popup/popup.component", "popup/appear-popup.component", "popup/popup-toggle.component", "popup/popup-helper.view", "router/router.view", "router/inner-link.component", "router/page-transition.component", "scroll/scroll-blocker-css.view", "form/form.component", "form/input-wrapper.component", "form/form-response.component", "slider/text-slider.component", "slider/slider-hover-group.component", "slider/slider-accordeon-control.component", "svg/big-svg.component", "stage/stage.component", "parallax/parallax-wrapper.component", "decor/svg-border.component", "decor/cursor-interactive.component", "decor/link-interactive.component", "decor/basic-link.component", "decor/logo-link.component", "decor/menu-button.component", "decor/scroll-links.component", "decor/float-button.component"], function(t, e, i, n, r, s) {
    i(function() {
        n.init(), r.init(), s.init(), e.dispatch({
            type: "dom:ready"
        })
    })
}), define("../app", function() {});